---
title: 计算机组成原理
author: TimeYe
tags: ["note"]
---

[TOC]



# 计算机系统概述

## 计算机系统的组成

![image-20250426150652679](https://img.tynote.cn/img/typora/202504261506813.png#400h)

## 计算机的发展

### **1️⃣电子数字计算机的发展历程**

![image-20250426151024442](https://img.tynote.cn/img/typora/202504261510504.png#400h)

**背后的科学家**

![image-20250426151113129](https://img.tynote.cn/img/typora/202504261511194.png#400h)

### **2️⃣摩尔定律**

![image-20250426151216168](https://img.tynote.cn/img/typora/202504261512233.png#400h)

### **3️⃣cpu从1970年到2015年的发展情况**

![image-20250426151328771](https://img.tynote.cn/img/typora/202504261513840.png#400h)

### **4️⃣软件发展**

![image-20250426151607990](https://img.tynote.cn/img/typora/202504261516047.png#400h)

### **5️⃣当前计算机发展趋势**

![image-20250426151733535](https://img.tynote.cn/img/typora/202504261517604.png#400h)

## 计算机硬件

### **1️⃣冯•诺依曼计算机结构**

![image-20250426151920393](https://img.tynote.cn/img/typora/202504261519472.png#400h)

![image-20250426152218275](https://img.tynote.cn/img/typora/202504261522336.png#400h)

### **2️⃣冯•诺依曼计算机的特点**

![image-20250426152334299](https://img.tynote.cn/img/typora/202504261523368.png#400h)

​	**冯诺依曼机的基本工作方式是<font color='blue'>控制流驱动方式</font>，也就是按照指令的执行序列，依次读取指令，然后根据指令所含的控制信息，调用数据信息进行处理。因此，在执行程序的过程中，始终以控制信息流为驱动工作的因素，而数据信息流则是被动地调用处理。**

![image-20250426152635239](https://img.tynote.cn/img/typora/202504261526304.png#400h)

​	**可以看到，控制器与其他4个部件之间，都通过控制线和反馈线相连，这是因为这些部件需要在控制器的控制下协调工作。控制器通过控制线给其他部件发送控制信号，命令这些部件执行相应的任务，而其他部件通过反馈线将自身状态和任务完成情况反馈给控制器。**

​	**例如，在控制器控制下，将用户信息通过输入设备、运算器，存放到存储器中**

![image-20250426153154886](https://img.tynote.cn/img/typora/202504261531939.png#400h)

​	**又例如，在控制器的控制下，将存储器中的信息，通过运算器、输出设备，进行输出**

![image-20250426153309381](https://img.tynote.cn/img/typora/202504261533438.png#400h)

### **3️⃣冯诺依曼计算机的缺点及改进**

- **缺点**

![image-20250426153449642](https://img.tynote.cn/img/typora/202504261534701.png#400h)

- **改进**

​	**现代计算机以存储器为中心**

![image-20250426153633865](https://img.tynote.cn/img/typora/202504261536926.png#400h)

### **4️⃣现代计算机的结构**

- **输入输出设备**

![image-20250426153731587](https://img.tynote.cn/img/typora/202504261537658.png#400h)

​    

- **存储器**

![image-20250426153801061](https://img.tynote.cn/img/typora/202504261538123.png#400h)

**运算器和控制器**

![image-20250426153829451](https://img.tynote.cn/img/typora/202504261538519.png#400h)

<<font color='red'>**注**</font>>

![image-20250426154126391](https://img.tynote.cn/img/typora/202504261541448.png#400h)

​	**运算器除了包含算术逻辑单元外，还包含了一些相关寄存器。在大规模集成电路制作工艺出现后，运算器和控制器往往被集成在同一颗芯片上，称为中央处理器（CPU）**

**现代计算机结构示意图**

![image-20250426154149097](https://img.tynote.cn/img/typora/202504261541168.png#400h)

### 小结

![image-20250426154655822](https://img.tynote.cn/img/typora/202504261546971.png)

## 计算机软件

### **1️⃣计算机软件的分类**

![image-202504261552611](https://img.tynote.cn/img/typora/202504261552611.png#400h)

### **2️⃣计算机软件的发展**

![image-20250426155405396](https://img.tynote.cn/img/typora/202504261554463.png#400h)

​	**使用微软Visual Studio集成开发环境编写的一段C语言源程序**

![image-20250426155735691](https://img.tynote.cn/img/typora/202504261557762.png)

​	**下面是对其编译、调试的情况**

![image-20250426155947402](https://img.tynote.cn/img/typora/202504261559586.png)

​	**需要说明的是，为了方便用户查看机器指令，开发环境默认使用十六进制的形式显示，而不是二进制形式**

![image-20250426155610643](https://img.tynote.cn/img/typora/202504261556858.png)

### **3️⃣程序设计语言和语言翻译程序的关系**

![image-20250426160202180](https://img.tynote.cn/img/typora/202504261602253.png#400h)

### **4️⃣使用GCC编译C语言源程序举例**

![image-20250426160314871](https://img.tynote.cn/img/typora/202504261603950.png#400h)

​	**除了常见的编译和汇编外，该实例还增加了预处理和多目标程序链接的过程**

### **5️⃣操作系统**

![image-20250426160442871](https://img.tynote.cn/img/typora/202504261604945.png#400h)

## 计算机系统的层次结构

### **1️⃣计算机系统的分层思想**

![image-20250426160633555](https://img.tynote.cn/img/typora/202504261606649.png#400h)

![image-20250426160829332](https://img.tynote.cn/img/typora/202504261608411.png#400h)

​	**在有微程序的系统中，CPU内部有一个控制存储器，用于存放各种机器指令对应的微程序，当CPU执行机器指令时，会在控制存储器里寻找与该机器指令对应的微程序，找到后，取出微程序中的微指令来控制执行各个微操作，从而完成机器指令的功能。**

![image-20250426161231169](https://img.tynote.cn/img/typora/202504261612246.png#400h)

### **2️⃣软件和硬件的逻辑功能等价性**

![image-20250426161255092](https://img.tynote.cn/img/typora/202504261612169.png#400h)

![image-20250426161400840](https://img.tynote.cn/img/typora/202504261614925.png#400h)

### **小结**

![image-20250426161901388](https://img.tynote.cn/img/typora/202504261619459.png#400h)

![image-20250426162025959](https://img.tynote.cn/img/typora/202504261620035.png#400h)

## 计算机的基本工作原理

### **1️⃣计算机硬件组成的细化**

![image-20250426162445342](https://img.tynote.cn/img/typora/202504261624423.png#400h)

![image-20250426163519216](https://img.tynote.cn/img/typora/202504261635290.png#400h)

- **加法：若要ALU做加法，首先需要将被加数送到累加器ACC中，而将加数送到操作数寄存器X中，ALU执行加法运算后，运算结果，即和，会保存在累加器ACC中。**
- **减法：若要ALU做减法，首先需要将被减数送到累加器ACC中，而将减数送到操作数寄存器X中，ALU执行减法运算后，运算结果，即差，会保存在累加器ACC中。**
- **乘法：若要ALU做乘法，首先需要将被乘数送到操作数寄存器X中，而将乘数送到乘商寄存器MQ中，ALU执行乘法运算后，运算结果，即乘积，其高位会保存在累加器ACC中，而低位会保存在乘商寄存器MQ中。**
- **除法：若要ALU做加法，首先需要将被除数送到累加器ACC中，而将除数送到操作数寄存器X中，ALU执行除法运算后，运算结果，即商和余数，其中，商会保存在乘商寄存器MQ中，余数会保存在累加器ACC中。**

### **2️⃣算术运算原理及过程**

**加法操作过程**

![image-20250426163603291](https://img.tynote.cn/img/typora/202504261636359.png#400h)

**减法操作过程**

![image-20250426163651085](https://img.tynote.cn/img/typora/202504261636171.png#400h)

**乘法操作过程**

![image-20250426163823943](https://img.tynote.cn/img/typora/202504261638023.png#400h)

**除法操作过程**

![image-20250426163903466](https://img.tynote.cn/img/typora/202504261639544.png#400h)

**算术运算过程相同点**

![image-20250426164133674](https://img.tynote.cn/img/typora/202504261641748.png#400h)

### **3️⃣主存储器**

![image-20250426164221018](https://img.tynote.cn/img/typora/202504261642096.png#400h)

![image-20250426164259076](https://img.tynote.cn/img/typora/202504261642164.png#400h)

![image-20250426164338885](https://img.tynote.cn/img/typora/202504261643970.png#400h)

![image-20250426164428748](https://img.tynote.cn/img/typora/202504261644829.png#400h)

​	**如果用二进制来编址，则需要16个二进制比特，最小地址为16个二进制比特0，最大地址为16个二进制比特1，如下图所示**

![image-20250426164608201](https://img.tynote.cn/img/typora/202504261646294.png#400h)

​	**如果用十六进制来编址，则需要4个十六进制位，最小地址为4个0，最大地址为4个F，如下图所示**

![image-20250426164723984](https://img.tynote.cn/img/typora/202504261647067.png#400h)

![image-20250426164912747](https://img.tynote.cn/img/typora/202504261649829.png#400h)

![image-20250426165009600](https://img.tynote.cn/img/typora/202504261650684.png#400h)

![image-20250426165122037](https://img.tynote.cn/img/typora/202504261651125.png#400h)

![image-20250426165206162](https://img.tynote.cn/img/typora/202504261652246.png#400h)

### **4️⃣控制器**

![image-20250426165252825](https://img.tynote.cn/img/typora/202504261652914.png#400h)

###  **5️⃣细化后的计算机硬件组成框图**

![image-20250426165409254](https://img.tynote.cn/img/typora/202504261654334.png#400h)

![image-20250426165432256](https://img.tynote.cn/img/typora/202504261654332.png#400h)

![image-20250426165522811](https://img.tynote.cn/img/typora/202504261655905.png#400h)

![image-20250426165616588](https://img.tynote.cn/img/typora/202504261656687.png#400h)

###  **6️⃣机器指令简介**

![image-20250426165725749](https://img.tynote.cn/img/typora/202504261657834.png#400h)

​	**编写计算a×b+c的机器指令程序**

![image-20250426174806571](https://img.tynote.cn/img/typora/202504261748653.png#400h)

![image-20250426175657175](https://img.tynote.cn/img/typora/20250426175657263.png#400h)

![image-20250426175743508](https://img.tynote.cn/img/typora/20250426175743592.png#400h)

![image-20250426175836321](https://img.tynote.cn/img/typora/20250426175836412.png#400h)

![image-20250426175933798](https://img.tynote.cn/img/typora/20250426175933885.png#400h)

### **7️⃣计算机的基本工作原理**

​	**以a×b+c该机器程序为例，结合之前得出的计算机硬件组成框图，学习计算机的基本工作原理。注意，为了简单起见，并未画出I/O设备，并且在接下来的叙述中，我们将主存储器简称为内存**

![image-20250426180427180](https://img.tynote.cn/img/typora/20250426180427282.png#400h)

​	**由[1.6-5中控制器](#5️⃣细化后的计算机硬件组成框图)章节我们已经知道，程序计数器PC用来<font color='blue'>存放当前欲执行的指令地址</font>，且<font color='blue'>PC自动形成下一条地址</font>,初始时，程序计数器PC的值为0，可以理解为指向内存中编号为0的存储单元 **

**第一条指令**

- **①对第一条指令进行<font color='blue'>取指</font>**

![image-20250426201554476](https://img.tynote.cn/img/typora/20250426201554476.png#400h)

<video src="https://img.tynote.cn/img/typora/20250428110659093.mp4" width="720" height="405" preload="none"  controls>            </video>


- **②对第一条指令进行<font color='blue'>分析</font>**

**第一条指令取指完成后，程序计数器PC会自动形成下一条指令的地址，也就是自动加1的功能，此时PC值从0变成了1，接着对第一条指令进行分析**

![image-20250426202358657](https://img.tynote.cn/img/typora/20250426202358657.png#400h)


<video src="https://img.tynote.cn/img/typora/20250426202615838.mp4" width="720" height="405" preload="none"  controls="controls">
</video>


- **③对第一条指令进行<font color='blue'>执行</font>**

**在完成第一条指令的分析后，控制器就知道了该指令所要执行的具体操作，于是就执行该指令**

![image-20250426203252371](https://img.tynote.cn/img/typora/20250426203252611.png#400h)

<video src="https://img.tynote.cn/img/typora/20250426203200021.mp4" width="720" height="405" preload="none"  controls="controls">
</video>

**第二条指令**

​	**在完成第一条指令的取值后，程序计数器(PC)=1，也就是指向内存中编号为1的存储单元，而该存储单元的内容，就是本程序的第二条机器指令**

<video src="https://img.tynote.cn/img/typora/20250426203709529.mp4" width="720" height="405" preload="none"  controls="controls">
</video>

- **①对第二条指令取指**

![image-20250426203929223](https://img.tynote.cn/img/typora/20250426203929537.png#400h)

<video src="https://img.tynote.cn/img/typora/20250426204112181.mp4" width="720" height="405" preload="none"  controls="controls">
</video>

- **②对第二条指令进行<font color='blue'>分析</font>**

**第二条指令取指完成后，程序计数器PC会自动形成下一条指令的地址，也就是自动加1的功能，此时PC值从1变成了2，也就是指向内存中编号为2的存储单元，而该存储单元的内容，就是本程序的第三条机器指令。接着对第二条指令进行分析**

![image-20250426204739042](https://img.tynote.cn/img/typora/20250426204739509.png#400h)

<video src="https://img.tynote.cn/img/typora/20250426204902517.mp4" width="720" height="405" preload="none"  controls="controls">
</video>

<video src="https://img.tynote.cn/img/typora/20250426205053757.mp4" width="720" height="405" preload="none"  controls="controls">
</video>

- **③对第二条指令进行<font color='blue'>执行</font>**

> **在完成第一条指令的分析后，控制器就知道了该指令所要执行的具体操作，于是就执行该指令**

![image-20250426205619951](https://img.tynote.cn/img/typora/20250426205620411.png#400h)

<video src="https://img.tynote.cn/img/typora/20250426205742285.mp4" width="720" height="405" preload="none"  controls="controls">
</video>
**后续过程请参照上述过程自行分析**

![image-20250505104553812](https://img.tynote.cn/img/typora/20250505104601183.png#400h)

![image-20250505104650430](https://img.tynote.cn/img/typora/20250505104650912.png#400h)

### 小结

![image-20250505104810339](https://img.tynote.cn/img/typora/20250505104810755.png#400h)

![image-20250505104838141](https://img.tynote.cn/img/typora/20250505104838581.png#400h)

![image-20250505104909382](https://img.tynote.cn/img/typora/20250505104909883.png#400h)

## 计算机系统的性能指标

### 1️⃣定义



![image-20250429104236446](https://img.tynote.cn/img/typora/20250429104236446.png#400h)

### 2️⃣软硬件与计算机系统性能的关系

![image-20250429104346983](https://img.tynote.cn/img/typora/20250429104346983.png#400h)

### 3️⃣计算机硬件的相关性能指标

![image-20250429105108665](https://img.tynote.cn/img/typora/20250429105108807.png#400h)

#### 基本性能指标



![image-20250429105207446](https://img.tynote.cn/img/typora/20250429105207621.png#400h)



![image-20250429170826683](https://img.tynote.cn/img/typora/20250429170826823.png#400h)

![image-20250429171511831](https://img.tynote.cn/img/typora/20250429171511966.png#400h)

![image-20250429175149991](https://img.tynote.cn/img/typora/20250429175150109.png#400h)

![image-20250429171543014](https://img.tynote.cn/img/typora/20250429171543134.png#400h)

![image-20250429172916073](https://img.tynote.cn/img/typora/20250429172916187.png#400h)

#### 与运算速度相关的性能指标

![image-20250429175644075](https://img.tynote.cn/img/typora/20250429175644201.png#400h)

![image-20250429191055023](https://img.tynote.cn/img/typora/20250429191055154.png#400h)

![image-20250429191246584](https://img.tynote.cn/img/typora/20250429191246673.png#400h)

![image-20250429191543727](https://img.tynote.cn/img/typora/20250429191543874.png#400h)

![image-20250429191716715](https://img.tynote.cn/img/typora/20250429191716834.png#400h)

![image-20250429191745710](https://img.tynote.cn/img/typora/20250429191745835.png#400h)

![image-20250429191858050](https://img.tynote.cn/img/typora/20250429191858171.png#400h)

![image-20250429191936733](https://img.tynote.cn/img/typora/20250429191936864.png#400h)

![image-20250429192009081](https://img.tynote.cn/img/typora/20250429192009211.png#400h)

![image-20250429192114112](https://img.tynote.cn/img/typora/20250429192114232.png#400h)

![image-20250429192602398](https://img.tynote.cn/img/typora/20250429192602523.png#400h)

![image-20250429192643571](https://img.tynote.cn/img/typora/20250429192643708.png#400h)

![image-20250507100600058](https://img.tynote.cn/img/typora/20250507100600346.png#400h)

![image-20250429192725312](https://img.tynote.cn/img/typora/20250429192725455.png#400h)

![image-20250429192843808](https://img.tynote.cn/img/typora/20250429192843953.png#400h)

![image-20250429192911062](https://img.tynote.cn/img/typora/20250429192911187.png#400h)

![image-20250429193316642](https://img.tynote.cn/img/typora/20250429193316771.png#400h)

![image-20250429193426825](https://img.tynote.cn/img/typora/20250429193426951.png#400h)

![image-20250429193532769](https://img.tynote.cn/img/typora/20250429193532903.png#400h)

![image-20250429193601329](https://img.tynote.cn/img/typora/20250429193601447.png#400h)

### 小结

![image-20250429193649981](https://img.tynote.cn/img/typora/20250429193650198.png#400h)

![image-20250429193722260](https://img.tynote.cn/img/typora/20250429193722395.png#400h)

![image-20250429193906115](https://img.tynote.cn/img/typora/20250429193906236.png#400h)

![image-20250429193939890](https://img.tynote.cn/img/typora/20250429193940022.png#400h)

![image-20250429194002138](https://img.tynote.cn/img/typora/20250429194002274.png#400h)

![image-20250429194027467](https://img.tynote.cn/img/typora/20250429194027614.png#400h)

![image-20250429194053058](https://img.tynote.cn/img/typora/20250429194053187.png#400h)

![image-20250507100800665](https://img.tynote.cn/img/typora/20250507100800854.png#400h)



![image-20250429194404927](https://img.tynote.cn/img/typora/20250429194405060.png#400h)

# 计算机内部的数据表示

## 数据表示的相关概念

![image-20250429194707277](https://img.tynote.cn/img/typora/20250429194707401.png#400h)

![image-20250429194736032](https://img.tynote.cn/img/typora/20250429194736165.png#400h)

​	**由于本章的内容主要是数值数据在计算机内部的表示，因此，我们假设在寄存器中存储的是某个数值数据的二进制编码，该二进制编码可能表示的数值数据有以下几种：**

![image-20250429195357791](https://img.tynote.cn/img/typora/20250429195357927.png#400h)

![image-20250429195502970](https://img.tynote.cn/img/typora/20250429195503118.png#400h)

![image-20250429195652475](https://img.tynote.cn/img/typora/20250429195652613.png#400h)

## 进位计数制及其数据之间的相互转换

### 1️⃣进位计数制

![image-20250429195819624](https://img.tynote.cn/img/typora/20250507100443201.png#400h)

![image-20250429195908528](https://img.tynote.cn/img/typora/20250509115417263.png#400h)

![image-20250429195957521](https://img.tynote.cn/img/typora/20250429195957644.png#400h)

![image-20250429200027836](https://img.tynote.cn/img/typora/20250429200027972.png#400h)

![image-20250429200055066](https://img.tynote.cn/img/typora/20250429200055202.png#400h)

![image-20250429200200104](https://img.tynote.cn/img/typora/20250429200200232.png#400h)

### 2️⃣任意进制转十进制

![image-20250429200239611](https://img.tynote.cn/img/typora/20250429200239740.png#400h)

![image-20250429200308939](https://img.tynote.cn/img/typora/20250429200309105.png#400h)

![image-20250429200327091](https://img.tynote.cn/img/typora/20250429200327225.png#400h)

![image-20250429200346289](https://img.tynote.cn/img/typora/20250429200346414.png#400h)

### 3️⃣二进制转八进制、十六进制

![image-20250429200435145](https://img.tynote.cn/img/typora/20250429200435282.png#400h)

![image-20250429200521414](https://img.tynote.cn/img/typora/20250429200521541.png#400h)

![image-20250429200546381](https://img.tynote.cn/img/typora/20250429200546509.png#400h)

![image-20250429201108114](https://img.tynote.cn/img/typora/20250429201108260.png#400h)

![image-20250429201156540](https://img.tynote.cn/img/typora/20250429201156679.png#400h)

![image-20250429201228734](https://img.tynote.cn/img/typora/20250429201228859.png#400h)

![image-20250429201319737](https://img.tynote.cn/img/typora/20250429201319863.png#400h)

### 4️⃣十进制转任意进制

![image-20250429202738436](https://img.tynote.cn/img/typora/20250429202738573.png#400h)

![image-20250429203257432](https://img.tynote.cn/img/typora/20250429203257581.png#400h)

![image-20250429203421622](https://img.tynote.cn/img/typora/20250429203421747.png#400h)

![image-20250429203446997](https://img.tynote.cn/img/typora/20250429203447130.png#400h)

![image-20250429203512715](https://img.tynote.cn/img/typora/20250429203512852.png#400h)

![image-20250429203635774](https://img.tynote.cn/img/typora/20250429203635903.png#400h)

![image-20250429203707307](https://img.tynote.cn/img/typora/20250429203707457.png#400h)

![image-20250429203756779](https://img.tynote.cn/img/typora/20250429203756924.png#400h)

![image-20250429203824431](https://img.tynote.cn/img/typora/20250429203824564.png#400h)

![image-20250429203906428](https://img.tynote.cn/img/typora/20250429203906566.png#400h)

![image-20250429203929271](https://img.tynote.cn/img/typora/20250429203929418.png#400h)

![image-20250429204002217](https://img.tynote.cn/img/typora/20250429204002360.png#400h)

### 小结

![image-20250429204136183](https://img.tynote.cn/img/typora/20250429204136339.png#400h)

## 定点数的编码

### 原码

#### 1️⃣定点整数和定点小数的原码表示方法

![image-20250429204342409](https://img.tynote.cn/img/typora/20250429204342541.png#400h)

![image-20250429204405910](https://img.tynote.cn/img/typora/20250429204406058.png#400h)

![image-20250429204947801](https://img.tynote.cn/img/typora/20250429204947941.png#400h)

#### 2️⃣定点整数的原码定义

![image-20250429205033054](https://img.tynote.cn/img/typora/20250429205033187.png#400h)

#### 3️⃣定点小数的原码定义

![image-20250429210830915](https://img.tynote.cn/img/typora/20250429210831048.png#400h)

![image-20250429211352315](https://img.tynote.cn/img/typora/20250429211352448.png#400h)

#### 4️⃣原码的优缺点

![image-20250429211449888](https://img.tynote.cn/img/typora/20250429211450021.png#400h)

![image-20250429211544565](https://img.tynote.cn/img/typora/20250429211544715.png#400h)

### 补码

#### 1️⃣补数的概念

![image-20250429211823757](https://img.tynote.cn/img/typora/20250429211824024.png#400h)

![image-20250429211858415](https://img.tynote.cn/img/typora/20250429211858565.png#400h)

![image-20250429212229341](https://img.tynote.cn/img/typora/20250429212229477.png#400h)

![image-20250429212315453](https://img.tynote.cn/img/typora/20250429212315601.png#400h)

![image-20250429212408474](https://img.tynote.cn/img/typora/20250429212408617.png#400h)

![image-20250429212550706](https://img.tynote.cn/img/typora/20250429212550856.png#400h)

#### 2️⃣定点整数的补码定义

![image-20250429213017151](https://img.tynote.cn/img/typora/20250429213017289.png#400h)

​	**二进制减法手算法**

<video src="https://img.tynote.cn/img/typora/20250429213921274.mp4" width="720" height="405" preload="none"  controls>            </video>

​	**二进制减法凑值法**

<video src="https://img.tynote.cn/img/typora/20250429214326722.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250429214417972](https://img.tynote.cn/img/typora/20250429214418133.png#400h)

![image-20250429214532293](https://img.tynote.cn/img/typora/20250429214532450.png#400h)

![image-20250429214607904](https://img.tynote.cn/img/typora/20250429214608085.png#400h)

![image-20250429214758243](https://img.tynote.cn/img/typora/20250429214758392.png#400h)

![image-20250429215308939](https://img.tynote.cn/img/typora/20250429215309095.png#400h)

#### 3️⃣定点小数的补码定义



![image-20250430152358999](https://img.tynote.cn/img/typora/20250430152359167.png#400h)

![image-20250430152416185](https://img.tynote.cn/img/typora/20250430152416366.png#400h)

![image-20250430152744214](https://img.tynote.cn/img/typora/20250430152744358.png#400h)

![image-20250430155307864](https://img.tynote.cn/img/typora/20250430155308028.png#400h)

![image-20250430155411295](https://img.tynote.cn/img/typora/20250430155411450.png#400h)

#### 4️⃣补码的优缺点

![image-20250430155712266](https://img.tynote.cn/img/typora/20250430155712430.png#400h)

![image-20250430163517882](https://img.tynote.cn/img/typora/20250430163518098.png#400h)

<font color='red'><注></font>：实际上，<font color='blue'>补码都是正数，补码根本没有符号位，全是数值位</font>。减法运算通过换成补码后，减数变成了正数，于是就可以进行加法运算，补码的意义就是使减数变成它对应的正数。那为何补码的最高位通常被称作符号位呢？我们知道，正数的补码是其本身，所以其补码最高位自然就是0，而计算负数的补码时，使用公式$[2^{n+1}+x]\ mod \ 2^{n+1}，(-2^n≤x<0)$时，计算得到的补码的最高位刚好为1，所以我们知道了，补码的最高位和原码的最高位（符号位）都是1，所以可以通过补码的最高位来判断原码的符号正负（即原来真值的正负情况），而补码全是正数，所以不能看到补码最高位是1就说该补码为负数，而应该说该补码对应的原码（或真值）为负数。

![image-20250430165410238](https://img.tynote.cn/img/typora/20250430165410443.png#400h)

![image-20250430170044010](https://img.tynote.cn/img/typora/20250430170044181.png#400h)

### 反码

#### 1️⃣原码按位操作变补码

​	**原码符号位不变，数值位按位取反，末位加1，得到的编码就是补码**

![image-20250430172821446](https://img.tynote.cn/img/typora/20250430172821593.png#400h)

​	**而原码和补码中间的这一串编码即为反码,正数的反码是其原码，所以我们下面只讨论求负数的反码**

![image-20250430172929255](https://img.tynote.cn/img/typora/20250430172929423.png#400h)

#### 2️⃣定点整数的反码定义

![image-20250430173227196](https://img.tynote.cn/img/typora/20250430173227355.png#400h)

![image-20250430173316489](https://img.tynote.cn/img/typora/20250430173316642.png#400h)

![image-20250430173428549](https://img.tynote.cn/img/typora/20250430173428700.png#400h)

![image-20250430173449720](https://img.tynote.cn/img/typora/20250430173449879.png#400h)

![image-20250430173957926](https://img.tynote.cn/img/typora/20250430173958089.png#400h)

#### 3️⃣定点小数的反码定义

![image-20250430181052448](https://img.tynote.cn/img/typora/20250430181052602.png#400h)

![image-20250430181510912](https://img.tynote.cn/img/typora/20250430181511069.png#400h)

![image-20250430181553259](https://img.tynote.cn/img/typora/20250430181553406.png#400h)

![image-20250430181616429](https://img.tynote.cn/img/typora/20250430181616581.png#400h)

![image-20250430210253339](https://img.tynote.cn/img/typora/20250430210253718.png#400h)

![image-20250430211019718](https://img.tynote.cn/img/typora/20250430211019887.png#400h)

![image-20250430212723555](https://img.tynote.cn/img/typora/20250430212723738.png#400h)

![image-20250430213419515](https://img.tynote.cn/img/typora/20250430213419666.png#400h)

#### 4️⃣反码的优缺点

![image-20250430213602517](https://img.tynote.cn/img/typora/20250430213602671.png#400h)

![image-20250430213628597](https://img.tynote.cn/img/typora/20250430213628815.png#400h)

### 移码

![image-20250430214806002](https://img.tynote.cn/img/typora/20250430214806227.png#400h)

![image-20250430214857159](https://img.tynote.cn/img/typora/20250430214857430.png#400h)

**由上图可知，真值x变成移码后，最小值为0**

#### 1️⃣ 移码的定义式

![image-20250430215622957](https://img.tynote.cn/img/typora/20250430215623162.png#400h)

![image-20250430215700354](https://img.tynote.cn/img/typora/20250430215700568.png#400h)

![image-20250430215727734](https://img.tynote.cn/img/typora/20250430215727941.png#400h)

![image-20250430215759068](https://img.tynote.cn/img/typora/20250430215759269.png#400h)

![image-20250430215855764](https://img.tynote.cn/img/typora/20250430215856012.png#400h)

#### 2️⃣ 移码的优点

![image-20250430220054022](https://img.tynote.cn/img/typora/20250430220054226.png#400h)

### 原码、反码、补码、移码之间的转换

![image-20250501210315933](https://img.tynote.cn/img/typora/20250501210323128.png#400h)

​	**真值为负数时，原码、反码、补码、移码转换要比正数时的转换关系更复杂，所以我们下面具体讨论真值为负数时的转换情况**

#### 1️⃣反码法(适合硬件)

![image-20250501210642371](https://img.tynote.cn/img/typora/20250501210642535.png#400h)

#### 2️⃣扫描法(手工求)

![image-20250501211249070](https://img.tynote.cn/img/typora/20250501211249226.png#400h)

​	**扫描法箭头是双向的，即可用扫描法负数原码求补码，也可其补码求原码。所以$原码\xrightarrow{求补}补码\xrightarrow{求补}原码$，因此我们可以得到这样一个结论，那就是求补码的补码就可以得到原码。简单来说，就是补码的补码是原码，又或者说，原码与补码互为补码。**

​	<font color='red'><注></font>：扫描法中的`从右到左，右起第一个1及其右边的0保持不变`中的`右边的0`指的是1右边的<font color='blue'>所有0</font>。

![image-20250501214012087](https://img.tynote.cn/img/typora/20250501214012281.png#400h)

​	**已知真值x的补码，求其相反数-x的补码的方法**

![image-20250501214319206](https://img.tynote.cn/img/typora/20250501214319384.png#400h)

![image-20250501214835529](https://img.tynote.cn/img/typora/20250501214835728.png#400h)

![image-20250501214852391](https://img.tynote.cn/img/typora/20250501214852579.png#400h)

![image-20250501214927292](https://img.tynote.cn/img/typora/20250501214927478.png#400h)

### 定点数的编码习题课

![image-20250502180510420](https://img.tynote.cn/img/typora/20250502180517635.png#400h)

![image-20250502180654815](https://img.tynote.cn/img/typora/20250502180654993.png#400h)

![image-20250502180840959](https://img.tynote.cn/img/typora/20250502180841153.png#400h)

![image-20250502181530014](https://img.tynote.cn/img/typora/20250502181530270.png#400h)

![image-20250502182001866](https://img.tynote.cn/img/typora/20250502182002130.png#400h)

![image-20250502182102486](https://img.tynote.cn/img/typora/20250502182102719.png#400h)

![image-20250502182549896](https://img.tynote.cn/img/typora/20250502182550120.png#400h)

![image-20250502182612975](https://img.tynote.cn/img/typora/20250502182613186.png#400h)

![image-20250502183117386](https://img.tynote.cn/img/typora/20250502183117622.png#400h)

![image-20250502192247819](https://img.tynote.cn/img/typora/20250502192248030.png#400h)

![image-20250502192349145](https://img.tynote.cn/img/typora/20250502192349372.png#400h)

![image-20250502192449759](https://img.tynote.cn/img/typora/20250502192449991.png#400h)

![image-20250502192708104](https://img.tynote.cn/img/typora/20250502192708321.png#400h)

![image-20250502193138596](https://img.tynote.cn/img/typora/20250502193138837.png#400h)

![image-20250502194325304](https://img.tynote.cn/img/typora/20250502194325533.png#400h)

​	**法二：也可以根据补码和移码的关系：仅符号位相反，且移码保留了原有真值的大小关系，可以直接比较。移码整个数轴从小到大从左到右是全0~全1，要想表示的数越小，就应该把1往低位放，所以除去符号位，移码为负，数值位2个1，5个0所能表示的最小数为00000011，对应的补码为10000011。**

![image-20250502195622495](https://img.tynote.cn/img/typora/20250502195622705.png#400h)

![image-20250502200907310](https://img.tynote.cn/img/typora/20250507100844719.png#400h)

![image-20250502200936793](https://img.tynote.cn/img/typora/20250502200937016.png#400h)





## 浮点数的表示

### 浮点数的表示形式和表示范围

#### 1️⃣定点小数在计算机中的表示形式

![image-20250509154433686](https://img.tynote.cn/img/typora/20250509154440944.png#400h)

![image-20250509162816247](https://img.tynote.cn/img/typora/20250509162816428.png#400h)

**原码的0有两种表示，然后最大正数和最小负数、最小正数和最大负数的符号位相反，数值位相同，再根据反码和原码的转换关系可以知道，原码的数值位取反即可得到对应的反码，除最小负数外，其他在反码的基础上加1即可得到对应补码，由于补码能多表示一个最小负数，所以其最小负数为`-1`，对应的补码为1.000···00**

**原码中最大正数为0.111···11，其对应的十进制为$2^{-1}+2^{-2}···+2^{-n}= \frac{2^{-1}(1-2^{-n})}{ 1-2^{-1}}=1-2^{-n}$，是首项为$2^{-1}$，公比为$2^{-1}$的等比数列的前n项和**

#### 2️⃣定点整数在计算机中的表示形式

![image-20250509164040923](https://img.tynote.cn/img/typora/20250509164041192.png#400h)

![image-20250509164611585](https://img.tynote.cn/img/typora/20250509164611853.png#400h)

![image-20250509164633474](https://img.tynote.cn/img/typora/20250509164633738.png#400h)

![image-20250509164750540](https://img.tynote.cn/img/typora/20250509164750850.png#400h)

**由于计算机能处理的数为纯小数或者纯整数，所以在面对3.1415926这样的带小数时，有的同学会想到将其转化为一个`定点数×比例因子`的形式来间接表示带小数，但是由于面对不同带小数，比例因子没有办法统一，因而这种方法不适用，我们希望将浮点数直接表示在寄存器中，于是就引出了浮点数的表示问题**

#### 3️⃣浮点数的表示

![image-20250509165336333](https://img.tynote.cn/img/typora/20250509165336620.png#400h)

![image-20250509165615652](https://img.tynote.cn/img/typora/20250509165615955.png#400h)

**<font color='red'><注>：</font>$2^{10}$表示小数点向右移动2位，原因是因为指数部分也是用二进制表示的，即二进制指数10对应的是十进制数为2，$[10]_2=[2]_{10}$**

![image-20250509174107423](https://img.tynote.cn/img/typora/20250509174107714.png#400h)

**基数r是隐含约定的，一旦约定，就不再变化，换句话说 ，不需要专门表示和存储基数r，基数r的取值可以是2、4、8、16等**

#### 4️⃣浮点数的表示范围

![image-20250509221249774](https://img.tynote.cn/img/typora/20250509221250120.png#400h)

**由于尾数M的数符决定了整个浮点数的正负，所以当整个浮点数为负，且浮点数绝对值最大时，得到的即为负数N最小值，绝对值越大，负数越小，绝对值越小，负数越大，要注意绝对值由$r^E×尾数M的数值位$构成**
$$
\begin{cases}
		负数N最小值：r^{阶码E最大值}×尾数负数最小值=-(r^{阶码E最大值}×尾数数值位)=-(浮点数最大绝对值)\\
		负数N最大值：r^{阶码E最小值}×尾数负数最大值=-(r^{阶码E最小值}×尾数数值位)=-(浮点数最小绝对值)\\
	\end{cases}
$$
**整数N最大值=+6计算过程举例：基数r=2，阶码最大值011，即+3，尾数最大值0.11，即$1×2^{-1}+1×2^{-2}=+0.75$，**
**所以$正数N_{max}=2^{011}×[0.11]_{2}=2^{+3}×[0.11]_{2}=[+011]_{2}=[+6]_{10}$，计算过程中只需将阶码也就是指数转化为十进制，尾数转化为基数r进制即可，便于我们知道对应的r进制数小数点移动了几位，即本例最后是二进制数0.11小数点向右移动3位变成011，然后再将二进制数011转化为十进制数+6即可。**



![image-20250509221549354](https://img.tynote.cn/img/typora/20250509221549666.png#400h)



**解析：浮点数N要取到最大值时，阶码取最大值011，即+3，尾数取最大值0.1111，即**
**$[0.1111]_2=1×2^{-1}+1×2^{-2}+1×2^{-3}+1×2^{-4}=[+0.9375]_{10}$，但是此处无需转化为十进制数，为方便计算我们应将其转化为对应的r=8进制数，**
**即$[0.11111]_2=[+0.74]_8$，所以$N_{max}=8^{011}×[0.1111]_2=8^{+3}×[+0.74]_8=[+740]_8=0×8^0+4×8^1+7×8^2=[+480]_{10}$**

![image-20250512154739739](https://img.tynote.cn/img/typora/20250512154747061.png#400h)

![image-20250512154843566](https://img.tynote.cn/img/typora/20250512154844087.png#400h)

**阶码最大值为$[2^k-1]_{10}$，最小值为$[-(2^k-1)]_{10}$，尾数最大值为$[1-2^{-n}]_{10}$，最小值为$[2^{-n}]_{10}$，浮点数的最大正数，最小正数，最大负数，最小负数按照规律将阶码和尾数组合即可**

#### 5️⃣习题

![image-20250512154954985](https://img.tynote.cn/img/typora/20250512154955359.png#400h)

![image-20250512155154280](https://img.tynote.cn/img/typora/20250512155154648.png#400h)

![image-20250512155955688](https://img.tynote.cn/img/typora/20250512155956101.png#400h)

### 浮点数的规格化

#### 1️⃣浮点数的规格化

![image-20250512160942333](https://img.tynote.cn/img/typora/20250512160942751.png#400h)

![image-20250512161058704](https://img.tynote.cn/img/typora/20250512161059113.png#400h)

**使浮点数的表示精度最高：试想一下，如果尾数的数值部分的最高位为0，则实际上该位对数值的表达是没有作用的，因为在构成数值时，该位的位权是没有作用的，而规格化，就是要移除数值部分最高位的0，这相当于数值部分能够补充相应数量的低位，这样就提高了表示精度。**

![image-20250512161537790](https://img.tynote.cn/img/typora/20250512161538215.png#400h)

![image-20250512161838027](https://img.tynote.cn/img/typora/20250512161838434.png#400h)

![image-20250512161917709](https://img.tynote.cn/img/typora/20250512161918121.png#400h)

![image-20250512162058186](https://img.tynote.cn/img/typora/20250512162058595.png#400h)

![image-20250512162241785](https://img.tynote.cn/img/typora/20250512162242194.png#400h)

![image-20250512162936672](https://img.tynote.cn/img/typora/20250512162937072.png#400h)

![image-20250512163127939](https://img.tynote.cn/img/typora/20250512163128341.png#400h)

**$+\frac{13}{128}=+13×2^{-7}=[+1101]_2×2^{-7}=[+0.00011101]_2$，即二进制数1101小数点向左移动7位**

![image-20250512164249698](https://img.tynote.cn/img/typora/20250512164250115.png#400h)

#### 2️⃣习题

![image-20250512164330763](https://img.tynote.cn/img/typora/20250512164331150.png#400h)

![image-20250512164525833](https://img.tynote.cn/img/typora/20250512164526250.png#400h)

![image-20250512164721064](https://img.tynote.cn/img/typora/20250512164721506.png#400h)

![image-20250512164829832](https://img.tynote.cn/img/typora/20250512164830290.png#400h)

### IEEE 754标准

#### 1️⃣IEEE 754标准概述

![image-20250512165037639](https://img.tynote.cn/img/typora/20250512165038081.png#400h)

![image-20250512165158181](https://img.tynote.cn/img/typora/20250512165158580.png#400h)

#### 2️⃣IEEE 754标准下32位单精度浮点数的阶码相关内容

![image-20250512165514356](https://img.tynote.cn/img/typora/20250512165514786.png#400h)

![image-20250512170014873](https://img.tynote.cn/img/typora/20250512170015292.png#400h)

![image-20250512170253717](https://img.tynote.cn/img/typora/20250512170254168.png#400h)

**我们将最小的两个数真值为-128和-127用作特殊用途，用来表示特殊数和非规格化数，而其他数即-126~+127用于IEEE 754单精度浮点数的规格化数的表示**

![image-20250512170844884](https://img.tynote.cn/img/typora/20250512170845292.png#400h)

![image-20250512170956702](https://img.tynote.cn/img/typora/20250512170957138.png#400h)

#### 3️⃣IEEE 754标准下32位单精度浮点数的尾数相关内容

![image-20250512180749362](https://img.tynote.cn/img/typora/20250512180749701.png#400h)

**然而，IEEE 754单精度浮点数格式中的尾数虽然为定点小数，但其格式与我们之前复习的定点小数格式稍有不同，小数点隐含固定在尾数前面，而将原本小数点相邻左侧的符号位前移到最左侧，也就是IEEE 754单精度浮点数格式中的最高位作为符号位，如上图所示，而在小数点的相邻左侧隐藏一个1，但用来表示数值而不表示符号。为方便后续描述，我们用大写字母S表示符号位，大写字母E表示阶码，大写字母M表示尾数，这样，完整的尾数形式应该表示为`1.M`**

![image-20250512180854320](https://img.tynote.cn/img/typora/20250512180854755.png#400h)

![image-20250512182159696](https://img.tynote.cn/img/typora/20250512182200218.png#400h)

![image-20250512182332181](https://img.tynote.cn/img/typora/20250512182332642.png#400h)

![image-20250512182737286](https://img.tynote.cn/img/typora/20250512182737741.png#400h)

![image-20250512183407064](https://img.tynote.cn/img/typora/20250512183407504.png#400h)

![image-20250512183839095](https://img.tynote.cn/img/typora/20250512183839554.png#400h)

**非规格化数是用于表示很小的数，本来是指数是127，尾数由`1.M`变为`0.M`后，发生了右规，隐藏位的1右规以后，阶码加1，就变成了-126.同时也是为了让非规格化单精度浮点数能够平缓过渡到规格化单精度浮点数，即让这两大类单精度浮点数的衔接不至于突兀。指数部分统一调整至-126，以便能够连续地逼近并达到真正意义上的零值附近的数据点。简言之，设置非规格化数的指数为-126是为了确保整个数值范围内没有任何空白区段，并且能够在计算机内部高效、紧凑地存储尽可能多的不同大小的数值信息。**

​	**上述IEEE 754单精度浮点数的分类重新整理如下：**

![image-20250512184445549](https://img.tynote.cn/img/typora/20250512184446060.png#400h)

​	**下面是IEEE 754浮点数标准中32位单精度浮点数与64位双精度浮点数各自可表示的各类数，64位双精度浮点数可表示的各类数可参照32位单精度浮点数进行推导，相比于32位单精度浮点数，64位双精度浮点数仅将阶码和尾数位数扩展，而其他规则不变。**

![image-20250512203537019](https://img.tynote.cn/img/typora/20250512203537519.png#400h)

#### 4️⃣IEEE 754单精度(32位)浮点数与对应真值之间的转换

![image-20250512190341819](https://img.tynote.cn/img/typora/20250512190342259.png#400h)

![image-20250512192359719](https://img.tynote.cn/img/typora/20250512192400187.png#400h)

![image-20250512192501592](https://img.tynote.cn/img/typora/20250512192502071.png#400h)

![image-20250512192558721](https://img.tynote.cn/img/typora/20250512192559177.png#400h)

![image-20250512200948448](https://img.tynote.cn/img/typora/20250512200948933.png#400h)

![image-20250512202037638](https://img.tynote.cn/img/typora/20250512202038093.png#400h)

![image-20250512202119558](https://img.tynote.cn/img/typora/20250512202119997.png#400h)

![image-20250512202146638](https://img.tynote.cn/img/typora/20250512202147089.png#400h)

**遇到此类题可先判断符号和阶码，若符号相同，且阶码差距大，则可直接比较出结果**

![image-20250512203232093](https://img.tynote.cn/img/typora/20250512203232516.png#400h)

#### 5️⃣IEEE 754单精度(32位)浮点数表示范围

![image-20250512204236275](https://img.tynote.cn/img/typora/20250512204236726.png#400h)

- 规格化数范围

![image-20250512204645230](https://img.tynote.cn/img/typora/20250512204645705.png#400h)

- 非规格化数范围

![image-20250512204843528](https://img.tynote.cn/img/typora/20250512204843963.png#400h)

- IEEE 754双精度浮点数表示范围

![image-20250512204945537](https://img.tynote.cn/img/typora/20250512204945953.png#400h)

- 习题

![image-20250512205459922](https://img.tynote.cn/img/typora/20250512205500387.png#400h)

**因为非规格化数的阶码真值为-126，很小，所以最大正整数一定是规格化正数**

![image-20250512205909670](https://img.tynote.cn/img/typora/20250520160538280.png#400h)



![image-20250512210216067](https://img.tynote.cn/img/typora/20250512210216499.png#400h)

#### 6️⃣精度缺失与IEEE 754数据格式规范

![image-20250512210327973](https://img.tynote.cn/img/typora/20250512210328437.png#400h)

![image-20250512210409177](https://img.tynote.cn/img/typora/20250512210409623.png#400h)

## C语言中的数据类型及转换

### 数据类型

![image-20250512214900249](https://img.tynote.cn/img/typora/20250512214900568.png#400h)

​	

![image-20250512215053917](https://img.tynote.cn/img/typora/20250512215054235.png#400h)

![image-20250512215529765](https://img.tynote.cn/img/typora/20250512215530110.png#400h)

![image-20250512215602295](https://img.tynote.cn/img/typora/20250512215602629.png#400h)

### 整型数据之间的类型转换

![image-20250514163725404](https://img.tynote.cn/img/typora/20250514163732927.png#400h)

#### 1️⃣相同字长之间的转换

![image-20250514164301974](https://img.tynote.cn/img/typora/20250514164302325.png#400h)

- 相同字长之间的转换——交集``0~127`之间的类型转换

**`char`转换为`unsigned`型**

![image-20250514164712046](https://img.tynote.cn/img/typora/20250514164712443.png#400h)

![image-20250514165001835](https://img.tynote.cn/img/typora/20250514165002216.png#400h)

![image-20250514165332876](https://img.tynote.cn/img/typora/20250514165333255.png#400h)

- 相同字长之间的转换——`-128~1`之间的类型转换

**`char`转换为`unsigned`型**

![image-20250514165846412](https://img.tynote.cn/img/typora/20250514165846893.png#400h)

**选用补码的原因是，补码既可表示负数，也可表示与其相对应的正数，这在了解补数的过程中我们已经知道。本例中-127转换为无符号数，相当于是在求与其相对应的正数，因为char型数值位共7位，符号位1位，所以最高位为符号位，最高位进位的权值为$2^8=256$，所以这个模就是256，根据补码整数的定义可得-127对应的正数为$-127+256=129$**。

**<font color='blue'>负数对应的正数=负数+模</font>**

- 相同字长之间的转换——`0~256`之间的数据转换

**`unsigned char`转换为`char`型**

![image-20250514174245193](https://img.tynote.cn/img/typora/20250514174245658.png#400h)

**转换后的数据=原值-256**

**<font color='blue'>正数对应的负数=正数-模</font>**

- 例题

![image-20250514172625455](https://img.tynote.cn/img/typora/20250514172625892.png#400h)

**short型数据共有16位，包含1个符号位，15个数值位，最高位进位的权值为$2^16=65536$，根据补码整数的定义可得-32767对应的正数为$-32767+65536=32769$**

![image-20250514174701907](https://img.tynote.cn/img/typora/20250514174702402.png#400h)

#### 2️⃣小字长转大字长

![image-20250514175143139](https://img.tynote.cn/img/typora/20250514175143631.png#400h)

![image-20250514180218547](https://img.tynote.cn/img/typora/20250514180219087.png#400h)

![image-20250514180315218](https://img.tynote.cn/img/typora/20250514180315851.png#400h)

- 例题

![image-20250514180516518](https://img.tynote.cn/img/typora/20250514180517038.png#400h)

#### 3️⃣大字长转小字长

![image-20250514180710953](https://img.tynote.cn/img/typora/20250514180711444.png#400h)

![image-20250514180803268](https://img.tynote.cn/img/typora/20250514180803781.png#400h)

### int,float,double之间的转换

![image-20250514180935578](https://img.tynote.cn/img/typora/20250514180936042.png#400h)

#### 1️⃣float转double

![image-20250514181122690](https://img.tynote.cn/img/typora/20250514181123289.png#400h)

![image-20250514181212860](https://img.tynote.cn/img/typora/20250514181213449.png#400h)

![image-20250514181333692](https://img.tynote.cn/img/typora/20250514181334331.png#400h)

#### 2️⃣double转float

![image-20250514181500543](https://img.tynote.cn/img/typora/20250514181501141.png#400h)

#### 3️⃣float/double转int

![image-20250514181551136](https://img.tynote.cn/img/typora/20250514181551713.png#400h)

#### 4️⃣int转float

![image-20250514181715477](https://img.tynote.cn/img/typora/20250514181716098.png#400h)

#### 5️⃣int转double

![image-20250514181910650](https://img.tynote.cn/img/typora/20250514181911239.png#400h)

#### 6️⃣总结

![image-20250514182254880](https://img.tynote.cn/img/typora/20250514182255478.png#400h)

# 运算方法和运算器

## 移位运算

### 逻辑移位

#### 1️⃣逻辑左移和逻辑右移



![image-20250514201650917](https://img.tynote.cn/img/typora/20250514201651479.png#400h)

![image-20250514201849267](https://img.tynote.cn/img/typora/20250520160538281.png#400h)

#### 2️⃣逻辑移位的应用举例

- 将$b_6$的内容清0而不影响其他各位，使用C语言实现

![image-20250514203245115](https://img.tynote.cn/img/typora/20250514203245679.png#400h)

**首先定义一个名为`b6_mask`的宏，意思为b6位的掩码，其内容为`1<<6`，即1左移6位，在本例中，该宏的作用相当于创建了另一个8位无符号变量，其最低为b0的初始值为1，其他位的初始值为0，然后将该变量的内容逻辑左移6位，高位移除，低位补0，这样就得到了b6位的掩码，如下图所示**

![image-20250514203903168](https://img.tynote.cn/img/typora/20250514203903759.png#400h)

**接下来，使用之前定义的宏编写了这条语句，该语句的作用是，首先将b6位的掩码按位取反，如下图所示**

![image-20250514204244368](https://img.tynote.cn/img/typora/20250514204244986.png#400h)

**然后将b6位的掩码按位取反的结果与变量regDate中的内容进行与运算，与1相与的那些位保持不变，而与0相与的那些位会被清0，如下图所示**

![image-20250514204519899](https://img.tynote.cn/img/typora/20250514204520502.png#400h)

**最后，与运算得到的结果会被写回到变量regDate中，如下图所示，这样，我们就通过逻辑移位运算、取反运算、与运算，实现了将寄存器的某个位清0，而不影响寄存器的其他各位**

![image-20250514204745752](https://img.tynote.cn/img/typora/20250514204746316.png#400h)

​	**完整实现过程**



<video src="https://img.tynote.cn/img/typora/20250514202821566.mp4" width="720" height="405" preload="none"  controls>            </video>

- 将$b_6$的内容置1而不影响其他各位，使用C语言实现

**只需要将上一例中的取反运算符去掉，把与运算符改为或运算符即可，这相当于把变量regDate中的内容与b6位的掩码进行或运算，与0相或的那些位会保持不变，与1相或的那些位会被置1，如下图所示**



![image-20250514205733096](https://img.tynote.cn/img/typora/20250514205733775.png#400h)

**最后，或运算得到的结果会被重新写回变量regDate中，如下图所示。这样，我们就通过逻辑移位运算和或运算实现了将寄存器的某个位置1，而不影响寄存器的其他各位**

![image-20250514205844471](https://img.tynote.cn/img/typora/20250514205845106.png#400h)

**需要说明的是，在上述例子中，我们只利用了一个位的掩码对该位进行清0或置1的操作，实际上，可以利用每个位各自的位掩码，对每个位同时进行清0或置1的操作，例如下面的练习**

![image-20250514210842930](https://img.tynote.cn/img/typora/20250514210843622.png#400h)

**其中，`b0_mask|b5_mask`是将b0和b5的掩码先合并，然后再进行与运算，实现将b0和b5同时清0，下一句中`b2_mask|b3_mask`也是先将b2和b3的掩码先合并，然后再一起置1**

### 算术移位

![image-20250514215835627](https://img.tynote.cn/img/typora/20250514215836228.png#400h)

#### 1️⃣对正数进行算术移位

![image-20250515101812028](https://img.tynote.cn/img/typora/20250515101812676.png#400h)

![image-20250515103735247](https://img.tynote.cn/img/typora/20250515103735684.png#400h)

![image-20250515103925218](https://img.tynote.cn/img/typora/20250515103925775.png#400h)

![image-20250515103959928](https://img.tynote.cn/img/typora/20250515104000510.png#400h)

![image-20250515105814156](https://img.tynote.cn/img/typora/20250515105814753.png#400h)

![image-20250515105849424](https://img.tynote.cn/img/typora/20250515105850023.png#400h)

#### 2️⃣对负数进行算术移位

![image-20250515110809506](https://img.tynote.cn/img/typora/20250515110810157.png#400h)

![image-20250515110941333](https://img.tynote.cn/img/typora/20250515110942019.png#400h)

3️⃣总结

![image-20250515111010981](https://img.tynote.cn/img/typora/20250515111011628.png#400h)

![image-20250515150532343](https://img.tynote.cn/img/typora/20250515150533023.png#400h)



![image-20250515150614227](https://img.tynote.cn/img/typora/20250515150614932.png#400h)

![image-20250515151756450](https://img.tynote.cn/img/typora/20250515151757166.png#400h)

![image-20250515151835578](https://img.tynote.cn/img/typora/20250515151836285.png#400h)

![image-20250515151905378](https://img.tynote.cn/img/typora/20250515151906067.png#400h)

![image-20250515151928340](https://img.tynote.cn/img/typora/20250515151929049.png#400h)

#### 3️⃣补码的另一种算术移位方法

- 例1

![image-20250515154108995](https://img.tynote.cn/img/typora/20250515154109638.png#400h)

![image-20250515152647031](https://img.tynote.cn/img/typora/20250515152647693.png#400h)



![image-20250515161843698](https://img.tynote.cn/img/typora/20250515161844264.png)

**在之前学习补码的过程中我们已经知道了补码全是正数，只不过是通过其最高位可以反应原来真值的正负，此处$[+26]_补$算术左移3位后，相当于乘以$2^3$，即$+26×3=+208$，只不过算术左移3位后，最高位由原来的0变成了1，因此反应出原来的真值为负数，所以208对应的负数即为$[x]_补=x+2^8,\therefore x=[x]_补-2^8，即x=208-256=-48$**

- 例2

![image-20250515154217020](https://img.tynote.cn/img/typora/20250515154217665.png#400h)

![image-20250515152720782](https://img.tynote.cn/img/typora/20250515152721451.png#400h)

- 练习1

![image-20250515154413592](https://img.tynote.cn/img/typora/20250515154414241.png#400h)

- 练习2

![image-20250515154613698](https://img.tynote.cn/img/typora/20250515154614338.png#400h)

![image-20250515155128763](https://img.tynote.cn/img/typora/20250515155129415.png#400h)

#### 4️⃣算术移位的应用举例

![image-20250515155756154](https://img.tynote.cn/img/typora/20250515155756813.png#400h)

#### 5️⃣C语言中的移位运算

![image-20250515163237577](https://img.tynote.cn/img/typora/20250515163238330.png#400h)

**我们学习逻辑移位的过程中，了解到了逻辑移位只针对无符号数，而上图中有符号数si也会执行逻辑左移的原因是，计算机中或者C语言中数值都用补码表示，而补码的算术左移方法二类似于逻辑左移，都是高位移除，低位补0。（不太确定）**

- 习题

![image-20250515163932647](https://img.tynote.cn/img/typora/20250515163933306.png#400h)

![image-20250515164009131](https://img.tynote.cn/img/typora/20250515164009838.png#400h)

![image-20250515164056203](https://img.tynote.cn/img/typora/20250515164056914.png#400h)

![image-20250515164116894](https://img.tynote.cn/img/typora/20250515164117597.png#400h)

### 3.1.3循环移位

#### 1️⃣四种循环移位

![image-20250515170315976](https://img.tynote.cn/img/typora/20250515170316699.png#400h)

- 不带CF标志位的循环右移

![image-20250515170640393](https://img.tynote.cn/img/typora/20250515170641152.png#400h)

**寄存器中存储的各位二进制数同时向右移动，从最低位b0移出的二进制数会被移入到最高位b7，这样就构成了循环。另外，从最低位b0移出的二进制数还会存入CF标志位，但是CF标志位本身并不存在于循环右移中，因此称为"不带CF标志位的循环右移"**

![3.1-2-ezgif.com-video-to-gif-converter](https://img.tynote.cn/img/typora/20250515172141453.gif#400h)

![image-20250515172004641](https://img.tynote.cn/img/typora/20250515172005512.png#400h)

- 不带CF标志位的循环左移

![image-20250515172245217](https://img.tynote.cn/img/typora/20250515172245939.png#400h)

**寄存器中存储的各位二进制数同时向左移动，从最高位b7移出的二进制数会被移入到最高位b0，这样就构成了循环。另外，从最高位b7移出的二进制数还会存入CF标志位，但是CF标志位本身并不存在于循环左移中，因此称为"不带CF标志位的循环左移"**

![image-20250515172403535](https://img.tynote.cn/img/typora/20250515172404244.png#400h)

![image-20250515172430106](https://img.tynote.cn/img/typora/20250515172430831.png#400h)

- 带CF标志位的循环右移

![image-20250515173648245](https://img.tynote.cn/img/typora/20250515173649001.png#400h)

**对于带CF标志位的循环右移，CF标志位存储的二进制数和寄存器存储的各位二进制数同时向右移动，为了方便描述，我们将CF标志位初始存储的二进制数记为$x_{CF}$，从CF标志位移出的二进制数，会被移入到寄存器的最高位b7，而从寄存器最低位b0移出的二进制数，会被移入到CF标志位，这样就构成了带CF标志位的循环右移。**

![image-20250515173714107](https://img.tynote.cn/img/typora/20250515173714840.png#400h)

![image-20250515173749239](https://img.tynote.cn/img/typora/20250515173749956.png#400h)

- 带CF标志位的循环左移

![image-20250515174025707](https://img.tynote.cn/img/typora/20250515174026373.png#400h)

**对于带CF标志位的循环左移，CF标志位存储的二进制数和寄存器存储的各位二进制数同时向左移动，为了方便描述，我们将CF标志位初始存储的二进制数记为$x_{CF}$，从CF标志位移出的二进制数，会被移入到寄存器的最低位b0，而从寄存器最高位b7移出的二进制数，会被移入到CF标志位，这样就构成了带CF标志位的循环左移。**

![image-20250515174057202](https://img.tynote.cn/img/typora/20250515174057920.png#400h)

![image-20250515181310401](https://img.tynote.cn/img/typora/20250515181311417.png#400h)

#### 2️⃣循环移位的应用

![image-20250515181953678](https://img.tynote.cn/img/typora/20250515181954484.png#400h)

#### 3️⃣循环移位的C语言实现

![image-20250515184651524](https://img.tynote.cn/img/typora/20250515184652237.png#400h)

## 定点数的加法和减法运算

### 补码加减法运算公式

![image-20250515185005080](https://img.tynote.cn/img/typora/20250515185005857.png#400h)

![image-20250515185029291](https://img.tynote.cn/img/typora/20250515185030285.png#400h)

#### 1️⃣补码的加法运算公式

​	**此处我们是基于定点小数的补码定义来证明补码的加减法运算公式，也可以基于定整数的补码定义来证明补码的加减法运算公式，只不过证明过程的书写内容稍麻烦**



![image-20250515185521341](https://img.tynote.cn/img/typora/20250515185522094.png#400h)

- 符号同正

![image-20250515185600523](https://img.tynote.cn/img/typora/20250515185601503.png#400h)

- 符号相反

![image-20250515185728676](https://img.tynote.cn/img/typora/20250515185729400.png#400h)

![image-20250515185808483](https://img.tynote.cn/img/typora/20250515185809191.png#400h)

- 符号同负

![image-20250515201121223](https://img.tynote.cn/img/typora/20250515201122115.png#400h)

#### 2️⃣补码减法的运算公式

![image-20250515201549825](https://img.tynote.cn/img/typora/20250515201550600.png#400h)

![image-20250515201811725](https://img.tynote.cn/img/typora/20250515201812476.png#400h)

#### 3️⃣例题

![image-20250515202043909](https://img.tynote.cn/img/typora/20250515202044624.png#400h)

![image-20250515202127749](https://img.tynote.cn/img/typora/20250515202128529.png#400h)

![image-20250515202250125](https://img.tynote.cn/img/typora/20250515202250882.png#400h)

![image-20250515202347159](https://img.tynote.cn/img/typora/20250515202347963.png#400h)

![image-20250515202946476](https://img.tynote.cn/img/typora/20250515202947210.png#400h)

![image-20250515203154527](https://img.tynote.cn/img/typora/20250515203155274.png#400h)

![image-20250515203405345](https://img.tynote.cn/img/typora/20250515203406129.png#400h)

### 补码加减法的溢出检测

#### 1️⃣溢出的概念

![image-20250515203654742](https://img.tynote.cn/img/typora/20250515203655475.png#400h)

![image-20250515203707420](https://img.tynote.cn/img/typora/20250515203708290.png#400h)

#### 2️⃣溢出检测的三种方法

![image-20250515203818002](https://img.tynote.cn/img/typora/20250515203818731.png#400h)

- 方法1：根据操作数的符号位与运算结果的符号位是否一致进行判断

![q](https://img.tynote.cn/img/typora/20250515214351202.png#400h)

![image-20250515214418462](https://img.tynote.cn/img/typora/20250515214419215.png#400h)

![image-20250515214523049](https://img.tynote.cn/img/typora/20250515214523947.png#400h)

![image-20250515214604303](https://img.tynote.cn/img/typora/20250515214605115.png#400h)

![image-20250515215113067](https://img.tynote.cn/img/typora/20250515215113857.png#400h)

![image-20250515220220678](https://img.tynote.cn/img/typora/20250515220221445.png#400h)

![image-20250515220427233](https://img.tynote.cn/img/typora/20250515220427980.png#400h)
$$
方法1溢出检测的逻辑表达式
\begin{cases}
		x_{n-1}\cdot y_{n-1}\cdot \overline{s}_{n-1}\\
		\overline{x}_{n-1}\cdot \overline{y}_{n-1}\cdot s_{n-1}\\
	\end{cases}
$$
**上述溢出检测的逻辑表达式，第一个表达式可以认为$x_{n-1}与y_{n-1}$同为1，$s_{n-1}$为0时，结果为1；第二个表达式可以认为$x_{n-1}与y_{n-1}$同为0，$s_{n-1}$为1时，结果为1，将这两个表达式进行逻辑或运算，即可得到溢出标志位OF的逻辑表达式，如下图所示**

![image-20250515220506514](https://img.tynote.cn/img/typora/20250515220507287.png#400h)

![image-20250515221749201](https://img.tynote.cn/img/typora/20250515221750030.png#400h)

- 方法2：根据运算过程中最高数值位的进位与符号位的进位是否一致进行判断

![image-20250516091335695](https://img.tynote.cn/img/typora/20250516091343228.png#400h)

![image-20250516091447354](https://img.tynote.cn/img/typora/20250516091447860.png#400h)

![image-20250516091812905](https://img.tynote.cn/img/typora/20250516091813452.png#400h)

![image-20250516092023365](https://img.tynote.cn/img/typora/20250516092023849.png#400h)
$$
方法2溢出检测的逻辑表达式：OF=C_{n-1}\bigoplus C_n（异或：同0异1）
$$

- 方法3：利用变形补码(具有2位符号位的补码)的符号位进行判断

![image-20250516092443839](https://img.tynote.cn/img/typora/20250516092444456.png#400h)

![image-20250516093305779](https://img.tynote.cn/img/typora/20250516093306431.png#400h)

![image-20250516093402398](https://img.tynote.cn/img/typora/20250516093402999.png#400h)
$$
方法3溢出检测的逻辑表达式：OF=C_{n+1}\bigoplus C_n（异或：同0异1）
$$

#### 3️⃣习题

![image-20250516094603939](https://img.tynote.cn/img/typora/20250516094604673.png#400h)

![image-20250516094653250](https://img.tynote.cn/img/typora/20250516094654005.png#400h)

![image-20250516095624240](https://img.tynote.cn/img/typora/20250516095625290.png#400h)

![image-20250516095904772](https://img.tynote.cn/img/typora/20250516095905698.png#400h)

![image-20250516095937884](https://img.tynote.cn/img/typora/20250516095938649.png#400h)

![image-20250516100006402](https://img.tynote.cn/img/typora/20250516100007166.png#400h)

![image-20250516100041633](https://img.tynote.cn/img/typora/20250516100042397.png#400h)

![image-20250516100107621](https://img.tynote.cn/img/typora/20250516100108640.png#400h)

![image-20250516101111848](https://img.tynote.cn/img/typora/20250516101112719.png#400h)

![image-20250516101148608](https://img.tynote.cn/img/typora/20250516101149430.png#400h)

### 逻辑代数和逻辑门

#### 1️⃣逻辑代数中的逻辑运算



![image-20250516101328823](https://img.tynote.cn/img/typora/20250516101329755.png#400h)

#### 2️⃣基本逻辑运算与基本逻辑门

- 与运算和与门

​	**与运算：全1为1**

![image-20250516102001603](https://img.tynote.cn/img/typora/20250516102002449.png#400h)

![image-20250516102137996](https://img.tynote.cn/img/typora/20250516102138762.png#400h)

**注意，尽管我们在之后进行逻辑电路分析时，输入和输出都用二值逻辑中的1或0来表示，但是我们应该清楚，一般情况下，逻辑1在电路中用高电平来表示，例如`1.5V~4.2V`，逻辑0在电路中用低电平来表示，例如`500mv~1.8V`，另外，信号从输入到逻辑门开始，到逻辑门输出结果为止，是要耗费时间的，称为逻辑门的传播延迟，简称为门级延迟，一般为纳秒级，例如，工作电压为6V，线路的负载电容为50pF(皮法)的情况下，最大门级延迟为15ns，上述电气特性，可参看具体芯片的数据手册。**

![image-20250516103023109](https://img.tynote.cn/img/typora/20250516103023876.png#400h)

**例如，这是7408芯片，其内部包含有4个与门，下图是其内部各与门的输入/输出端与芯片外部的引脚的对应关系，需要注意的是，生产74系列芯片的产家不止一家，电气特性可能有所不同。**

- 或运算和或门

​	**或运算：存1为1**

![image-20250516103257241](https://img.tynote.cn/img/typora/20250516103258026.png#400h)

![image-20250516103416267](https://img.tynote.cn/img/typora/20250516103417018.png#400h)

- 非运算和非门

![image-20250516103518238](https://img.tynote.cn/img/typora/20250516103519190.png#400h)

![image-20250516103614376](https://img.tynote.cn/img/typora/20250516103615387.png#400h)

#### 3️⃣复合逻辑运算与复合逻辑门

- 与非运算和与非门

​	**与非运算：全1为0**

![image-20250516103818888](https://img.tynote.cn/img/typora/20250516103819691.png#400h)

![image-20250516104655615](https://img.tynote.cn/img/typora/20250516104656399.png#400h)

![image-20250516105014151](https://img.tynote.cn/img/typora/20250516105014904.png#400h)

![image-20250516105118009](https://img.tynote.cn/img/typora/20250516105118985.png#400h)

![image-20250516105532951](https://img.tynote.cn/img/typora/20250516105533975.png#400h)

![image-20250516105719971](https://img.tynote.cn/img/typora/20250516105720779.png#400h)

![image-20250516152752864](https://img.tynote.cn/img/typora/20250516152753702.png#400h)

- 或非运算和或非门

​	**或非运算：全0为1**

![image-20250516152929076](https://img.tynote.cn/img/typora/20250516152929912.png#400h)

![image-20250516153433430](https://img.tynote.cn/img/typora/20250516153434351.png#400h)

![image-20250516153519246](https://img.tynote.cn/img/typora/20250516153520152.png#400h)

- 异或运算和异或门

​	**异或运算：相同为0，不同为1**



![image-20250516153939265](https://img.tynote.cn/img/typora/20250516153939978.png#400h)

![image-20250516154051979](https://img.tynote.cn/img/typora/20250516154053097.png#400h)

![image-20250516154321713](https://img.tynote.cn/img/typora/20250516154322419.png#400h)

![image-20250516154757636](https://img.tynote.cn/img/typora/20250516154758497.png#400h)

![image-20250516154943004](https://img.tynote.cn/img/typora/20250516154943835.png#400h)

![image-20250516155020692](https://img.tynote.cn/img/typora/20250516155021940.png#400h)

- 同或运算和同或门

​	**同或运算：相同为1，不同为0。实际上就是异或运算取反。**



![image-20250516155235344](https://img.tynote.cn/img/typora/20250516155236013.png#400h)

#### 4️⃣基本逻辑门电路图形符号

![image-20250611091326431](https://img.tynote.cn/img/typora/20250611091335261.png#400h)

![image-20250611091449855](https://img.tynote.cn/img/typora/20250611091451050.png#400h)

![image-20250611091519281](https://img.tynote.cn/img/typora/20250611091520181.png)

### 一位全加器的硬件逻辑实现

![image-20250516155613103](https://img.tynote.cn/img/typora/20250516155613933.png#400h)

![image-20250516161315805](https://img.tynote.cn/img/typora/20250516161316746.png#400h)

![image-20250516161726462](https://img.tynote.cn/img/typora/20250516161727292.png#400h)

​	**例如$X_i,Y_i,C_i$为0时，得到的$S_i,C_{i+1}$为0**

![image-20250516161938064](https://img.tynote.cn/img/typora/20250516161938848.png#400h)

​	**所有组合的真值表：**

![image-20250516162213852](https://img.tynote.cn/img/typora/20250516162214669.png#400h)

![image-20250516162426275](https://img.tynote.cn/img/typora/20250516162427499.png#400h)

![image-20250516162816189](https://img.tynote.cn/img/typora/20250516162817370.png#400h)

![image-20250516163303329](https://img.tynote.cn/img/typora/20250516163304182.png#400h)

![image-20250516163548509](https://img.tynote.cn/img/typora/20250516163549690.png#400h)

![image-20250516164207688](https://img.tynote.cn/img/typora/20250516164208560.png#400h)

![image-20250516164419536](https://img.tynote.cn/img/typora/20250516164420423.png#400h)

### 串行进位加法器的硬件逻辑实现

![image-20250516164623626](https://img.tynote.cn/img/typora/20250516164624960.png#400h)

#### 1️⃣构建8位及n位串行进位加法器

​	**根据其进位信号的产生特点，称为串行进位加法器，也称为行波进位加法器。**



![image-20250516165146721](https://img.tynote.cn/img/typora/20250516165147818.png#400h)

![image-20250516170141580](https://img.tynote.cn/img/typora/20250520160538282.png#400h)

**因此我们需要添加一个异或门，如下图所示**

![image-20250516165836682](https://img.tynote.cn/img/typora/20250516165837584.png#400h)

![image-20250516165906201](https://img.tynote.cn/img/typora/20250516165907067.png#400h)

#### 2️⃣改造n位串行进位加法器

- 改造上述电路，使其既可以做补码加法，也可以做补码减法

![image-20250516165954098](https://img.tynote.cn/img/typora/20250516165954969.png#400h)

​	**改造过程：①首先断开操作数Y的每一位与其对应的n位串行进位加法器中的一位全加器的输入端的连接**

![image-20250516170713346](https://img.tynote.cn/img/typora/20250516170714147.png#400h)

​	**②在其之间各添加一个异或门，各异或门的输出端连接到相对应的一位全加器的输入端**

![image-20250516170840734](https://img.tynote.cn/img/typora/20250516170841569.png#400h)

​	**③操作数Y的每一位输入连接到相对应的异或门的一个输入端，各异或门的另一个输入端连接在一起，作为加法运算和减法运算的切换控制端`Sub`**

![image-20250516171035895](https://img.tynote.cn/img/typora/20250516171036756.png#400h)

​	**根据异或的特点我们知道，当给`Sub`端输入1时，各异或门的输出即为操作数Y的每一位取反，于是这一步我们就实现了求$[-Y]_补$的取反过程**

![image-20250516171342414](https://img.tynote.cn/img/typora/20250516171343222.png#400h)

​	**当给`Sub`端输入0时，各异或门的输出与操作数Y的每一位相同**

![image-20250516171704408](https://img.tynote.cn/img/typora/20250516171705227.png#400h)

​	**将`Sub`端连接到n位串行进位加法器中的最低位的一位全加器的输入端**

![image-20250516172005826](https://img.tynote.cn/img/typora/20250516172006702.png#400h)

​	**这样，当给`Sub`端输入1时，各异或门的输出即为操作数Y的每一位的取反，而输入到`Sub`端的1，也会输入到最低位的一位全加器的进位输入端，进而实现末位加1**

![image-20250516172234473](https://img.tynote.cn/img/typora/20250516172235459.png#400h)

​	**而当给`Sub`端输入0时，各异或门的输出与操作数Y的每一位相同，而输入到`Sub`端的0，也会输入到最低位的一位全加器的输入端，这并不影响加法运算的结果**

![image-20250516172424666](https://img.tynote.cn/img/typora/20250516172425324.png#400h)

#### 3️⃣分析串行进位加法器的性能

​	**假设在T0时刻，相关信号同时输入到n位串行进位加法器的相关输入端，不难看出，两个操作数的相关信号同时输入到了相应的一位全加器的输入端，而对于进位信号，此时只有最低位的一位全加器的进位输入端`C_0`有信号输入，而其他一位全加器的进位输入端要依次等待其相邻低位的一位全加器的进位输入端产生的进位信号，这就是所谓的串行进位或行波进位。**

​	**因此，我们首先来分析最低位的一位全家器`FA_0`的处理，这是T0时刻，各输入信号到达相关逻辑门的情况**

![image-20250516173352077](https://img.tynote.cn/img/typora/20250516173352747.png#400h)

​	**1T时间后，有信号从最上面的与门输出，并到达其最左侧的或门**

![image-20250516173524494](https://img.tynote.cn/img/typora/20250516173525160.png#400h)

​	**3T时间后，最下方的异或门有信号输出，并到达相关的逻辑门**

![image-20250516173735905](https://img.tynote.cn/img/typora/20250516173736583.png#400h)

​	**4T时间后，中间的与门有信号输出，并到达其左侧的或门**

![image-20250516173834794](https://img.tynote.cn/img/typora/20250516173835923.png#400h)

​	**5T时间后，该或门输出信号，而该信号就是`FA_0`产生的进位输出信号**

![image-20250516174005644](https://img.tynote.cn/img/typora/20250516174006487.png#400h)

​	**6T时间后，左侧的异或门输出信号，而该信号就是`FA_0`产生的本为和信号**

![image-20250516174951513](https://img.tynote.cn/img/typora/20250516174952527.png#400h)

​	**再来分析`FA_1`的处理，通过之前的分析知道，5T时间后，`FA_0`产生的进位输出信号进入`FA_1`的进位输入端，而`FA_1`的其他各输入端从T0时刻起就有相关信号输入了，因此，6T时间后，中间的与门有信号输出，并到达其左侧的或门，7T时间后，该或门输出信号，而该信号就是`FA_1`产生的进位输出信号，8T时间后，左侧的异或门输出信号，而该信号就是`FA_1`产生的本位和信号**

![image-20250516175509364](https://img.tynote.cn/img/typora/20250516175510090.png#400h)

​	**以此类推，不难得到每个一位全加器产生进位输出、本位和输出各自需要等待的时间**

![image-20250516175753596](https://img.tynote.cn/img/typora/20250516175754329.png#400h)

![image-20250516175836627](https://img.tynote.cn/img/typora/20250516175837487.png#400h)

#### 4️⃣习题

![image-20250516180025486](https://img.tynote.cn/img/typora/20250516180026320.png#400h)

![image-20250516180615556](https://img.tynote.cn/img/typora/20250516180616404.png#400h)

![image-20250516180714552](https://img.tynote.cn/img/typora/20250516180715470.png#400h)

![image-20250516180746173](https://img.tynote.cn/img/typora/20250516180747073.png#400h)

![image-20250516180832361](https://img.tynote.cn/img/typora/20250516180833410.png#400h)

![image-20250516180946871](https://img.tynote.cn/img/typora/20250516180947741.png#400h)

![image-20250516181113993](https://img.tynote.cn/img/typora/20250516181115064.png#400h)

![image-20250516181149607](https://img.tynote.cn/img/typora/20250516181150755.png#400h)

![image-20250516181210526](https://img.tynote.cn/img/typora/20250516181211350.png#400h)

![image-20250516181258269](https://img.tynote.cn/img/typora/20250520160538283.png#400h)

### 先行进位加法器的硬件实现

#### 1️⃣构建先行进位加法器

​	**如果能够打破串行进位加法器中的进位依赖，提前得到所有一位全加器所需的进位输入信号，也就是所谓的先行进位，这样，所有一位全加器都可以并行运算，从而可以提高运算性能。**

![image-20250516194646482](https://img.tynote.cn/img/typora/20250516194647427.png#400h)

![image-20250516195035649](https://img.tynote.cn/img/typora/20250516195037032.png#400h)

![image-20250516195224361](https://img.tynote.cn/img/typora/20250516195225253.png#400h)

![image-20250516195714002](https://img.tynote.cn/img/typora/20250516195714875.png#400h)

![image-20250516195725493](https://img.tynote.cn/img/typora/20250516195726375.png#400h)

![image-20250516195850179](https://img.tynote.cn/img/typora/20250516195851080.png#400h)

![image-20250516195935540](https://img.tynote.cn/img/typora/20250516195936341.png#400h)

#### 2️⃣基于4位先行进位电路构建4位快速加法器

![image-20250516200026041](https://img.tynote.cn/img/typora/20250516200026939.png#400h)

​	**根据进位生成函数`G_i`的逻辑表达式可知，每个数位的进位生成函数都是由参与加法运算的两个操作数X和Y的相应数位的与运算得出，因此，我们给先行进位电路的`G_0~G_3`这四个输入端各连接一个与门；根据进位传递函数`P_i`的逻辑表达式可知，每个数位的进位传递函数都是由参与加法运算的两个操作数X和Y的相应数位异或运算得出，因此，我们给先行进位电路的`P_0~P_3`这四个输入端各连接异或门**

![image-20250516201104706](https://img.tynote.cn/img/typora/20250516201105416.png#400h)

​	**之后，将两个操作数X和Y的各数位连接到相应的与门和异或门的输入端**

![image-20250516201211352](https://img.tynote.cn/img/typora/20250516201212209.png#400h)

​	**根据本位和`S_i`的逻辑表达式可知，它由进位输入`C_i`和进位传递函数`P_i`的异或运算得出，因此，我们在上述电路的基础上，再增加求本位和的电路即可，至此，我们就基于4位先行进位电路构建出了4位快速加法器**

![image-20250516201539721](https://img.tynote.cn/img/typora/20250516201540753.png#400h)

#### 3️⃣分析4位快速加法器的性能

![image-20250516202048834](https://img.tynote.cn/img/typora/20250516202049732.png#400h)

- 完整分析过程

<video src="https://img.tynote.cn/img/typora/20250516202747521.mp4" width="720" height="405" preload="none"  controls>            </video>

#### 4️⃣4位快速加法器与4位串行进位加法器性能比较

![image-20250516203154638](https://img.tynote.cn/img/typora/20250516203156762.png#400h)

​	**为了方便进行后续对比，我们使用4位快速加法器构建更大位宽的加法器电路**

![image-20250516203327201](https://img.tynote.cn/img/typora/20250516203328005.png#400h)

![image-20250516203429598](https://img.tynote.cn/img/typora/20250516203430534.png#400h)

​	**接下来分析通过进位串联方式构建的16位加法器的性能，假设T0时刻，参与加法运算的i盎格16位操作数X和Y以及进位输入`C_0`同时到达16位快速加法器的相应的输入端**

![image-20250516204158780](https://img.tynote.cn/img/typora/20250516204200127.png#400h)

![image-20250516204608451](https://img.tynote.cn/img/typora/20250516204609493.png#400h)

- 完整分析过程

<video src="https://img.tynote.cn/img/typora/20250516205346252.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250516205603363](https://img.tynote.cn/img/typora/20250516205604393.png#400h)

![image-20250516205640092](https://img.tynote.cn/img/typora/20250520160144428.png#400h)

#### 5️⃣可级联的4位先行进位电路

![image-20250516205823089](https://img.tynote.cn/img/typora/20250516205824354.png#400h)

![image-20250516205906405](https://img.tynote.cn/img/typora/20250516205907343.png#400h)

![image-20250516205952068](https://img.tynote.cn/img/typora/20250516205953022.png#400h)

![image-20250516210049703](https://img.tynote.cn/img/typora/20250516210050655.png#400h)

![image-20250516210258723](https://img.tynote.cn/img/typora/20250516210259670.png#400h)

#### 6️⃣构建16位组内、组间并行加法器

![image-20250516210606679](https://img.tynote.cn/img/typora/20250516210607743.png#400h)

![image-20250516210935829](https://img.tynote.cn/img/typora/20250516210936850.png#400h)

![image-20250516210959854](https://img.tynote.cn/img/typora/20250516211000883.png#400h)

![image-20250516211015472](https://img.tynote.cn/img/typora/20250516211016450.png#400h)

- 完整构建过程

<video src="https://img.tynote.cn/img/typora/20250516211218788.mp4" width="720" height="405" preload="none"  controls>            </video>

#### 7️⃣分析16位组内、组间并行加法器的性能

![image-20250516211647737](https://img.tynote.cn/img/typora/20250516211648737.png#400h)

- 完整分析过程

<video src="https://img.tynote.cn/img/typora/20250516211919098.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250516212020722](https://img.tynote.cn/img/typora/20250516212021821.png#400h)

## 无符号数的乘法运算硬件逻辑实现

#### 1️⃣笔算乘法的分析

![image-20250518200342034](https://img.tynote.cn/img/typora/20250518200349863.png#400h)

![image-20250518200410940](https://img.tynote.cn/img/typora/20250518200411655.png#400h)

![image-20250518200427076](https://img.tynote.cn/img/typora/20250518200427769.png#400h)

![image-20250518200530101](https://img.tynote.cn/img/typora/20250518200530898.png#400h)

![image-20250518200601655](https://img.tynote.cn/img/typora/20250518200602251.png#400h)

![image-20250518200734846](https://img.tynote.cn/img/typora/20250518200735558.png#400h)

![image-20250518200748705](https://img.tynote.cn/img/typora/20250518200749695.png#400h)

![image-20250518200812646](https://img.tynote.cn/img/typora/20250518200813363.png#400h)

![image-20250518200939327](https://img.tynote.cn/img/typora/20250518200940028.png#400h)

![image-20250518201026877](https://img.tynote.cn/img/typora/20250518201027630.png#400h)

![image-20250518201226773](https://img.tynote.cn/img/typora/20250518201227693.png#400h)

#### 2️⃣笔算乘法的改进

![image-20250518201328786](https://img.tynote.cn/img/typora/20250518201329490.png#400h)

![image-20250518201456154](https://img.tynote.cn/img/typora/20250518201456874.png#400h)

![image-20250518201614186](https://img.tynote.cn/img/typora/20250518201615090.png#400h)

#### 3️⃣无符号数乘法的硬件逻辑实现

![image-20250518201708469](https://img.tynote.cn/img/typora/20250518201709216.png#400h)

![image-20250518201938172](https://img.tynote.cn/img/typora/20250518201939074.png#400h)

![image-20250518203125259](https://img.tynote.cn/img/typora/20250518203126049.png#400h)

- 完整运算过程

<video src="https://img.tynote.cn/img/typora/20250518204003274.mp4" width="720" height="405" preload="none"  controls>            </video>

## 定点数的乘法运算

### 原码乘法运算的硬件逻辑实现

![image-20250518204734251](https://img.tynote.cn/img/typora/20250518204735034.png#400h)

**需要说明的是，这里的一位乘法并不是指参与运算的两个操作数是一位的，而是指在乘法运算过程中，每次根据乘数中的一位来计算位积。**

![image-20250518215702099](https://img.tynote.cn/img/typora/20250518215702887.png#400h)

**由于我们采用的是两个操作数的绝对值原码，因此可将它们看作是无符号数，所以右移一位的操作属于逻辑右移**

![image-20250518220128459](https://img.tynote.cn/img/typora/20250518220129174.png#400h)

![image-20250518220302996](https://img.tynote.cn/img/typora/20250518220303742.png#400h)

### 补码乘法运算的硬件逻辑实现

#### 1️⃣Booth算法的推导和分析



![image-20250519100025162](https://img.tynote.cn/img/typora/20250519100032851.png#400h)

![image-20250519101706283](https://img.tynote.cn/img/typora/20250519101706842.png#400h)

**此处根据模数性质得到结果为2不理解**

![image-20250519102506756](https://img.tynote.cn/img/typora/20250519102507365.png#400h)

![image-20250519102621824](https://img.tynote.cn/img/typora/20250519102622422.png#400h)

![image-20250519102919929](https://img.tynote.cn/img/typora/20250519102920518.png#400h)

![image-20250519103043432](https://img.tynote.cn/img/typora/20250519103044056.png#400h)

![image-20250519103228595](https://img.tynote.cn/img/typora/20250519103229195.png#400h)

![image-20250519103355607](https://img.tynote.cn/img/typora/20250519103356241.png#400h)

![image-20250519103424821](https://img.tynote.cn/img/typora/20250519103425421.png#400h)

#### 2️⃣Booth算法的硬件逻辑实现

![image-20250519153122943](https://img.tynote.cn/img/typora/20250519153123664.png#400h)

![image-20250519153221003](https://img.tynote.cn/img/typora/20250519153221708.png#400h)

![image-20250519153247079](https://img.tynote.cn/img/typora/20250519153247810.png#400h)

![image-20250519153436004](https://img.tynote.cn/img/typora/20250519153436734.png#400h)

- 译码器、反相器和选择器的作用说明

<video src="https://img.tynote.cn/img/typora/20250519161314851.mp4" width="720" height="405" preload="none"  controls>            </video>

​	**$y_i=1，y_{i+1}=0$时，译码器结果为100，表示要经过反相器这条通路**

![image-20250519174853879](https://img.tynote.cn/img/typora/20250519174854629.png#400h)

**$y_i=1，y_{i+1}=1或y_i=0，y_{i+1}=0$，译码器结果为001，表示走选择器这条通路，选择器的这个选择输入端收到有效信号后，会将从这个数据输入端输入的信号，也就是全0，从数据输出端输出，这样，全0就输出给了算术逻辑单元ALU中的加法器作为其中一个操作数**

![image-20250519181637307](https://img.tynote.cn/img/typora/20250519181637934.png#400h)

**$y_i=0，y_{i+1}=1$，选择器的这个选择是输入端接收到有效信号后，会将从这个数据输入端输入的信号，也就是操作数寄存器X中存放的被乘数x的补码，从数据输出端输出，这样，被乘数x的补码就被输入给了算术逻辑单元ALU中的加法器，作为其中一个操作数**

![image-20250519182330107](https://img.tynote.cn/img/typora/20250519182330757.png#400h)

​	**最后，要舍弃乘数y的符号位1，以及去除之前添加的辅助位的位置（该方框连同其中数值一并舍弃）**

![image-20250519182118367](https://img.tynote.cn/img/typora/20250519182119034.png#400h)

​	**流程图**

![image-20250519184209570](https://img.tynote.cn/img/typora/20250519184210217.png#400h)



- 本例乘法运算逻辑执行过程

<video src="https://img.tynote.cn/img/typora/20250519184447137.mp4" width="720" height="405" preload="none"  controls>            </video>

#### 3️⃣习题

- 习题1

![image-20250519184612414](https://img.tynote.cn/img/typora/20250519184613236.png#400h)

![image-20250519184635029](https://img.tynote.cn/img/typora/20250519184636058.png#400h)

![image-20250519184718741](https://img.tynote.cn/img/typora/20250519184719753.png#400h)

![image-20250519184745335](https://img.tynote.cn/img/typora/20250519184746375.png#400h)

![image-20250519185019296](https://img.tynote.cn/img/typora/20250519185020116.png#400h)

- 习题2 

![image-20250519185201303](https://img.tynote.cn/img/typora/20250519185202062.png#400h)

![image-20250519185239449](https://img.tynote.cn/img/typora/20250519185240270.png#400h)

### 无符号阵列乘法器

#### 1️⃣构建无符号阵列乘法器

![image-20250519185553395](https://img.tynote.cn/img/typora/20250519185554160.png#400h)

![image-20250519185730023](https://img.tynote.cn/img/typora/20250519185730738.png#400h)

![image-20250519190243011](https://img.tynote.cn/img/typora/20250519190243792.png#400h)

![image-20250519190124203](https://img.tynote.cn/img/typora/20250519190124928.png#400h)

![image-20250519190437409](https://img.tynote.cn/img/typora/20250519190438239.png#400h)

![image-20250519190456307](https://img.tynote.cn/img/typora/20250519190457314.png#400h)

#### 2️⃣性能分析

![image-20250519190839741](https://img.tynote.cn/img/typora/20250519190840500.png#400h)

![image-20250519191126284](https://img.tynote.cn/img/typora/20250520160518484.png#400h)

![image-20250519191614224](https://img.tynote.cn/img/typora/20250519191614972.png#400h)

![image-20250519191711727](https://img.tynote.cn/img/typora/20250519191712793.png#400h)

![image-20250519191733383](https://img.tynote.cn/img/typora/20250519191734147.png#400h)

### 补码阵列乘法器

#### 1️⃣逻辑实现

![image-20250519201917833](https://img.tynote.cn/img/typora/20250519201918740.png#400h)

![image-20250519202021958](https://img.tynote.cn/img/typora/20250519202022777.png#400h)

![image-20250519202110841](https://img.tynote.cn/img/typora/20250519202111694.png#400h)

![image-20250519202414663](https://img.tynote.cn/img/typora/20250519202415667.png#400h)

![image-20250519202512622](https://img.tynote.cn/img/typora/20250519202513537.png#400h)

![image-20250519202547025](https://img.tynote.cn/img/typora/20250519202548070.png#400h)

![image-20250519202629328](https://img.tynote.cn/img/typora/20250519202630312.png#400h)

![image-20250519202645788](https://img.tynote.cn/img/typora/20250519202646555.png#400h)

#### 2️⃣求补电路实现

​	**在串行进位加法器那一节中，曾介绍过，如何给串行进位加法器添加可控加减法电路，使其既可以进行补码加法运算，也可以进行补码减法运算，此处可以借鉴**

![image-20250519203226518](https://img.tynote.cn/img/typora/20250519203227336.png#400h)

![image-20250519203415252](https://img.tynote.cn/img/typora/20250519203416261.png#400h)

![image-20250519203442431](https://img.tynote.cn/img/typora/20250519203443223.png#400h)

![image-20250519203612093](https://img.tynote.cn/img/typora/20250519203613287.png#400h)

![image-20250519203641728](https://img.tynote.cn/img/typora/20250519203642887.png#400h)

#### 3️⃣求补电路改进

- 改进

![image-20250519203702591](https://img.tynote.cn/img/typora/20250519203703378.png#400h)

- 验证

![image-20250519204056554](https://img.tynote.cn/img/typora/20250519204057360.png#400h)

![image-20250519204834812](https://img.tynote.cn/img/typora/20250520160538284.png#400h)

![image-20250519205036555](https://img.tynote.cn/img/typora/20250520160538285.png#400h)

**上述或门，只要有一个为1，则由于会往前传播，也就是本次或门的输出结果1作为前面或门的输入，导致前面的或门输出全为1，而或门输出的1作为异或门的一个输入，导致对应的位取反，也就是实现了扫面法中的右起第一个1左面的数值位全部取反**

![image-20250519205521848](https://img.tynote.cn/img/typora/20250519205522698.png#400h)

## 定点数的除法运算

### 原码除法运算



![image-20250519205806155](https://img.tynote.cn/img/typora/20250519205807181.png#400h)

#### ①恢复余数法

###### 逻辑实现

![image-20250519205949016](https://img.tynote.cn/img/typora/20250519205950092.png#400h)

![image-20250519210023729](https://img.tynote.cn/img/typora/20250519210024919.png#400h)

![image-20250519210802825](https://img.tynote.cn/img/typora/20250519210803815.png#400h)

![image-20250519211050853](https://img.tynote.cn/img/typora/20250519211051566.png#400h)

**计算机无法直接判断大小，只能默认够减，减完发现结果小于0，才知道不够减，此时需要再加上被除数来恢复，而被除数又可看作是初始余数，所以叫做恢复余数法**

![image-20250519211242389](https://img.tynote.cn/img/typora/20250519211243206.png#400h)

![image-20250519211830455](https://img.tynote.cn/img/typora/20250519211831747.png#400h)

- 完整执行过程

<video src="https://img.tynote.cn/img/typora/20250519211736851.mp4" width="720" height="405" preload="none"  controls>            </video>

###### 硬件逻辑实现

![image-20250519211959021](https://img.tynote.cn/img/typora/20250519212000297.png#400h)

![image-20250519212220750](https://img.tynote.cn/img/typora/20250519212221546.png#400h)

![image-20250519212344734](https://img.tynote.cn/img/typora/20250519212345516.png#400h)

![image-20250519213242086](https://img.tynote.cn/img/typora/20250519213242865.png#400h)

![image-20250519213418861](https://img.tynote.cn/img/typora/20250519213419503.png#400h)

#### ②不恢复余数法

![image-20250519214922634](https://img.tynote.cn/img/typora/20250519214923417.png#400h)

![image-20250519214956408](https://img.tynote.cn/img/typora/20250519214957215.png#400h)

![image-20250519215214244](https://img.tynote.cn/img/typora/20250519215215043.png#400h)

![image-20250519215653773](https://img.tynote.cn/img/typora/20250519215654572.png#400h)

![image-20250519215718469](https://img.tynote.cn/img/typora/20250519215719242.png#400h)

![image-20250519215911454](https://img.tynote.cn/img/typora/20250519215912267.png#400h)

### 补码除法运算

![image-20250519220114963](https://img.tynote.cn/img/typora/20250519220115708.png#400h)

#### ①不恢复余数法



![image-20250519220152675](https://img.tynote.cn/img/typora/20250519220153434.png#400h)

###### 如何确定商值

![image-20250519220701874](https://img.tynote.cn/img/typora/20250519220702720.png#400h)

![image-20250519220722668](https://img.tynote.cn/img/typora/20250519220723509.png#400h)

![image-20250519221205455](https://img.tynote.cn/img/typora/20250519221206261.png#400h)

###### 如何形成商符

![image-20250519221501089](https://img.tynote.cn/img/typora/20250519221501805.png#400h)

**当X和Y的补码同号时，由于X的绝对值小于Y的绝对值，所以$[R_1]_{补}$与Y的补码必然是异号的，异号表示不够减，上商0，而这恰好作为商符，表示商为正；当X和Y的补码异号时，由于X的绝对值小于Y的绝对值，所以$[R_1]_{补}$与Y的补码必然是同号的，同号表示不够减，上商1，而这恰好作为商符，表示商为负**

**另外，商的符号还可以用来判断商是否溢出，当被除数X与除数Y的补码同号时，若余数$R_1$的补码与除数Y的补码同号时，上商1即为溢出；当被除数X与除数Y的补码异号时，若余数$R_1$的补码与除数Y的补码异号时，上商0即为溢出**

###### 如何得到新余数

![image-20250520095716595](https://img.tynote.cn/img/typora/20250520095717373.png#400h)

![image-20250520095748267](https://img.tynote.cn/img/typora/20250520095749063.png#400h)

![image-20250520095936291](https://img.tynote.cn/img/typora/20250520095937093.png#400h)

###### 例题

![image-20250520103059920](https://img.tynote.cn/img/typora/20250520103100687.png#400h)

![image-20250520103145148](https://img.tynote.cn/img/typora/20250520103145898.png#400h)

​	**其相应的硬件逻辑实现与上节课源码除法的不恢复余数法的硬件逻辑实现是相似的，另外，与阵列乘法器类似，为了加快除法的运算速度，也可以设计阵列除法器**



## 浮点运算

### 浮点加减法运算

#### 1️⃣运算方法及过程

![image-20250520104127242](https://img.tynote.cn/img/typora/20250520104128044.png#400h)

![image-20250520104301329](https://img.tynote.cn/img/typora/20250520104302242.png#400h)

![image-20250520104356362](https://img.tynote.cn/img/typora/20250520104357165.png#400h)

![image-20250520104704439](https://img.tynote.cn/img/typora/20250520104705551.png#400h)

![image-20250520104757654](https://img.tynote.cn/img/typora/20250520104758430.png#400h)

![image-20250520104958244](https://img.tynote.cn/img/typora/20250520104959085.png#400h)

![image-20250520105043548](https://img.tynote.cn/img/typora/20250520105044646.png#400h)

![image-20250520105217752](https://img.tynote.cn/img/typora/20250520105218559.png#400h)

![image-20250520105256474](https://img.tynote.cn/img/typora/20250520105257488.png#400h)

![image-20250520105326387](https://img.tynote.cn/img/typora/20250520105327169.png#400h)

![image-20250520105436797](https://img.tynote.cn/img/typora/20250520105437807.png#400h)

![image-20250520105453273](https://img.tynote.cn/img/typora/20250520105454027.png#400h)

![image-20250520105516117](https://img.tynote.cn/img/typora/20250520105516921.png#400h)

#### 2️⃣习题

![image-20250520105657874](https://img.tynote.cn/img/typora/20250520105658656.png#400h)

#### 3️⃣小结

![image-20250520105908921](https://img.tynote.cn/img/typora/20250520105909751.png#400h)

### IEEE 754浮点加减法运算

![image-20250520110035979](https://img.tynote.cn/img/typora/20250520110036921.png#400h)

![image-20250520110203098](https://img.tynote.cn/img/typora/20250520110204176.png#400h)

![image-20250520110251662](https://img.tynote.cn/img/typora/20250520110252525.png#400h)

![image-20250520110413071](https://img.tynote.cn/img/typora/20250520110413928.png#400h)

![image-20250520110506056](https://img.tynote.cn/img/typora/20250520110506876.png#400h)

![image-20250520110520767](https://img.tynote.cn/img/typora/20250520110521915.png#400h)

![image-20250520110603107](https://img.tynote.cn/img/typora/20250520110603942.png#400h)

### 浮点乘法运算

![image-20250520110810753](https://img.tynote.cn/img/typora/20250520110811584.png#400h)

### 浮点除法运算

![image-20250520111058438](https://img.tynote.cn/img/typora/20250520111059518.png#400h)

# 存储系统

## 存储器概述

![image-20250601175430435](https://img.tynote.cn/img/typora/20250601175438478.png#400h)

![image-20250601175622769](https://img.tynote.cn/img/typora/20250601175623591.png#400h)

![image-20250601180541932](https://img.tynote.cn/img/typora/20250601180543124.png#400h)

### 存储器的分类

#### 1️⃣按存储介质分

![image-20250601181131581](https://img.tynote.cn/img/typora/20250601181132389.png#400h)

![image-20250601181307435](https://img.tynote.cn/img/typora/20250601181308393.png#400h)

![image-20250601181349703](https://img.tynote.cn/img/typora/20250601181350473.png#400h)

#### 2️⃣按存取方式分

![image-20250601181444237](https://img.tynote.cn/img/typora/20250601181444981.png#400h)

**上图就是使用磁带机对磁带存储器的内容进行存取，磁带存储器中的磁带，被磁带机中的旋转装置带动旋转，磁带机中的磁头贴近磁带，对其进行存取操作，很显然，要读取磁带某段区域存储的内容时，需要等到旋转装置带动磁带旋转到这段区域，到达磁头位置才能进行。**

![image-20250601181940683](https://img.tynote.cn/img/typora/20250601181941553.png#400h)

**第1章曾介绍过，要访问内存中的某个存储单元的内容，只要将该单元的地址写入到存储器地址寄存器MAR中，这样就可以对该存储单元进行读取或写入操作。**

![image-20250601182256319](https://img.tynote.cn/img/typora/20250601182257137.png#400h)

**属于直接存取存储器的机械硬盘就比属于顺序存取存储器的磁带多了一个访问维度，也就是磁头是摆动的，而不是固定的**

- 机械硬盘的内部构成和运行原理

<video src="https://img.tynote.cn/img/typora/20250601182732666.mp4" width="720" height="405" preload="none"  controls>            </video>

#### 3️⃣按可改写性分

![image-20250601182914687](https://img.tynote.cn/img/typora/20250601182915984.png#400h)

![image-20250601183019651](https://img.tynote.cn/img/typora/20250601183020502.png#400h)

**上图为BIOS(Basic Input Output System)配置界面，相信喜欢CPU超频和内存超频的同学并不陌生，其程序代码和配置参数存储在主板上一颗半导体只读存储器芯片中，现代主流的计算机主板厂商都提供了更新这种芯片存储信息的便捷方法，但对于普通的计算机用户，一般很少用到。**

![image-20250601183342548](https://img.tynote.cn/img/typora/20250601183343407.png#400h)

**学习过计算机网络的同学应该知道，以太网卡上固化有MAC地址，例如，上图中的网卡上使用了EEPROM，也就是电可擦可编程只读存储器，例如93C46芯片，来存储MAC地址以及产品相关信息。**

#### 4️⃣按可保存性分

![image-20250601183626985](https://img.tynote.cn/img/typora/20250601183627890.png#400h)

![image-20250601183658719](https://img.tynote.cn/img/typora/20250601183659603.png#400h)

**需要注意的是，对于固态硬盘，断电后长期不通电，例如2年以上，有可能造成存储信息的丢失，当然，这与环境温度，产品是消费级还是企业级等多个因素有关。**

#### 5️⃣按功能和存储速度分

![image-20250601184012821](https://img.tynote.cn/img/typora/20250601184013785.png#400h)

![image-20250601184112529](https://img.tynote.cn/img/typora/20250601184113868.png#400h)

![image-20250601184139468](https://img.tynote.cn/img/typora/20250601184140593.png#400h)

![image-20250601184200717](https://img.tynote.cn/img/typora/20250601184201603.png#400h)

![image-20250601184210714](https://img.tynote.cn/img/typora/20250601184211594.png#400h)

#### 6️⃣总结

![image-20250601184259802](https://img.tynote.cn/img/typora/20250601184300718.png#400h)

### 存储器性能指标和存储系统层次结构

#### 1️⃣存储器性能指标

![image-20250601204508482](https://img.tynote.cn/img/typora/20250601204509462.png#400h)

![image-20250604162127495](https://img.tynote.cn/img/typora/20250604162128364.png#400h)

![image-20250601204602388](https://img.tynote.cn/img/typora/20250601204745944.png#400h)

#### 2️⃣存储系统层次结构

![image-20250601205144947](https://img.tynote.cn/img/typora/20250601205146319.png#400h)

### 主存的基本结构

![image-20250601205357967](https://img.tynote.cn/img/typora/20250601205359083.png#400h)

![image-20250601205507112](https://img.tynote.cn/img/typora/20250601205508477.png#400h)

![image-20250601205922472](https://img.tynote.cn/img/typora/20250601205923722.png#400h)

![image-20250601210052412](https://img.tynote.cn/img/typora/20250601210053215.png#400h)

**实际上，存储器地址寄存器MAR的内容由CPU通过地址总线送入，存储器数据寄存器MDR用于暂存CPU通过数据总线送来的待写入存储体中某个单元的信息，或者暂存从存储体中某个存储单元读出的信息，而上述操作，以及地址译码器的译码，都需要在CPU的控制下进行，由于控制信号往往不止一个，因此将传输各种控制信号的传输线统称为控制总线。下面，我们分别举例说明，CPU从主存中读取信息的过程，以及向主存中写入信息的过程。**

- CPU从主存中读取信息的过程

<video src="https://img.tynote.cn/img/typora/20250601211037731.mp4" width="720" height="405" preload="none"  controls>            </video>

- CPU向主存写入信息的过程

<video src="https://img.tynote.cn/img/typora/20250601211221381.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250601211255575](https://img.tynote.cn/img/typora/20250601211256511.png#400h)

### 用于地址译码的译码结构

​	**随着硬件技术的发展，内存都制成大规模集成电路芯片，而将MAR和MDR集成到了CPU中。因此，当我们再画出主存的结构时，除特别需要，就不再画出MAR和MDR了。**

​	**地址译码器的译码结构分为单译码结构和双译码结构。**

#### 1️⃣单译码结构

![image-20250601212247796](https://img.tynote.cn/img/typora/20250601212249522.png#400h)

#### 2️⃣双译码结构

![image-20250601213336696](https://img.tynote.cn/img/typora/20250601213337947.png#400h)

![image-20250601213623580](https://img.tynote.cn/img/typora/20250601213624413.png#400h)

### 主存中数据的存放

#### 1️⃣机器字长与存储字长的区别

![image-20250601213819565](https://img.tynote.cn/img/typora/20250601213820422.png#400h)

#### 2️⃣地址访问模式

![image-20250601214058528](https://img.tynote.cn/img/typora/20250601214059703.png#400h)

![image-20250601214142643](https://img.tynote.cn/img/typora/20250601214143858.png#400h)

![image-20250601214220166](https://img.tynote.cn/img/typora/20250601214221351.png#400h)

![image-20250601214402848](https://img.tynote.cn/img/typora/20250601214403685.png#400h)

**即，1位是字节，16位是半字，32位是字**

![image-20250601214545728](https://img.tynote.cn/img/typora/20250601214546892.png#400h)

- intel x86汇编语言访问不同存储单元举例（假设数据段寄存器DS的值为0）

![image-20250601214935751](https://img.tynote.cn/img/typora/20250601214936559.png#400h)

![image-20250601214952335](https://img.tynote.cn/img/typora/20250601214953231.png#400h)

![	](https://img.tynote.cn/img/typora/20250601215110732.png#400h)

![image-20250601215332495](https://img.tynote.cn/img/typora/20250601215333729.png#400h)

![image-20250601215403763](https://img.tynote.cn/img/typora/20250601215404869.png#400h)

**假设存储字长为32位，也就是存储单元由4字节构成，若采用字访问模式，则通过字节地址的后两位可知道选择的是存储单元的哪一个字节，比如字节地址后两位为00，则选择的是该存储单元的最低位字节**

![image-20250601215517560](https://img.tynote.cn/img/typora/20250601215519109.png#400h)

**若采用半字访问模式，（机器字长为32位，即存储单元由4字节构成），则通过字节地址的倒数第二位可知道选择的是存储单元的哪个半字，例如，本例上中若字节地址倒数第二位为0，则选择的是该存储单元的低两位字节（也就是最低位半字）**

#### 3️⃣大端和小端方式

![image-20250601220418391](https://img.tynote.cn/img/typora/20250601220419693.png#400h)

![image-20250601220554794](https://img.tynote.cn/img/typora/20250601220555621.png#400h)

![image-20250601220649360](https://img.tynote.cn/img/typora/20250601220650746.png#400h)

![image-20250601220729817](https://img.tynote.cn/img/typora/20250601220731012.png#400h)

#### 4️⃣数据的边界对齐

![image-20250601220842258](https://img.tynote.cn/img/typora/20250601220843105.png#400h)

![image-20250602151122127](https://img.tynote.cn/img/typora/20250602151130003.png#400h)

![image-20250602151336184](https://img.tynote.cn/img/typora/20250602151337384.png#400h)

#### 5️⃣习题

![image-20250602151704851](https://img.tynote.cn/img/typora/20250602151705816.png#400h)

![image-20250602151737468](https://img.tynote.cn/img/typora/20250602151738387.png#400h)

![image-20250602151822270](https://img.tynote.cn/img/typora/20250602151823230.png#400h)

![image-20250602151849460](https://img.tynote.cn/img/typora/20250602151850239.png#400h)

## 静态随机存取存储器SRAM

### 存储元

![image-20250602152332942](https://img.tynote.cn/img/typora/20250602152333721.png#400h)

![image-20250602192235310](https://img.tynote.cn/img/typora/20250602192236129.png#400h)

![image-20250602153624400](https://img.tynote.cn/img/typora/20250602153625233.png#400h)

- 存储元工作原理

<video src="https://img.tynote.cn/img/typora/20250602153739185.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250602153933017](https://img.tynote.cn/img/typora/20250602153933831.png#400h)

- 读操作的原理

<video src="https://img.tynote.cn/img/typora/20250602154031975.mp4" width="720" height="405" preload="none"  controls>            </video>

- 写操作的工作原理

<video src="https://img.tynote.cn/img/typora/20250602154354226.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250602154456129](https://img.tynote.cn/img/typora/20250602154456940.png#400h)

### 存储元扩展和存储阵列扩展

**一个存储元只能存储一位二进制信息，于是对存储元扩展构成存储阵列（也就是行，可以是8个、16个存储元等），也就是我们通常看到的，如下图，再将存储阵列扩展，就构成了存储体**

![image-20250602155023659](https://img.tynote.cn/img/typora/20250602155024367.png#400h)

#### 1️⃣存储元扩展

![image-20250602155316556](https://img.tynote.cn/img/typora/20250602155317352.png#400h)

![image-20250602155415664](https://img.tynote.cn/img/typora/20250602155416638.png#400h)

![image-20250602155545023](https://img.tynote.cn/img/typora/20250602155545945.png#400h)

![image-20250602155635062](https://img.tynote.cn/img/typora/20250602155635843.png#400h)

**请注意，每个存储元都有D和$\overline{D}$两条位线，并且每一列的所有存储元都共享我们之前解释过的不算入单个存储元的那两个MOS管，而这两个MOS管由这一列的列选通线控制**

​	**将每一列存储元并联后的位线D经过该列相应的MOS管再并联在一起，送入I/O电路；同理，将每一列存储元并联后的位线$\overline{D}$经过该列相应的MOS管再并联在一起，送入I/O电路，这样我们就完成了存储元的扩展**

![image-20250602160153565](https://img.tynote.cn/img/typora/20250602160154332.png#400h)

![image-20250602160639434](https://img.tynote.cn/img/typora/20250602160640430.png#400h)

- 举例说明

<video src="https://img.tynote.cn/img/typora/20250602161030292.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250602161124592](https://img.tynote.cn/img/typora/20250602161125411.png#400h)

#### 2️⃣存储阵列扩展

![image-20250602161610620](https://img.tynote.cn/img/typora/20250602161611435.png#400h)

### 存储器结构及芯片实例

![image-20250602174424381](https://img.tynote.cn/img/typora/20250602174425244.png#400h)

#### 1️⃣存储器结构

![image-20250602174556042](https://img.tynote.cn/img/typora/20250602174557086.png#400h)

![image-20250602174850887](https://img.tynote.cn/img/typora/20250602174852016.png#400h)

![image-20250602175134211](https://img.tynote.cn/img/typora/20250602175135370.png#400h)

![image-20250602175337101](https://img.tynote.cn/img/typora/20250602175337826.png#400h)

**I/O电路处在存储单元和数据总线之间，读出时，4对位信号$D_{xy}、\overline{D_{xy}}$经I/O电路中各自的差分放大器放大后，根据电流方向的不同输出4位二进制数据；写入时数据总线上的数据送入I/O电路，再写入到相应的存储单元。上述译码器、驱动器、I/O电路需要在控制电路的控制下进行工作，控制电路包含有两条非常重要的控制线，一条是片选线CS，另一条是写使能控制线WE，它们都是低电平有效，因此图中它们的英文缩写词上都有上划线，表示低电平有效。由于一块SRAM存储器芯片的容量有限，可能满足不了一个大容量存储器的需求，这时可以使用多片SRAM存储器芯片进行扩展，对这样扩展而来的存储器进行访问时，并不是所有的SRAM存储器芯片都会同时工作，通过片选信号$\overline{CS}$可以很好的解决SRAM存储器芯片的选择问题，只有片选信号$\overline{CS}$有效的SRAM存储器芯片才能被访问。对存储器的读或写操作，需要由写使能线WE进行控制，当WE为有效电平，也就是低电平时，表明要对存储器进行写操作；当WE为无效电平，也就是高电平时表明可以从存储器读取信息。**

#### 2️⃣存储器芯片实例

![image-20250602185157292](https://img.tynote.cn/img/typora/20250602185158021.png#400h)

**这些三态门的作用是控制I/O1~I/O4这4条数据线的传输方向**

- 举例说明

<video src="https://img.tynote.cn/img/typora/20250602190150840.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250602190441660](https://img.tynote.cn/img/typora/20250602190442826.png#400h)

![image-20250602190713786](https://img.tynote.cn/img/typora/20250602190714821.png#400h)

![image-20250602190745606](https://img.tynote.cn/img/typora/20250602190746681.png#400h)

**通过芯片的真值表，我们就能掌握新的使用方法，也就是地址线、数据线、控制线之间的逻辑操作关系**

![image-20250602190859978](https://img.tynote.cn/img/typora/20250602190900965.png#400h)

![image-20250602190918531](https://img.tynote.cn/img/typora/20250602190919456.png#400h)

![image-20250602190943485](https://img.tynote.cn/img/typora/20250602190944333.png#400h)

![image-20250602191131251](https://img.tynote.cn/img/typora/20250602191132321.png#400h)

![image-20250602191158196](https://img.tynote.cn/img/typora/20250602191159018.png#400h)

#### 3️⃣习题

![image-20250602191723628](https://img.tynote.cn/img/typora/20250602191724451.png#400h)

## 动态随机存取存储器DRAM

### 存储元及其扩展

#### 1️⃣存储元

![image-20250602192001138](https://img.tynote.cn/img/typora/20250602192002157.png#400h)

![image-20250602192029549](https://img.tynote.cn/img/typora/20250602192030583.png#400h)

![image-20250602193052183](https://img.tynote.cn/img/typora/20250602193052963.png#400h)

![image-20250602192811877](https://img.tynote.cn/img/typora/20250602192812692.png#400h)

![image-20250602193138040](https://img.tynote.cn/img/typora/20250602193138867.png#400h)

**若现在MOS管被打开，而源极此时没有高电平输入来驱动电荷保持在电容上，则电容会通过MOS管放电，直到电容上的电荷完全放没**

![image-20250602193330226](https://img.tynote.cn/img/typora/20250602193331017.png#400h)

![image-20250602193303720](https://img.tynote.cn/img/typora/20250602193304683.png#400h)

- 完整过程

<video src="https://img.tynote.cn/img/typora/20250602193638846.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250602193434159](https://img.tynote.cn/img/typora/20250602193435074.png#400h)

#### 2️⃣存储元扩展

​	**将16个DRAM存储元排列成4行4列的二维阵列形式，每一行的所有存储元的MOS管的栅极用一条行线连起来，每一列的所有存储元的MOS管的源极用一条列线连接起来**

![image-20250602200426513](https://img.tynote.cn/img/typora/20250602200427368.png#400h)

![image-20250602200541434](https://img.tynote.cn/img/typora/20250602200542733.png#400h)

![image-20250602204021117](https://img.tynote.cn/img/typora/20250602204021956.png#400h)

![image-20250602204153305](https://img.tynote.cn/img/typora/20250602204154169.png#400h)

​	**完成数据的读操作后，撤除行选通信号，关闭灵敏读出/恢复放大器，至此，读操作完成**

![image-20250602204949724](https://img.tynote.cn/img/typora/20250602204950581.png#400h)

- 完整过程

<video src="https://img.tynote.cn/img/typora/20250602205207456.mp4" width="720" height="405" preload="none"  controls>            </video>

**注意，由于DRAM存储阵列比SRAM存储阵列的工作原理复杂，为了简单起见，我们将存储元的原本两条位线D和$\overline{D}$合并为了一条，并简称为列线，而每一列所有存储元所共享的两个MOS管以及控制这两个MOS管的列选通线也未画出。另外，通过本例可以发现，DRAM的行选通信号和列选通信号并不是同时给出的，因此，DRAM存储器通常将行地址线和列地址线复用，以减少地址引脚数目。**

![image-20250602205332355](https://img.tynote.cn/img/typora/20250602205333223.png#400h)

#### 3️⃣DRAM和SRAM的对比

![image-20250602205450356](https://img.tynote.cn/img/typora/20250602205451216.png#400h)

### 动态刷新

![image-20250603093425734](https://img.tynote.cn/img/typora/20250603093426758.png#400h)

![image-20250603093449823](https://img.tynote.cn/img/typora/20250603093450598.png#400h)

#### 1️⃣动态刷新的概念

![image-20250603093632090](https://img.tynote.cn/img/typora/20250603093632927.png#400h)

#### 2️⃣刷新方式

![image-20250603093736528](https://img.tynote.cn/img/typora/20250603093737598.png#400h)

![image-20250603094126189](https://img.tynote.cn/img/typora/20250603094127031.png#400h)

![image-20250603095242251](https://img.tynote.cn/img/typora/20250603095243173.png#400h)

![image-20250603095339437](https://img.tynote.cn/img/typora/20250603095340267.png#400h)

#### 3️⃣习题

![image-20250603095414058](https://img.tynote.cn/img/typora/20250603095415125.png#400h)

### 存储器芯片实例和DRAM发展

#### 1️⃣存储器芯片实例

​	**DRAM芯片一般采用地址复用技术，也就是行地址线和列地址线分时复用一组地址线，对于容量较大的DRAM存储器芯片，地址复用技术可以有效的减少地址引脚的数量，对于本例，7条行地址线和7条列地址线进行地址复用，因此地址引脚数为7，为了实现地址复用，需要分别由行地址选通信号RAS和列地址选通信号CAS先后将7位地址A0~A6分别锁存到行地址锁存器和列地址锁存器中，由时钟发生器提供相应的定时。另外，7条行地址线也可作为刷新地址，用于刷新时的地址计数，逐行刷新，该DRAM存储器芯片，每次只能输出或输入1位二进制信息，数据的输入和输出是分开的，并且可以锁存。数据的输出由列选通信号CAS来控制，而数据的输入由写使能信号WE和列地址选通信号CAS来共同控制。注意，行地址选通信号RAS，列地址选通信号CAS以及写使能信号WE都是低电平有效，因此，它们各自的英文缩写词带有上划线，另外，图中出现的En是Enable的缩写，表示使能，高电平有效。对比上节课的1K×4位的SRAM存储器芯片2114，该DRAM存储器芯片2116并没有提供片选信号CS，通常可由行地址选通信号RAS和列地址选通信号CAS代替**

![image-20250603202020505](https://img.tynote.cn/img/typora/20250603202021394.png#400h)

![image-20250603202614849](https://img.tynote.cn/img/typora/20250603202615986.png#400h)

![image-20250603202826846](https://img.tynote.cn/img/typora/20250603202827671.png#400h)

#### 2️⃣DRAM的发展

![image-20250603203222521](https://img.tynote.cn/img/typora/20250603203223946.png#400h)

​	**典型的SDRAM读操作时序如图所示，我们用虚线画出每个时钟周期，以方便后续说明，SDRAM进行读操作时，首先给出行地址和行地址选通信号RAS，该信号为低有效，为了简单起见，在我们的描述中，当前不相关的信号应该处于无效电平，就不特意说明了。在遇到时钟周期的上升沿时，开始进行行地址锁存，在该时钟周期内完成行地址锁存后，还要将RAS拉高，使其无效，一小段延迟后给出列地址和列地址选通信号CAS，该信号为低有效，在遇到时钟周期上升沿时，开始进行列地址锁存，并选中具体的的存储单元，在该时钟周期内完成列地址锁存并选中具体的存储单元后，还要将CAS拉高，使其无效，经过一小段延迟后，遇到时钟周期的上升沿即可输出第一个数据，后续每个时钟周期都会输出一个数据，直至突发长度的数据输出完毕。目前的内存条都是使用DDR4或者DDR5 SDRAM，它们是SDRAM的改进，在介绍SDRAM的时序参数时，原本应该使用一片具体的SDRAM存储器芯片举例，为了避免陌生和枯燥，我们使用了大家都熟悉的DDR4 SDRAM进行了举例**

![image-20250604104129958](https://img.tynote.cn/img/typora/20250604104130829.png#400h)

![image-20250604103422495](https://img.tynote.cn/img/typora/20250604103423770.png#400h)



- SDRAM读操作时序

<video src="https://img.tynote.cn/img/typora/20250604102057805.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250604103642557](https://img.tynote.cn/img/typora/20250604103643599.png#400h)

![image-20250604103951585](https://img.tynote.cn/img/typora/20250604103952846.png#400h)

![image-20250604104010146](https://img.tynote.cn/img/typora/20250604104011129.png#400h)

## 只读存储器ROM简介

### 1️⃣只读存储器ROM

![image-20250604104241478](https://img.tynote.cn/img/typora/20250604104242620.png#400h)

![image-20250604104332770](https://img.tynote.cn/img/typora/20250604104333969.png#400h)

![image-20250604104532660](https://img.tynote.cn/img/typora/20250604104533513.png#400h)

**需要说明的是，闪存分为NOR型和NAND型，NOR型闪存以其快速读取和随机访问能力，适用于嵌入式系统中的程序存储，例如目前主流PC板使用NOR型闪存来存储图形化BIOS，而NAND型闪存以其高容量和成本效益，适用于大容量数据存储，例如固态硬盘和U盘。注意，上述只读存储器，除掩膜式只读存储器MROM外，都是可以进行写入的，而只读存储器ROM通常指的是非易失性存储器，即那些在断电后仍能保持数据的存储器，虽然字面上的只读容易使人误解为只能读取不能写入，但实际上，许多类型的ROM确实允许写入操作，只是这些写入操作通常由一定的限制条件和次数**

### 2️⃣PC用到的半导体存储器

![image-20250604105649111](https://img.tynote.cn/img/typora/20250604105650078.png#400h)

![image-20250604105609649](https://img.tynote.cn/img/typora/20250604105610790.png#400h)

### 3️⃣习题

![image-20250604105732732](https://img.tynote.cn/img/typora/20250604105733564.png#400h)

![image-20250604105828400](https://img.tynote.cn/img/typora/20250604105829262.png#400h)

## 主存的扩展及其与CPU的连接

### 位扩展

![image-20250604162322336](https://img.tynote.cn/img/typora/20250604162323148.png#400h)

![image-20250604162442851](https://img.tynote.cn/img/typora/20250604162443695.png#400h)

- CPU对主存的访问过程
  - 初始状态

​	**初始状态下，CPU的存储器请求控制器引脚MREQ输出无效电平，也就是高电平，用1表示，各存储芯片的片选信号CS收到该无效电平，因此不被选中工作，进而各自的1位数据线输出为高阻态，可认为未与CPU的数据总线连接。CPU的读/写控制引脚R/W输出高电平，各存储芯片的写使能引脚WE收到该高电平，由于各存储芯片此时都未被选中工作，因此不会理会该信号，而CPU的地址总线和数据总线的输出未知，或者说可以不用关心。**

![image-20250604164115340](https://img.tynote.cn/img/typora/20250604164116187.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604163215026.mp4" width="720" height="405" preload="none"  controls>            </video>



- 在初始状态下CPU进行读操作

​	**假设在初始状态下，CPU要进行读操作，CPU的18条地址总线送出18位的地址，各存储芯片都会通过各自的18个地址引脚收到这18位的地址，因此，当各存储芯片被同时选中工作时，其各自内部该地址所对应的存储单元被同时选中，之后CPU的存储器请求控制引脚MREQ输出低电平，各存储芯片的片选信号CS收到该有效电平，因此都被选中工作，由于此时各存储芯片的写使能引脚WE上的信号是之前由CPU的读/写控制引脚R/W输出的高电平，因此，各存储芯片将被选中的存储单元存储的1位数据通过各自的1位数据线，传送到CPU的32位数据总线中相应的数据线，之后，CPU通过32位数据总线读取32位数据。**

![image-20250604164141325](https://img.tynote.cn/img/typora/20250604164142235.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604163931577.mp4" width="720" height="405" preload="none"  controls>            </video>

- 在初始状态下CPU进行写操作

​	**在初始状态下，CPU进行写操作的过程，CPU的32位数据总线送出32位待写入主存的数据，之后CPU的18条地址总线送出18位的地址，各存储芯片都会通过各自的18个地址引脚收到这18位的地址，因此，当各存储芯片被同时选中工作时，其各自内部该地址所对应的存储单元被同时选中，之后CPU的读/写控制引脚R/W输出低电平，各存储芯片的写使能引脚WE收到该低电平，由于各存储芯片此时都未被选中工作，因此不会理会该信号，之后CPU的存储器请求控制引脚MREQ输出低电平，各存储芯片的片选信号引脚CS收到该有效电平，因此都被选中工作，，由于此时各存储芯片的写使能引脚WE上的信号是之前由CPU的读/写控制引脚R/W输出的低电平，因此，各存储芯片通过各自的1位数据线从CPU的32位数据总线中相应的数据线上读入1位数据，并写入所选中的存储单元**



![image-20250604165054199](https://img.tynote.cn/img/typora/20250604165055111.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604165154982.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250604165309095](https://img.tynote.cn/img/typora/20250604165309989.png#400h)

### 字扩展

![image-20250604183920005](https://img.tynote.cn/img/typora/20250604183920954.png#400h)

![image-20250604184227102](https://img.tynote.cn/img/typora/20250604184228035.png#400h)

**CPU的A18~A20地址引脚连接到3-8译码器的输入引脚，3-8译码器的8个译码输出引脚分别连接到相应存储芯片的片选引脚CS，将CPU的存储器请求控制引脚MREQ连接到3-8译码器的输出使能引脚OE，CPU的读/写控制引脚R/W连接到每一片存储芯片的写使能引脚WE。所以A18 ~ A20与3-8译码器负责选哪一片存储芯片，A0 ~ A17负责选择存储芯片内的存储单元地址**

- CPU对主存的访问过程
  - 初始状态

​	**初始状态下，CPU的存储器请求控制引脚MREQ输出无效电平，也就是高电平，用1表示，这会使得3-8译码器的8个译码输出全部都为无效电平，各存储芯片的片选引脚CS收到该无效电平，因此不被选中工作，进而各自的8位数据总线输出为高阻态，可认为未与CPU的数据总线连接，CPU的读/写控制引脚R/W输出高电平，各存储芯片的写使能引脚WE收到该高电平，由于各存储芯片此时都未被选中工作，因此不会理会该信号，而CPU的地址总线和数据总线的输出未知，或者说不用关心**

![image-20250604191052325](https://img.tynote.cn/img/typora/20250604191053210.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604190701196.mp4" width="720" height="405" preload="none"  controls>            </video>

- 在初始状态下CPU进行读操作

​	**假设CPU要进行读操作，CPU的21条地址总线送出21位的地址，其中，各存储芯片都会通过各自的18个地址引脚收到这21位地址的低18位，而3-8译码器的3个译码输入引脚收到高3位地址，假设这个高3位地址为000，之后CPU的存储器请求控制引脚MREQ输出低电平，3-8译码器的输出使能引脚OE收到该低电平时，将3位译码输入译码成8位译码输出，具体为Y0位输出有效信号，也就是低电平 ，而Y1~Y7仍保持输出无效信号，也就是高电平，这样，8片存储芯片中，只有片选信号引脚CS收到有效电平的该存储芯片被选中工作，而该存储芯片通过自身18个地址引脚收到的18位地址所对应的存储芯片内部的那个存储单元被选中，由于此时该存储芯片的写使能引脚WE上的信号是之前由CPU的读/写控制引脚R/W输出的高电平，因此，该存储芯片将被选中的存储单元中存储的8位数据，通过自己的8位数据总线传送到CPU的8位数据总线，由于此时剩余7片存储芯片都未被选中工作，因此它们各自的8位数据总线处于高阻态，不会对CPU的8位数据总线产生影响，之后CPU通过8位数据总线读取8位数据**

![image-20250604192156862](https://img.tynote.cn/img/typora/20250604192157732.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604192245488.mp4" width="720" height="405" preload="none"  controls>            </video>

- 在初始状态下CPU进行写操作

​	**假设CPU要进行写操作，CPU的8位数据总线送出8位待写入主存的数据，CPU的21条地址总线送出21位的地址，其中，各存储芯片都会通过各自的18个地址引脚，收到这21位地址的低18位，而3-8译码器的3个译码输入引脚收到高3位地址，假设这个高3位地址为111，之后，CPU的读/写控制引脚R/W输出低电平，各存储芯片的写使能引脚WE收到该低电平，由于各存储芯片此时都未被选中工作，因此不会理会该信号，之后CPU的存储器请求控制引脚MREQ输出低电平，3-8译码器的输出使能引脚OE收到该低电平时，将3位译码输入译码成8位译码输出，具体为Y7输出有效信号，也就是低电平，，而Y0 ~ Y6仍保持输出无效信号，也就是高电平，这样，8片存储芯片中，只有片选引脚CS收到有效电平的该存储芯片被选中工作，而该存储芯片通过自身18个地址引脚收到的18位地址所对应的存储芯片内部的那个存储单元被选中，由于此时该存储芯片的写使能引脚WE上的信号，是之前由CPU的读/写控制引脚R/W输出的低电平，因此，该存储芯片通过自身的8位数据总线从CPU的8位数据总线获取到8位数据并写入所选中的存储单元**

![image-20250604193258794](https://img.tynote.cn/img/typora/20250604193259683.png#400h)

<video src="https://img.tynote.cn/img/typora/20250604193335346.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250604193615300](https://img.tynote.cn/img/typora/20250604193616468.png#400h)

![image-20250604193811756](https://img.tynote.cn/img/typora/20250604193812809.png#400h)

### 字位同时扩展

![image-20250604211025493](https://img.tynote.cn/img/typora/20250604211026732.png#400h)

![image-20250604211107467](https://img.tynote.cn/img/typora/20250604211108365.png#400h)

**CPU对主存的读操作和写操作过程与字扩展方式下 CPU对主存的读操作和写操作过程是一样的**

### 习题课

![image-20250604211315450](https://img.tynote.cn/img/typora/20250604211316578.png#400h)

**需要说明的是，CPU中存储器地址寄存器MAR的位数与地址总线的位宽是相等的，决定了可寻址空间的大小；而存储器数据寄存器MAR的宽与数据总线的位宽是相等的，因此我们可以画出CPU与主存连接的原理图**

![image-20250604211653166](https://img.tynote.cn/img/typora/20250604211654273.png#400h)

![image-20250604212426876](https://img.tynote.cn/img/typora/20250604212428361.png#400h)

![image-20250604213245152](https://img.tynote.cn/img/typora/20250604213246464.png#400h)

![image-20250604213629981](https://img.tynote.cn/img/typora/20250604213631006.png#400h)

![image-20250604213918497](https://img.tynote.cn/img/typora/20250604213919306.png#400h)

![image-20250604213952556](https://img.tynote.cn/img/typora/20250604213953407.png#400h)

![image-20250604214424070](https://img.tynote.cn/img/typora/20250604214425306.png#400h)

![image-20250604214445465](https://img.tynote.cn/img/typora/20250604214446417.png#400h)

## 主存系统的优化

![image-20250604214641317](https://img.tynote.cn/img/typora/20250604214642195.png#400h)

### 双端口存储器

​	**双端口存储器是指同一个存储器具有两个相互独立的的存储器端口，每个端口都具有自己独立的数据总线、地址总线、控制总线，因此，每个窗口可以独立的进行读写操作，为了便于理解，我们假设有一个双核的CPU，每个核通过该存储器的一个端口对其进行访问。假设两个核同时访问该存储器，当他们各自给出的要访问的存储单元的地址不相同时，二者可以同时进行读写操作，也就是并行读写；当他们各自给出的要访问的存储单元的地址相同时，则二者会产生读写冲突，如何解决冲突问题呢？不难想到，可以为每个端口添加一个忙标志，，记为BUSY,带有上划线表示低电平有效,通过这种方法，就可解决读写冲突问题，当冲突发生时，由判断逻辑决定哪个端口优先进行读写操作，而将另一个端口的BUSY信号输出低电平，以延迟该端口对存储器的访问，高优先端口读写操作完成后，被延迟端口的BUSY信号输出高电平后，该端口就可以对存储器进行访问了。**

![image-20250604215230749](https://img.tynote.cn/img/typora/20250604215231575.png#400h)

![image-20250604215503926](https://img.tynote.cn/img/typora/20250604215504789.png#400h)

![image-20250604214832842](https://img.tynote.cn/img/typora/20250604214833733.png#400h)

### 单体多字存储器

![image-20250604220203115](https://img.tynote.cn/img/typora/20250604220204283.png#400h)

​	**将内存控制器中的片选引脚分别连接到两个存储模块各自的片选引脚，将内存控制器的地址总线的全部引脚分别连接到两个存储模块各自的地址总线引脚，假设内存控制器的数据总线为128位，而两个存储模块各自的64位数据总线分别连接到内存控制器的128位数据总线中相应的64位，这样就完成了单体多字存储器的构建**

![image-20250604220929489](https://img.tynote.cn/img/typora/20250604220930409.png#400h)

**例如，在上图这块PC主板上有4个内存插槽，根据其说明书可知，将两条同样规格的内存条分别插入2号和4号槽位时，即可构建双通道内存**

![image-20250604221123360](https://img.tynote.cn/img/typora/20250604221124276.png#400h)

**上述的双通道内存技术称为联动模式**

![image-20250604220453394](https://img.tynote.cn/img/typora/20250604220454264.png#400h)

**上图右侧为双通道内存技术非联动模式，这种模式要求内存控制器具有两套独立的端口，分别连接两个内存条；两个内存条也可并发工作，但它们的地址、读写命令不需要同步，因此两个内存条只需要频率相同即可**

### 多体交叉存储器

#### 1️⃣高位多体交叉

![image-20250605095541922](https://img.tynote.cn/img/typora/20250605095549745.png#400h)

![image-20250605095905208](https://img.tynote.cn/img/typora/20250605095907229.png#400h)

**不难发现，主存地址依次分配给了同一存储模块的不同存储单元，因此，高位多体交叉是顺序编址模式**

#### 2️⃣低位多体交叉

​	**只要将高位多体交叉当中主存地址的模块地址部分和块内地址部分颠倒一下顺序，则高位多体交叉就转换成了低位多体交叉，换句话说，我们用主存地址的高位给各存储模块的 存储单元进行编址，而主存地址的低位给各存储模块编号，这样，我们就将主存地址依次分配给了不同存储模块内相同的存储单元，而不是依次分配给了同一存储模块中连续的存储单元，因此，低位多体交叉又称为交叉编址模式**

![image-20250605101302802](https://img.tynote.cn/img/typora/20250605101303570.png#400h)

![image-20250605101148366](https://img.tynote.cn/img/typora/20250605101149150.png#400h)

**为什么不同时开始呢？比如M0和M1若同时开始，则在第4个τ时，M0和M1会同时进入总线传输周期，进而争用数据总线而产生冲突，因此，访问M1要比访问M0滞后τ这么长的时间，相应的，访问M1的操作比访问M0的操作会滞后τ则会么长的时间结束**

**连续n次流水线存取过程总耗时为T+(nm-1)τ,根据T=m×τ，化简得到总耗时为nT+(m-1)τ**

- 完整流水线方式存取过程

<video src="https://img.tynote.cn/img/typora/20250605102036504.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250605101215524](https://img.tynote.cn/img/typora/20250605101216313.png#400h)

#### 3️⃣习题

![image-20250605103817831](https://img.tynote.cn/img/typora/20250605103818880.png#400h)

![image-20250605104049669](https://img.tynote.cn/img/typora/20250605104050437.png#400h)

![image-20250605104203828](https://img.tynote.cn/img/typora/20250605104204799.png#400h)

![image-20250605104216646](https://img.tynote.cn/img/typora/20250605104217377.png#400h)

![image-20250605105457560](https://img.tynote.cn/img/typora/20250605105458317.png#400h)

![image-20250605105735494](https://img.tynote.cn/img/typora/20250605105736723.png#400h)

![image-20250605105820057](https://img.tynote.cn/img/typora/20250605105821151.png#400h)

## 高速缓冲存储器cache

### cache的相关基本概念

#### 1️⃣cache的作用

![image-20250605110312183](https://img.tynote.cn/img/typora/20250605110313386.png#400h)

#### 2️⃣程序局部性

![image-20250605110723499](https://img.tynote.cn/img/typora/20250605110724442.png#400h)

![image-20250605165631134](https://img.tynote.cn/img/typora/20250605165632066.png#400h)

#### 3️⃣cache系统的性能评价

​	**如图所示，假设CPU要进行数据访问，为了简单起见，我们假设数据访问为读操作，CPU会首先在cache中查找待访问的数据，当然了，这需要通过某种查找机制来实现，如果数据在cache中，则称为数据命中，将命中的数据读取到CPU中即可；**

![image-20250605165751142](https://img.tynote.cn/img/typora/20250605165752147.png#400h)

​	**若CPU在cache中未查找到所要访问的数据，则称为数据缺失，此时，需要将缺失的数据从主存调入cache中才能访问数据**

![image-20250605165809520](https://img.tynote.cn/img/typora/20250605165810632.png#400h)

![image-20250605165932527](https://img.tynote.cn/img/typora/20250605165933714.png#400h)

![image-20250605172655453](https://img.tynote.cn/img/typora/20250605172656348.png#400h)

**数据块过大，替换的时候替换出去的也多，之前经常被使用的也可能会替换出去，所以破坏了时间局部性**

![image-20250605170510375](https://img.tynote.cn/img/typora/20250605170511465.png#400h)

![image-20250605171808513](https://img.tynote.cn/img/typora/20250605171809462.png#400h)

**命中率h的计算表达式，也就是用命中cache的次数$n_c$除以总访问次数，也就是命中cache的次数$n_c$加上未命中情况下，需要从主存中访问信息的次数$n_m$**

**需要说明的是，r值较大，表示命中访问时间$t_c$远小于主存访问时间$t_m$，这意味着cache对性能的提升效果显著，cache的引入大大减少的数据访问的延迟；r值较小，那么cache对性能的提升效果可能就不明显了，因为命中访问时间$t_c$与主存访问时间$t_m$相差无几，当然了，在设计cache系统时，需要综合考虑性能、成本、技术可行性、系统的整体平衡等因素，r值也不能太大，一般为5~10**

### cache的读、写流程



![image-20250605175418189](https://img.tynote.cn/img/typora/20250605175419327.png#400h)

#### 1️⃣cache读操作的基本流程

![image-20250605175553201](https://img.tynote.cn/img/typora/20250605175554230.png#400h)

![image-20250605175614316](https://img.tynote.cn/img/typora/20250605175615483.png#400h)

![image-20250605175709082](https://img.tynote.cn/img/typora/20250605175710259.png#400h)

![image-20250605175754490](https://img.tynote.cn/img/typora/20250605175755653.png#400h)

![image-20250605175808796](https://img.tynote.cn/img/typora/20250605175810122.png#400h)

![image-20250605175916070](https://img.tynote.cn/img/typora/20250605175916961.png#400h)

#### 2️⃣cache写操作的基本流程

- 数据命中的情况下的写操作

![image-20250605180139016](https://img.tynote.cn/img/typora/20250605180139937.png#400h)

![image-20250605180207004](https://img.tynote.cn/img/typora/20250605180208340.png#400h)

![image-20250605180244936](https://img.tynote.cn/img/typora/20250605180245804.png#400h)

- 数据未命中情况下的写操作

  ![image-20250605180438142](https://img.tynote.cn/img/typora/20250605180439308.png#400h)

![image-20250605180702612](https://img.tynote.cn/img/typora/20250605180703579.png#400h)

### 地址映射-直接映射

#### 1️⃣地址映射

![image-20250605201014706](https://img.tynote.cn/img/typora/20250605201016027.png#400h)

![image-20250605201226263](https://img.tynote.cn/img/typora/20250605201227286.png#400h)

![image-20250605201351680](https://img.tynote.cn/img/typora/20250605201352823.png#400h)

![image-20250605202318982](https://img.tynote.cn/img/typora/20250605202319849.png#400h)

**由于本节课介绍的是地址映射的相关知识，因此除特别需要，我们可以简单的认为这些空闲空间 仅用于记录主存数据块地址标记**

![image-20250605202414921](https://img.tynote.cn/img/typora/20250605202415869.png#400h)

#### 2️⃣直接映射(Direct Mapping)

![image-20250605202711864](https://img.tynote.cn/img/typora/20250605202713214.png#400h)

![image-20250605202823356](https://img.tynote.cn/img/typora/20250605202824262.png#400h)

**因此，直接映射又称为模映射**

![image-20250605202905426](https://img.tynote.cn/img/typora/20250605202906666.png#400h)

![image-20250605202959462](https://img.tynote.cn/img/typora/20250605203000298.png#400h)

​	**在主存数据块有了分区号之后，我们就没有必要对主存中的全部数据块进行统一编号，而是对每个分区中的第一个数据块编号为0，后续每个数据块的编号依次加1，知道该分区中的数据块全部编号完成，如图所示，这样各分区中的各个数据块的编号就与cache中cache各行的编号一一对应相等了。这样做，实际上是将原来用于主存中全部数据块统一编号的比特数量减少了一部分。而这部分用于给分区编号**

![image-20250605203619769](https://img.tynote.cn/img/typora/20250605203620707.png#400h)

![image-20250605204109452](https://img.tynote.cn/img/typora/20250605204110576.png#400h)

​	**如下图所示，红色位置为主存中的待访问信息，它属于分区1，因此，它的主存地址的主存分区号部分的取值为1，由于该信息位于分区1中的数据块1中，因此它的主存地址的区内数据块号或称为cache行号或cache行索引部分的值为1，假设该信息在数据块1中的起始位置距离数据块1的起始地址偏移了8个字节，因此它的主存地址的数据块内偏移部分的值为8，这样我们就通过该信息的主存地址精确描述出了该信息在主存中的具体位置。**

​	**通过该信息的主存地址在cache中进行快速查找时，，通过其区内数据块号的取值可以立即定位出或者说索引到该信息所在主存数据块所对应的cache行，然而，通过直接映射规则我们知道，主存中会有多个数据块对应cache中的某个固定行，那么如何判断cache行1中当前保存的主存数据块的副本是否就是待访问信息所在的那个主存数据块呢？通过比较cache行中主存分区号的取值与待访问信息的主存地址中的主存分区号部分的取值是否相等，来判断该cache行中的数据块副本保存的是否就是待访问信息所在的主存数据块，如果相等，则数据命中，如果不相等，则数据缺失。假设在本例的cache行1中，主存分区号的当前值为1，二者相等，表明数据命中，若该cache行中的有效位为1 ，则表明该cache行中的信息有效，于是通过待访问信息的主存地址中的数据块内偏移部分的取值，就可在该cache行的数据块副本中找到待访问信息，进而从快速的cache中读取该信息，而不用在慢速的主存中读取该信息；如果cache未命中，也就是数据缺失或该cache行的有效位为0，表明该cache行中的信息无效，则需要根据待访问信息的主存地址，将主存中该信息所在数据块载入相应cache行，相应的，还需要将该cache行的有效位置1，以及将该擦cache行的主存分区号设置为该信息的主存地址中的主存分区号，同时将信息送入CPU。**

![image-20250605204610262](https://img.tynote.cn/img/typora/20250605204611300.png#400h)

#### 3️⃣直接映射的硬件逻辑实现

​	**如图所示，这是一个包含有4个cache行的直接映射方式的硬件逻辑实现，各cache行中的有效位用英文valid表示，各cache行中的标记字段用英文tag表示，在直接映射方式中，tag实际上就是主存地址中的主存分区号部分，灰色部分是各cache行中用于保存数据块副本的缓冲区，假设各数据块由4个存储字构成，记为W0~W3，1个存储字可由1字节构成，也可由2个、4个或8个字节构成，以此类推，为了描述方便，我们以存储字为单位，而不用字节单位或比特单位，因此主存地址中的数据块内偏移部分以存储字为单位，将数据块内偏移部分用英文offset表示，区内数据块号用英文index表示，其值作为行索引译码器的输入端，经过译码器输出相应的cache行选通信号，该信号还连接到所选中cache行相关的两个三态门的各自的控制端，被选通cache行相关的位于这一列（左侧那一列）的那个三态门被控制打开输出，因此，该cache行中的有效位和标记tag会通过三态门输出到比较器，被选通cache行相关的位于这一列（右侧那一列）的那个三态门被控制打开输出，因此该cache行中数据块副本缓冲区的4个字通过三态门输出到字选择器的输入端，若比较器判断被选通cache行的有效位为1，并且该行中的标记tag的值主存地址中的标记tag的值相同，则比较器输出命中信号，该信号同时也会使能字选择器，字选择器根据主存地址中的偏移offset的值选择自身4个输入端中相应的那个输入端进行输出，也就是输出所选中cache行中数据块副本缓冲区中相应的那个字进行输出**

![image-20250718143712206](https://img.tynote.cn/img/typora/20250805124028530.png#400h)

- 访问过程举例

​	**<font color='red'>主存地址0FH</font>**

​	**假设主存分区号由4位二进制数构成，因此，主存空间可划分为$2^4=16$个分区，从分区0~分区15，需要说明的是，在下图中我们并没有画出主存，主要因为屏幕展示空间不够，但这并不影响我们对问题的理解。区内数据块号由2位二进制数构成，因此cache行中包含有$2^2=4$个cache行，从cache行0 ~ cache行3，数据块内偏移offset由两位二进制数构成，因此每个cache行的数据副本缓冲区包含有$2^2=4$个存储字，从存储字W0~W3，将上述主存地址的二进制形式代入硬件逻辑中，0FH为地址的十六进制形式，目的在于方便我们进行访问记录，通过记录几次访问过程的结果，我们最终可以总结出直接映射方式的特点。**

![image-20250605214936455](https://img.tynote.cn/img/typora/20250605214937419.png#400h)

​	**这是第1个待访问信息的主存地址，该主存地址的index部分的取值为11，经过行索引译码器译码后，输出cache行选通信号，高电平为有效信号，用1表示，cache行选通信号还会传送到各三态门的控制端，三态门的控制端也是高电平有效，cache行号为3的cache行被选中，由于该cache行中相应的三态门的控制端为有效信号,因此，该三态门打开输出，这样该cache行中的有效位的值和标记tag的值通过该三态门到达比较器，由于此时有效位的值为0，表示cache行中的信息无效，因此，不用关心标记tag的值，比较器将有效位的值与1进行比较，发现不相同，因此输出无效信号，用0表示，这表明数据未命中，该无效信号还会送入字选择器的使能输出OE端的输入端，尽管被选中cache行中数据块副本缓冲区相关的这个三态门（右侧）的控制端为有效信号，该缓冲区的4个存储字会通过右侧三态门输出到字选择器的相应输入端，并且主存地址的offset部分的取值11会送到字选择器的选择输出控制端，然而由于此时字选择器的输出使能OE输入的是无效信号，因此，字选择器并不会将所选择的存储字W3进行输出，因此第一次访问时，数据缺失，也就是未命中，需要进行数据块载入，将主存中待访问信息所在的数据块载入到cache行中被选通的cache行中的数据块副本缓冲区中，将待访问信息的主存地址中的编辑标记tag的值复制到被选通的cache行的tag中，还要将被选中cache行中的有效位置1，表示该cache行中的信息是有效的，最后，将该cache行中数据块副本缓冲区中的存储字W3送CPU即可**

![image-20250605221121675](https://img.tynote.cn/img/typora/20250605221122602.png#400h)

![image-20250605221047760](https://img.tynote.cn/img/typora/20250605221048742.png#400h)

​	**<font color='red'>主存地址10H</font>**

![image-20250606100731283](https://img.tynote.cn/img/typora/20250606100732161.png#400h)

**需要同主存地址0FH一样，将主存中待访问信息所在的数据块载入到cache行中被选通的cache行中的数据块副本缓冲区中，将待访问信息的主存地址中的编辑标记tag的值复制到被选通的cache行的tag中，还要将被选中cache行中的有效位置1，表示该cache行中的信息是有效的，最后，将该cache行中数据块副本缓冲区中的存储字W0送CPU即可，如下图所示**

![image-20250606101350084](https://img.tynote.cn/img/typora/20250606101350979.png#400h)

​	<font color='red'>**主存地址16H**</font>

​	**主存地址16H的访问过程同上，为数据缺失，需要载入，此处不再赘述，如下图所示**

![image-20250606101549647](https://img.tynote.cn/img/typora/20250606101550568.png#400h)

​	**<font color='red'>主存地址17H</font>**

![image-20250606101711644](https://img.tynote.cn/img/typora/20250606101712622.png#400h)

​	**<font color='red'>主存地址2CH</font>**

![image-20250606101944580](https://img.tynote.cn/img/typora/20250606101945913.png#400h)

​	**这次访问数据缺失，需要从主存中载入相应数据块到选通的cache行，由于该cache行之前存有数据块，因此我们称为替换，替换后，还要将cache行中的标记tag进行相应更新**

![image-20250606102211779](https://img.tynote.cn/img/typora/20250606102213235.png#400h)

​	**通过上述举例可以看出，在cache还有空行的情况下，就可能会出现替换cache行中原有数据块的情况，或者说是出现了冲突，因此，cache利用率不高**

![image-20250606102353901](https://img.tynote.cn/img/typora/20250606102354874.png#400h)

#### 4️⃣直接映射的特点

![image-20250605211705217](https://img.tynote.cn/img/typora/20250605211706303.png#400h)

### 直接映射习题课

#### 1️⃣例题1

![image-20250606103113321](https://img.tynote.cn/img/typora/20250606103114240.png#400h)

![image-20250606103317023](https://img.tynote.cn/img/typora/20250606103318097.png#400h)

#### 2️⃣习题1

![image-20250606104329741](https://img.tynote.cn/img/typora/20250606104330705.png#400h)

![image-20250606104315897](https://img.tynote.cn/img/typora/20250606104317030.png#400h)

#### 3️⃣例题2

**注意，32位计算机中一个字为4个字节，64位计算机中，一个字为8个字节**

![image-20250606112729551](https://img.tynote.cn/img/typora/20250606112730884.png#400h)

​	**要读取主存中0号单元的内容，首先会在cache中进行快速查找，未命中，于是将主存中0号单元所在的数据块载入到cache的第0行，并将该行的有效位置1，表示该行所包含的信息有效，不难看出，之后要读取主存中1~3号单元的内容，在cache中进行快速查找时都会命中，这里用颜色来区分是否命中，红色表示未命中，绿色表示命中；要读取主存中4号单元的内容，首先会在cache中进行快速查找，未命中，于是将主存中4号单元所在的数据块载入到cache的第1行，并将该行的有效位置1，表示该行所包含的信息有效，之后要读取主存中5 ~ 7号单元的内容，在cache中进行快速查找时都会命中，以此类推**

![image-20250606113308551](https://img.tynote.cn/img/typora/20250606113309531.png#400h)

![image-20250606113342044](https://img.tynote.cn/img/typora/20250606113343008.png#400h)

![image-20250606113112014](https://img.tynote.cn/img/typora/20250606113113075.png#400h)

![image-20250606114130348](https://img.tynote.cn/img/typora/20250606114131502.png#400h)

![image-20250606114207451](https://img.tynote.cn/img/typora/20250606114208431.png#400h)

#### 4️⃣习题2

![image-20250606154715628](https://img.tynote.cn/img/typora/20250606154716664.png#400h)

**每执行1次for循环，数组a中相应的元素被访问2次，第一次是读，第二次是加上32之后重新赋值，也就是写，先读后写共2次访问。实际上，由于程序执行前cache为空，所以主存的每个数据块都需要载入cache的相应行中1次，所以250行的每个数据块的第一个元素在读的时候均为未命中，每个元素共读1000次，共250次未命中，而写的时候由于每个元素写是紧随在读后面的，读的时候已经载入到了cache中，所以每个元素写的时候均为命中，即1000次写全命中，所以$缺失率=\frac{250+1000}{1000+1000}=12.5\%$**

**需要说明的是，为了简单起见，我们假设循环变量k在程序编译时被分配在寄存器中，并且数组a从主存的0号单元开始存放，实际上，即使不按以上假设进行分析，结果也不会相差太多，这也是题目最后两个字是“约为”的原因。（如果k在主存中，访问k时就可能把数组a的一部分载入到cache中，如果数组a的首个元素不位于块内的第一个，那么缺失次数可能就不同）**

#### 5️⃣习题3

![image-20250606160151894](https://img.tynote.cn/img/typora/20250606160152876.png#400h)

**要特别注意，题目中的cache行大小为64B，意思是指数据块副本的大小为64B，在王道教材的117页中，定义了cache块长也称为cache行长，而cache块大小对应的就是主存数据块大小**

![image-20250606162744308](https://img.tynote.cn/img/typora/20250606162745267.png#400h)

![image-20250606163725803](https://img.tynote.cn/img/typora/20250606163727082.png#400h)

![image-20250606164140810](https://img.tynote.cn/img/typora/20250606164141844.png#400h)

**注意上图中计算时要向下取整**

![image-20250606164239078](https://img.tynote.cn/img/typora/20250606164240090.png#400h)

![image-20250606165327533](https://img.tynote.cn/img/typora/20250606165328525.png#400h)

![image-20250606165500529](https://img.tynote.cn/img/typora/20250606165501533.png#400h)

![image-20250606170838737](https://img.tynote.cn/img/typora/20250606170839740.png#400h)

​	**在读取数组a的过程中，会出现cache已满，需要进行数据块替换的情况，这种情况下，命中率与之前是一样的**

![image-20250606165703028](https://img.tynote.cn/img/typora/20250606165704077.png#400h)

![image-20250606165844615](https://img.tynote.cn/img/typora/20250606165845801.png#400h)

​	**由于题中给定，数组a是按行存储的，但程序B是按列访问的，这导致接下来B要读取的元素，也就是第1行第0列的元素，并不在cache行号5的这15个元素之中，出现数据缺失，因此又要载入这个待读取元素所在的主存数据块到相应的cache行，而a[1] [0]所在数据块对应的cache行与上一次载入数据块所对应的cache行相同，是同一行，使得该cache行中的主存数据块被替换**

![image-20250606171019805](https://img.tynote.cn/img/typora/20250606171020991.png#400h)

![image-20250606171108213](https://img.tynote.cn/img/typora/20250606171109215.png#400h)

### 全相联映射

#### 1️⃣全相联映射

![image-20250606173143220](https://img.tynote.cn/img/typora/20250606173144401.png#400h)

​	**在全相联映射方式下，在不考虑用于写入策略的脏数据标志位和用于替换策略的淘汰计数等信息的情况下，每个cache行的灰色部分仅用于存放主存数据块地址，要与直接映射方式下存放的主存分区号进行区分**

![image-20250606173336784](https://img.tynote.cn/img/typora/20250606173337904.png#400h)

![image-20250606173722235](https://img.tynote.cn/img/typora/20250606173723417.png#400h)

#### 2️⃣全相联映射的硬件逻辑实现

​	**如图所示，这一个是包含有4个cache行的全相联映射方式的硬件逻辑实现，cache行的有效位valid各自作为并发比较器的输入，同时与1进行比较，各cache行的标记字段tag对应的是主存地址中的主存数据块地址部分，各cache行的tag各自作为并发比较器的输入，同时与主存地址中的主存数据块地质部分进行比较，并发比较器根据比较结果输出相应的cache行选通信号，用于选通某cache行，注意，同一时刻只可能有一路信号为有效信号，即只可能选通一个cache行，各cache行的选通信号还用于控制各cache行自己的三态门，当某个cache行被选通，该cache行的三态门被控制打开，因此，该cache行中的数据块副本缓冲区中的内容，通过三态门传送到字选择器的输入端，需要说明的是，为了简单起见，假设本例中数据块副本缓冲区中可以保存4个存储字，记为W0~W3，1个存储字可由1字节构成，也可由2个、4个或8个字节构成，以此类推，为了描述方便，我们已存储字为单位。并发比较器根据比较结果，不但输出cache选通信号，还会输出命中信号，命中信号除了向外提供通知外，还会对内部字选择器的输出使能OE进行控制，主存地址中的块内偏移部分，用于控制字选择器将自己的哪个数据输入端的信号进行输出，在本例中，字选择器有4个数据输入端，分别用于输入被选通cache行中的数据块副本缓冲区中的4个存储字，因此，主存地址中的块内偏移部分占2位，因为$2^2=4$种组合，每个组合用来指示输出4个存储字中的相应一个。**

![image-20250606180058613](https://img.tynote.cn/img/typora/20250606180059619.png#400h)

![image-20250606180516361](https://img.tynote.cn/img/typora/20250606180517291.png#400h)

- 访问过程举例

​	**<font color='red'>主存地址0FH</font>**

​	**假设这是第1个待访问信息的主存地址，将该主存地址写为二进制形式，低两位为块内偏移部分高6位为主存数据块地址部分，假设cache的初始状态为空，因此各cache行的valid为0，表示各cache行中的信息无效，各cache行有效位的值与1、标记tag的值与主存地址中数据块地址的值通过并发比较器同时进行比较，结果为未命中，这是因为此时各cache行中的有效位的值为0，并发比较器输出比较结果，低电平表示未命中，用0表示，该信号传送到字选择器的输出使能OE端，字选择器被禁止输出，并发比较器的各cache行选通信号输出端都输出无效电平，也就是低电平，这样，不会有cache行被选通，综上所述，对该主存地址中的信息进行访问时，cache未命中，也就是出现数据缺失，需要载入该主存所在的主存数据块到cache中，对于全相联映射方式，可将主存数据块载入到cache中的任何一个空行，假设该主存数据块载入到了cache行0中的数据块副本缓冲区中，则该cache行中标记tag的值需要更新为主存地址中数据块地址部分的值，另外还要将该cache行中的有效位置1，表示该cache行中的信息有效**

![image-20250606180803950](https://img.tynote.cn/img/typora/20250606180804905.png#400h)

​	**<font color='red'>主存地址10H</font>**

​	**访问过程同上，假设假设该主存数据块载入到了cache行1中的数据块副本缓冲区中，此处不再赘述**

![image-20250606201804593](https://img.tynote.cn/img/typora/20250606201805646.png#400h)



​	**<font color='red'>主存地址16H</font>**

​	**访问过程同上，假设假设该主存数据块载入到了cache行2中的数据块副本缓冲区中，此处不再赘述**

![image-20250606212718435](https://img.tynote.cn/img/typora/20250606212719512.png#400h)

​	**<font color='red'>主存地址17H</font>**

​	**将该地址写成二进制形式，各cache行有效位的值与1、标记tag的值与主存地址中数据块地址的值通过并发比较器同时进行比较，结果为命中，这是因为此时第2行cache中的有效位的值为1，并且该cache行中标记tag的值与主存地址中数据块地址的值相同，并发比较器输出结果，高电平表示命中，用1表示，该信号传送到字选择器的输出使能OE端，字选择器被使能输出，并发比较器的各cache行选通信号输出端输出，第2行cache行选通信号为高电平，其余cache行选通信号为低电平，因此只有第2行cache被选通，相应的，该cache行的三态门被控制打开，这样，该cache行中数据块副本缓冲区的4个字会通过三态门传送到字选择器相应的数据输入端，主存地址中块内偏移部分的值，作为字选择器的选择输出控制端的控制信号，11表示选择该数据输入端的信号进行输出，这相当于输出数据块副本缓冲区中的存储字W3，综上所述，本次访问数据命中，进行数据输出。**

![image-20250606213937694](https://img.tynote.cn/img/typora/20250606213938716.png#400h)

​	**<font color='red'>主存地址2CH</font>**

![image-20250606214114474](https://img.tynote.cn/img/typora/20250606214115551.png#400h)

**需要注意的是，本例中所采用的5个主存地址，与我们之前在直接映射方式那节课中举例所采用的主存地址完全相同，对于同样的主存地址2CH,在直接映射方式中，会出现替换cache行中原数据块的情况（尽管还有空的cache行），也就是出现了冲突的情况，而在全相联映射方式中，只要还有空的cache行，就不会出现冲突的情况**

![image-20250606220830346](https://img.tynote.cn/img/typora/20250606220831969.png#400h)

#### 3️⃣全相联映射的特点

![image-20250606221010851](https://img.tynote.cn/img/typora/20250606221012138.png#400h)

#### 4️⃣习题

![image-20250607095001589](https://img.tynote.cn/img/typora/20250607095009809.png#400h)

![image-20250607101037215](https://img.tynote.cn/img/typora/20250607101038249.png#400h)

### 组相联映射

#### 1️⃣组相联映射

![image-20250607101203457](https://img.tynote.cn/img/typora/20250607101204927.png#400h)

![image-20250607101323800](https://img.tynote.cn/img/typora/20250607101325293.png#400h)

![image-20250607101719899](https://img.tynote.cn/img/typora/20250607101720942.png#400h)

***在主存数据块有了分区号之后，我们就没有必要对主存中的全部数据块进行统一编号，而是对每个分区中的第一个数据块编号为0，后续每个数据块的编号依次加1，知道该分区中的数据块全部编号完成，如图所示，这样各分区中的各个数据块的编号就与cache中cache各行的编号一一对应相等了。这样做，实际上是将原来用于主存中全部数据块统一编号的比特数量减少了一部分。而这部分用于给分区编号**

![image-20250607101914420](https://img.tynote.cn/img/typora/20250607101915892.png#400h)

![image-20250607102136140](https://img.tynote.cn/img/typora/20250607102137195.png#400h)

**需要说明的是，上述计算cache总容量时，我们忽略了写入策略的脏数据标志位、用于替换策略的淘汰计数等信息**

![image-20250607102447661](https://img.tynote.cn/img/typora/20250607102448702.png#400h)

![image-20250607102626541](https://img.tynote.cn/img/typora/20250607102627657.png#400h)

#### 2️⃣组相联映射的硬件逻辑实现

![image-20250607112129805](https://img.tynote.cn/img/typora/20250607112131267.png#400h)

**$G_0和G_1决定选哪一个cache组，K_0和K_1决定选cache组内哪一行$**

- 访问过程举例

​	**<font color='red'>主存地址0FH</font>**	

​	**假设本例中，主存地址中的主存分区号部分占5位，因此主存包含有$2^5$个分区，本图中并未画出主存，这并不影响我们分析，区内块号部分，也就是cache组索引index或称cache组号占1位，因此cache包含有$2^1$个组，块内偏移部分占两位，因此各cache行的数据块副本缓冲区中包含有$2^2$个存储字。将该主存地址写成二进制形式，假设cache的初始状态为空，因此各cache行的有效位valid的取值为0，表示各cache行中的信息无效，主存地址中的cache组索引index的值经过组索引译码器进行译码输出，0表示低电平，为无效信号，1表示高电平，为有效信号，译码输出信号还会传送到各cache组相关的三态门控制端，以及行译码信号逻辑的输入端，由于译码信号$G_1$为高电平，因此编号为1的cache组被选中，同时该cache组的三态门被控制打开，这样该cache组内所有cache行中的有效位valid和标记tag会通过三态门传送到2路并发比较器，这些有效位的值与1、标记tag的值与主存地址中主存分区号的值通过并发比较器同时进行比较，结果为未命中，这是因为此时各cache行的有效位valid的值为0，并发比较器输出2路比较结果，0表示不匹配，并发比较器还会输出命中结果，0表示未命中，这是将2路比较结果进行逻辑或得出的，该命中结果的相应信号还会传送到字选择器的输出使能OE端，由于未命中，信号为低电平，因此字选择器被禁止输出，2路并发比较结果$K_0和K_1$与组索引译码器输出的2个组译码信号$G_0和G_1$通过行译码信号逻辑分别进行逻辑与，得到2×2个cache行选通信号$L_0~L_3$，即$L_0=k_0•G_0,L_1=k_1•G_0,L_2=k_0•G_1,L_3=k_1•G_1$，对于本次访问的主存地址，行译码信号逻辑输出如下4个无效的cache行选通信号，这4个信号还会传送到各cache行的三态门的控制端，由于是无效信号因此各三态门被控制关闭，综上所述，对该主存地址中的信息进行访问时，cache未命中，也就是出现数据缺失，需要载入该主存地址所在的主存数据块到之前选中的cache组内，由于组内采用全相联映射方式，因此可将主存数据块载入到该cache组内的任何一个空行，假设该主存数据块载入到了之前所选中cache组内部的这个cache行中的数据块副本缓冲区中（即L2行），则该cache行中标记tag的值需要更新为主存地址中主存分区号部分的值，另外还要将该cache行中的有效位置1，表示该cache行中的信息有效**

![image-20250607120433181](https://img.tynote.cn/img/typora/20250607120434194.png#400h)

![image-20250607120507999](https://img.tynote.cn/img/typora/20250607120509003.png#400h)

​	**为了使答案统一，在载入主存数据块时，按cache行号从小到大的顺序**

​	**<font color='red'>主存地址10H和主存地址16H</font>**

![image-20250607121418086](https://img.tynote.cn/img/typora/20250607121419150.png#400h)

​	**<font color='red'>主存地址17H</font>**

![image-20250607121724715](https://img.tynote.cn/img/typora/20250607121725837.png#400h)

​	**<font color='red'>主存地址2CH</font>**

![image-20250607121815806](https://img.tynote.cn/img/typora/20250607121817237.png#400h)

#### 3️⃣组相联映射的特点

![image-20250607121916413](https://img.tynote.cn/img/typora/20250607121917435.png#400h)

### 地址映射习题课

#### 1️⃣三种映射方式的比较

![image-20250607160034369](https://img.tynote.cn/img/typora/20250607160035594.png#400h)

![image-20250607160128799](https://img.tynote.cn/img/typora/20250607160130267.png#400h)

![image-20250607160507711](https://img.tynote.cn/img/typora/20250607160508803.png#400h)

![image-20250607160801561](https://img.tynote.cn/img/typora/20250607160802723.png#400h)

![image-20250607160826462](https://img.tynote.cn/img/typora/20250607160827508.png#400h)

![image-20250607161623484](https://img.tynote.cn/img/typora/20250607162056217.png#400h)

**尽管直接映射方式和组相联映射方式下的主存地址都包含有主存分区部分，但他们的划分依据是不同的**

#### 2️⃣习题

- 例题1

![image-20250607164602382](https://img.tynote.cn/img/typora/20250607164603518.png#400h)

![image-20250607164653798](https://img.tynote.cn/img/typora/20250607164655015.png#400h)

![image-20250607165003818](https://img.tynote.cn/img/typora/20250607165004984.png#400h)

![image-20250607165018907](https://img.tynote.cn/img/typora/20250607165020232.png#400h)

- 习题1

![image-20250607165930448](https://img.tynote.cn/img/typora/20250607165931528.png#400h)

- 习题2

![image-20250607170524446](https://img.tynote.cn/img/typora/20250607170525478.png#400h)

![image-20250607170709445](https://img.tynote.cn/img/typora/20250607170710593.png#400h)

- 习题3

​	**我们常说的n路并发比较，相当于采用了n个独立的比较器同时进行比较，而比较器的位数是指待比较数据的位宽**

![image-20250607171252815](https://img.tynote.cn/img/typora/20250607171254047.png#400h)

![image-20250607171421269](https://img.tynote.cn/img/typora/20250607171422440.png#400h)

### 替换算法

![image-20250607171708820](https://img.tynote.cn/img/typora/20250607171710027.png#400h)

![image-20250607171902225](https://img.tynote.cn/img/typora/20250607171903257.png#400h)

![image-20250607172057451](https://img.tynote.cn/img/typora/20250607172058757.png#400h)

#### 1️⃣先进先出FIFO算法



​	**注意，以下替换算法举例，除特别说明，均采用全相联映射方式**

​	**英文全称为：First In First Out**

![image-20250607172512940](https://img.tynote.cn/img/typora/20250607172513973.png#400h)

![image-20250607172529572](https://img.tynote.cn/img/typora/20250607172530660.png#400h)

#### 2️⃣最不常用LFU算法

**英文全称为：Least Frequently Used**

![image-20250607173014509](https://img.tynote.cn/img/typora/20250607173015800.png#400h)

​	**接下来进行访问，被访问的cache行的淘汰计数器加1，结果如下图所示**

![image-20250607173142840](https://img.tynote.cn/img/typora/20250607173144097.png#400h)

​	**继续访存，数据缺失，需要载入主存数据块到cache，由于此时cache已满，根据LFU替换算法，淘汰计数器数值最小的cache行中的主存数据块被替换，如下图所示，这是第5次主存数据块载入，此次载入时替换掉了cache行0中原有数据块，另外还要将该行的淘汰计数器的值清零**

![image-20250607173449859](https://img.tynote.cn/img/typora/20250607173450981.png#400h)

​	**当有两个cache行的淘汰计数器的值都是当前最小的，那应该选择哪个cache行进行替换呢，此时可采用之前介绍过的随机替换或者FIFO算法，之后再继续使用LFU算法**

![image-20250607173719391](https://img.tynote.cn/img/typora/20250607173720479.png#400h)

![image-20250607173827642](https://img.tynote.cn/img/typora/20250612110527644.png#400h)

**淘汰计数器从cache上电后就开始记录，但不能严格反映出近期的访问情况，即它只能反映一段时间内总的访问情况，而不能反映近期的访问情况。例如，上图中的两个cache行，A行在cache上电后的1分钟内被多次访问，该行的淘汰计数器的值增加到了10000，而在之后的时间，A行未被访问，B行却被多次访问，30秒时B行的淘汰计数器的值已增加到了6000多，并且之后B行仍会被频繁访问，换句话说，A行在前期被多次访问而后期不被访问，但其在前期已经累计了很大的淘汰计数值，B行前期很少被访问而后期被频繁访问，当出现数据缺失需要进行替换时，根据LFU算法，由于B行的淘汰计数值可能仍小于A行的淘汰计数值，使得B行的主存数据块被替换**

#### 3️⃣近期最少用LRU算法

​	**英文全称为：Least Recently Used**

![image-20250607174845298](https://img.tynote.cn/img/typora/20250607174846418.png#400h)

![image-20250607174929373](https://img.tynote.cn/img/typora/20250607174930652.png#400h)

- 完整过程

<video src="https://img.tynote.cn/img/typora/20250607175830830.mp4" width="720" height="405" preload="none"  controls>            </video>

![image-20250607175041458](https://img.tynote.cn/img/typora/20250607175042695.png#400h)

![image-20250607175126286](https://img.tynote.cn/img/typora/20250607175127525.png#400h)

![image-20250607175246107](https://img.tynote.cn/img/typora/20250607175247157.png#400h)

### 替换算法习题课

![image-20250607175934762](https://img.tynote.cn/img/typora/20250607175936365.png#400h)

#### 1️⃣例题1

![image-20250607180419859](https://img.tynote.cn/img/typora/20250607180421675.png#400h)

![image-20250607180643256](https://img.tynote.cn/img/typora/20250607180644601.png#400h)

​	**可以按列来查看每次访存的情况，例如，是cache命中还是未命中，未命中的情况下，是主存数据载入到空行还是替换掉某个行中的主存数据块，各行的淘汰计数值的变化情况等**

![image-20250607180910736](https://img.tynote.cn/img/typora/20250607180911948.png#400h)

​	**可以发现，从这一次替换开始，反复在同一个cache行进行替换，我们将这种现象称为颠簸或抖动**

![image-20250607181125844](https://img.tynote.cn/img/typora/20250607181127175.png#400h)

![image-20250607181146099](https://img.tynote.cn/img/typora/20250607181147272.png#400h)

![image-20250607181456291](https://img.tynote.cn/img/typora/20250607181457722.png#400h)

![image-20250607181614170](https://img.tynote.cn/img/typora/20250607181615422.png#400h)

![image-20250607181641658](https://img.tynote.cn/img/typora/20250607181642850.png#400h)

#### 2️⃣习题1

![image-20250607195838006](https://img.tynote.cn/img/typora/20250607195839328.png#400h)

#### 3️⃣习题2

![image-20250607200430655](https://img.tynote.cn/img/typora/20250607200431893.png#400h)

![image-20250607200659449](https://img.tynote.cn/img/typora/20250607200700993.png#400h)

​	**然而本题的官方答案是C，这是因为在下图中称为计算机黑皮书的计算机组成原理的相关教材中，还给出了另一种规则，即，对于本题，主存分区0对应组0，主存分区1对应组1，主存分区2对应组0，主存分区3对应组1，以此类推，题目给定主存数据块的大小为1个字，并且主存按字编址，因此我们可写出各主存数据块的地址，然后给出待访问序列所对应的cache组号，如下图所示**

![image-20250607201257025](https://img.tynote.cn/img/typora/20250607201258707.png#400h)

![image-20250607201533332](https://img.tynote.cn/img/typora/20250607201535031.png#400h)

![image-20250607201558332](https://img.tynote.cn/img/typora/20250607201559836.png#400h)

![image-20250607201626300](https://img.tynote.cn/img/typora/20250607201627943.png#400h)

![image-20250607201704026](https://img.tynote.cn/img/typora/20250607201705632.png#400h)

![image-20250607201838324](https://img.tynote.cn/img/typora/20250607201839866.png#400h)

#### 4️⃣习题3

![image-20250607201921355](https://img.tynote.cn/img/typora/20250607201922616.png#400h)

![image-20250607203114008](https://img.tynote.cn/img/typora/20250607203115117.png#400h)

![image-20250607203441652](https://img.tynote.cn/img/typora/20250607203443368.png#400h)

![image-20250607203707662](https://img.tynote.cn/img/typora/20250607203709208.png#400h)

![image-20250607203912435](https://img.tynote.cn/img/typora/20250607203913947.png#400h)

![image-20250607204030181](https://img.tynote.cn/img/typora/20250607204031371.png#400h)

### 写入策略

#### 1️⃣数据命中(写cache命中)的情况

![image-20250607204141442](https://img.tynote.cn/img/typora/20250607204142997.png#400h)

![image-20250607204211043](https://img.tynote.cn/img/typora/20250607204212262.png#400h)

​	**假设此时要向该主存单元写入新数据，首先根据该主存单元的地址在cache中进行快速查找，结果为第0行命中，于是按该主存单元地址中块内偏移部分的值，将待写入的新数据，写入该cache行中数据块副本缓冲区的相应位置，也就是说，当写cache命中时，只将新数据写入相应cache行而不立即写入主存，但这样会导致cache与主存中数据不一致，我们将这种数据称为脏数据。假设一段时间后，该cache行中的数据块需要替换为主存数据块4，则首先要将脏数据写回主存后，才能替换掉该cache行中原有的主存数据块，相应的，该cache行中标记tag的值会被更新为贮存数据块4的地址，在本例中，我们使用特定颜色的小方格来表示脏数据，那么如何让计算机知道所命中行中包含有脏数据呢？只要在各cache行中都添加一个脏数据标志位即可，脏数据标志位值为1，表明该cache行的数据块副本缓冲区中包含有脏数据值为0，则表明没有脏数据**

![image-20250607204734969](https://img.tynote.cn/img/typora/20250607204736432.png#400h)

![image-20250607205042216](https://img.tynote.cn/img/typora/20250607205043940.png#400h)

![image-20250607205118659](https://img.tynote.cn/img/typora/20250607205119962.png#400h)

![image-20250607205130730](https://img.tynote.cn/img/typora/20250607205131911.png#400h)

![image-20250607205650772](https://img.tynote.cn/img/typora/20250607205652204.png#400h)

![image-20250607205703931](https://img.tynote.cn/img/typora/20250607205705455.png#400h)

![image-20250607205721402](https://img.tynote.cn/img/typora/20250607205723009.png#400h)

**替换后，需要将该行的脏数据标志位的值清零，标记tag的值更新为新替换进来的主存数据块的地址**

![image-20250607205846859](https://img.tynote.cn/img/typora/20250607205848102.png#400h)

​	**假设一段时间后，该cache行中的数据块又需要替换**

![image-20250607205917470](https://img.tynote.cn/img/typora/20250607205918703.png#400h)

![image-20250607210215068](https://img.tynote.cn/img/typora/20250607210216694.png#400h)

![image-20250607210326961](https://img.tynote.cn/img/typora/20250607210328352.png#400h)

#### 2️⃣数据缺失(写cache未命中)的情况

![image-20250607210636670](https://img.tynote.cn/img/typora/20250607210638293.png#400h)

#### 3️⃣习题

![image-20250607210906962](https://img.tynote.cn/img/typora/20250607210908900.png#400h)

### cache的分类和应用

![image-20250607211033544](https://img.tynote.cn/img/typora/20250607211034730.png#400h)

#### 1️⃣硬件cache

![image-20250607211118064](https://img.tynote.cn/img/typora/20250607211120696.png#400h)

![image-20250607211152978](https://img.tynote.cn/img/typora/20250607211154342.png#400h)

​	**该多级cache结构分为3级，记为L1 cache，L2 cache，L3 cache，称为一级cache，二级cache，三级cache，每个CPU核包含有两个独立的一级cache，分别是数据cache和指令cache，每个CPU核还包含有一个二级cache，由该核内两个独立的数据cache和指令cache共用，因此称为二级联合cache，在这个多核CPU中还包含有一个三级cache，由所有核共享，因此称为三级联合cache。查阅该CPU的相关信息就可以知道，其片内各级cache的数据区大小、映射方式以及存取时间等信息。通过本例可以看出，越靠近CPU内核的cache，存取速度越快，但容量越小**

![image-20250607212031568](https://img.tynote.cn/img/typora/20250607212033237.png#400h)

#### 2️⃣软件cache

![image-20250607212524451](https://img.tynote.cn/img/typora/20250607212525892.png#400h)

**上图所示，机械硬盘与主存之间的速度、容量、成本都相差巨大，采用buffer cache技术可以优化机械硬盘的访问性能，需要说明的是，机械硬盘内部也集成有硬件cache，以提升读写性能，其容量通常为8MB~512MB，目前，固态硬盘已逐渐替代机械因硬盘称为主流，有些固态硬盘中带有硬件cache，而有些不带有硬件cache**

![image-20250607212543079](https://img.tynote.cn/img/typora/20250607212544845.png#400h)

#### 3️⃣习题

![image-20250607212613106](https://img.tynote.cn/img/typora/20250607212614851.png#400h)

## 虚拟存储器

### 相关概念和基本工作原理

![image-20250607212953809](https://img.tynote.cn/img/typora/20250607212955983.png#400h)

![image-20250607213109288](https://img.tynote.cn/img/typora/20250607213110972.png#400h)

**请注意，虚拟存储技术只是一种技术，而不是一种物理存储器实体，这也是虚拟二字的含义，联想一下计算机网络课程中的虚拟局域网VLAN，他是一种分割广播域的技术，而不是一种新型网络**

![image-20250607213515926](https://img.tynote.cn/img/typora/20250607213517660.png#400h)

### 页式虚拟存储器-概述

![image-20250607213653360](https://img.tynote.cn/img/typora/20250607213654930.png#400h)

![image-20250607213726188](https://img.tynote.cn/img/typora/20250607213727662.png#400h)

![image-20250607213903869](https://img.tynote.cn/img/typora/20250607213905541.png#400h)

![image-20250607213957431](https://img.tynote.cn/img/typora/20250607213959013.png#400h)

![image-20250607214018456](https://img.tynote.cn/img/typora/20250607214020124.png#400h)

![image-20250607214235893](https://img.tynote.cn/img/typora/20250607214237181.png#400h)

### 页式虚拟存储器-地址映射和页表

#### 1️⃣页式虚拟器的地址映射和页表

![image-20250607214731372](https://img.tynote.cn/img/typora/20250607214733264.png#400h)

![image-20250607214840893](https://img.tynote.cn/img/typora/20250612110544618.png#400h)

​	**下面是本例中相关进程的页表，请注意，当某个程序被加载到主存中运行时，我们就称其为进程，换句话说，进程是程序的执行实例，是操作系统进行资源分配和调度的基本单位，在采用虚拟存储技术的系统中，操作系统会为每一个进程创建一个页表，以便将虚拟空间映射到物理地址空间，也就是主存地址空间，页表中的每一行，也就是每一个页表项，包含有效位、脏位、替换控制位、访问权限位、禁止缓存位、存放位置等字段，用于记录每一个虚拟页的相关信息，页表采用虚拟页号作为索引进行访问，当某个页表项的有效位的取值为1时，表明该页表项所对应的虚拟页已从辅存调入主存，如下图所示，相应的，这些页表的项各自的存放位置字段中存放的是物理页号，用于表明其所对应的虚拟页调入了主存中的哪个物理页，若存放位置为null，表明该虚拟页为没有内容的页面，这通常意味着该页还没有被分配物理内存**

![image-20250607220036202](https://img.tynote.cn/img/typora/20250607220038179.png#400h)

![image-20250607220124932](https://img.tynote.cn/img/typora/20250607220126726.png#400h)

![image-20250607220145535](https://img.tynote.cn/img/typora/20250607220147452.png#400h)

![image-20250607220214514](https://img.tynote.cn/img/typora/20250607220215681.png#400h)

**需要注意，存储保护是操作系统中的一项重要功能，它确保不同进程在主存地址中的地址空间互相隔离，防止进程间相互s越界访问，从而保护进程和数据不被非法访问或修改**

![image-20250607220609994](https://img.tynote.cn/img/typora/20250607220611771.png#400h)

![image-20250607220828297](https://img.tynote.cn/img/typora/20250607220830294.png#400h)

![image-20250607221013360](https://img.tynote.cn/img/typora/20250607221014753.png#400h)

![image-20250607221146531](https://img.tynote.cn/img/typora/20250607221148389.png#400h)

#### 2️⃣习题

- 习题1

![image-20250608112956956](https://img.tynote.cn/img/typora/20250608113005151.png#400h)



![image-20250612111628967](https://img.tynote.cn/img/typora/20250612111629994.png#400h)

![image-20250612111649906](https://img.tynote.cn/img/typora/20250612111650842.png#400h)

- 习题2

![image-20250608113330548](https://img.tynote.cn/img/typora/20250608113331545.png#400h)

![image-20250608113629203](https://img.tynote.cn/img/typora/20250608113630232.png#400h)

![image-20250612111254317](https://img.tynote.cn/img/typora/20250612111255329.png#400h)

### 页式虚拟存储器-访问流程

#### 1️⃣页式虚拟存储器的访问流程

![image-20250608113953927](https://img.tynote.cn/img/typora/20250608113955023.png#400h)

![image-20250608114220949](https://img.tynote.cn/img/typora/20250608114222018.png#400h)

**需要说明的是，为了简单起见，我们暂未考虑系统中包含有cache的情况**

![image-20250608114621462](https://img.tynote.cn/img/typora/20250608114622580.png#400h)

#### 2️⃣结合cache的页式虚拟存储器的访问流程

​	**我们可将主存看作是包含有页表内容的若干个数据块以及包含有虚拟页的若干个数据块，我们将它们分别称为页表快、数据块。由于cache会缓存主存中经常访问的数据，因此，与数据块类似，部分页表块也会作为常用的热数据被载入cache中，下面我们就给出结合cache的页式虚拟存储器的访问流程**

![image-20250608115218111](https://img.tynote.cn/img/typora/20250608115219320.png#400h)

![image-20250608115620070](https://img.tynote.cn/img/typora/20250608115621170.png#400h)

**步骤⑦⑧是在数据缺失的情况下才进行**

### 使用快表TLB加速地址转换

#### 1️⃣TLB的相关概念和基本原理

![image-20250608120313116](https://img.tynote.cn/img/typora/20250608120314295.png#400h)

- 全相联方式下

![image-20250612105333181](https://img.tynote.cn/img/typora/20250612105341288.png#400h)

![image-20250608120608590](https://img.tynote.cn/img/typora/20250608120609576.png#400h)

- 组相联方式下

​	**存储器管理单元MMU通过虚拟地址中的TLB组索引可以索引到TLB内的相应组，之后将虚拟地址中的TLB标记分别于该组中的两个页表项各自的标记tag字段进行并发比较，并得到比较结果，将两个比较结果分别与各自相应页表项的有效位的值进行逻辑与，两个与运算的结果作为多路选择器的选择输出控制端，多路选择器的两个数据输入端分别来自两个页表项中的物理页号字段，在TLB命中的情况下，多路选择器的输出就来自该组中被命中的那个页表项中的物理页号，将虚拟地址中的页内偏移部分保持不变，拼接在物理页号后面就构成了物理地址**

![image-20250608121427863](https://img.tynote.cn/img/typora/20250608121429486.png#400h)

#### 2️⃣基于快表TLB的访问过程

​	**为了简单起见，本节课我们将cache/主存系统作为一个整体进行分析，不考虑cache是否命中的情况，而结合cache是否命中的更进一步分析，将在下节课介绍**

![image-20250608122205833](https://img.tynote.cn/img/typora/20250608122207051.png#400h)

**TLB缺失情况下，步骤4，cache/主存系统给MMU返回页表项，若页表项中的有效位的取值为1，则需要更新TLB**

![image-20250608122527913](https://img.tynote.cn/img/typora/20250608122529186.png#400h)

![image-20250612110923236](https://img.tynote.cn/img/typora/20250612110924253.png#400h)

### 基于TLB、cache的访存流程

#### 1️⃣基于TLB、cache的访存流程

![image-20250608155720228](https://img.tynote.cn/img/typora/20250608155721359.png#400h)

![image-20250608160106548](https://img.tynote.cn/img/typora/20250608160107589.png#400h)

**需要说明的是，虚线部分为可选部分，取决于相关的软硬件**

​	**接下来，我们依据这个流程图来填写这个表格，为了方便描述，我们将流程图中的3个条件判断改称为TLB命中、cache命中、页面命中。首先来看第①种情况的可能性，该访存流程中是TLB命中，cache也命中的情况，根据TLB的特点我们知道，TLB命中就意味着页面已经从辅存调入了主存，换句话说，从主存中一定可以获取到页面，因此称为页面命中，总结一下就是，<font color='blue'>TLB命中，则页一定命中</font>，综上所述，TLB命中，页命中，cache命中的情况是有可能的。根据刚总结出的规则，可得出⑥、⑦的情况是不可能的。**

![image-20250608161014987](https://img.tynote.cn/img/typora/20250608161016031.png#400h)

​	**再来看第②种情况的可能性，不难看出这种情况是可能的**

![image-20250608161133204](https://img.tynote.cn/img/typora/20250608161134515.png#400h)

​	**如下图所示，第③种情况也是可能的**

![image-20250608161357554](https://img.tynote.cn/img/typora/20250608161358588.png#400h)

​	**如下图所示，第④种情况也是可能的**

![image-20250608161334759](https://img.tynote.cn/img/typora/20250608161335864.png#400h)

​	**如下图所示，第⑤种情况也是可能的**

![image-20250608161438168](https://img.tynote.cn/img/typora/20250608161439206.png#400h)

​	**如下图所示，不难看出，访问流程不会进行到判断cache是否命中的步骤，因此第⑧种情况是不可能的。**

![image-20250608161632112](https://img.tynote.cn/img/typora/20250608161633199.png#400h)

#### 2️⃣总结

![image-20250608162030930](https://img.tynote.cn/img/typora/20250608162032023.png#400h)

#### 3️⃣习题

- 习题1

![image-20250608165144997](https://img.tynote.cn/img/typora/20250608165146329.png#400h)

- 习题2

![image-20250608165248037](https://img.tynote.cn/img/typora/20250608165249074.png#400h)

![image-20250608165349319](https://img.tynote.cn/img/typora/20250608165350496.png#400h)

- 习题3

![image-20250608165451500](https://img.tynote.cn/img/typora/20250608165452691.png#400h)

### 页式虚拟存储器习题课

#### 1️⃣习题1

![image-20250608165659929](https://img.tynote.cn/img/typora/20250608165701212.png#400h)

- 第1问

![image-20250608171447815](https://img.tynote.cn/img/typora/20250608171601948.png#400h)

- 第2问

![image-20250608171701724](https://img.tynote.cn/img/typora/20250608171702856.png#400h)

- 第3问

![image-20250608171832555](https://img.tynote.cn/img/typora/20250608171833777.png#400h)

![image-20250608172044637](https://img.tynote.cn/img/typora/20250608172045760.png#400h)

- 第4问

![image-20250608172309704](https://img.tynote.cn/img/typora/20250608172310781.png#400h)

​	**第4问解析过程如下**

<video src="https://img.tynote.cn/img/typora/20250608172639917.mp4" width="720" height="405" preload="none"  controls>            </video>

#### 2️⃣习题2

![image-20250608172712804](https://img.tynote.cn/img/typora/20250608172714716.png#400h)

![image-20250608173245056](https://img.tynote.cn/img/typora/20250608173246404.png#400h)

![image-20250608174732829](https://img.tynote.cn/img/typora/20250608174733941.png#400h)

**上述图片中，红色框内部分可能会造成困扰，因为我们之前并没有介绍过二级页表的相关知识，我们介绍的是一级页表，页表是常驻于主存中的，通过设置页表基址寄存器的值，可以切换到相应进程的页表，因此如果页表过大，就会占用太多的主存空间，解决页表过大的方法有很多，可以采用限制大小的一级页表，二级页表或多级页表方式也可以采用哈希方式的倒置页表等方法。从题目所给的这幅图中可以看出，在TLB缺失的情况下，才会在主存中通过页目录来查找页表，然后从页表中获取相应的页表项，而本题并未出现TLB缺失的情况，故不影响解答本题。**

#### 3️⃣习题3

![image-20250608175638264](https://img.tynote.cn/img/typora/20250608175639450.png#400h)

![image-20250608175752930](https://img.tynote.cn/img/typora/20250608175754099.png#400h)

![image-20250608180047481](https://img.tynote.cn/img/typora/20250608180048620.png#400h)

![image-20250608180620927](https://img.tynote.cn/img/typora/20250608180622221.png#400h)

![image-20250608180646102](https://img.tynote.cn/img/typora/20250608180647437.png#400h)

![image-20250608180912495](https://img.tynote.cn/img/typora/20250608180913648.png#400h)

**本题解答完毕，注意，从主存中载入TLB的是用于记录虚拟页相关信息的页表项，而不是虚拟页本身**

# 指令系统

## 指令系统概述

![image-20250618154946072](https://img.tynote.cn/img/typora/20250618154954385.png#400h)

![image-20250618155240161](https://img.tynote.cn/img/typora/20250618155241287.png#400h)

**需要说明的是，对于第(4)条信息，也就是下一条指令的地址， 一般情况下不需要在指令中显式给出，而是隐含在程序计数器PC中，指令按顺序执行时，PC的值会自动加上指令长度来得到下一条指令的地址，当遇到转移指令而不按顺序执行时，需要由指令给出转移到的目的地址**

![image-20250618160504762](https://img.tynote.cn/img/typora/20250618160506053.png#400h)

## 指令格式

### 指令的一般格式和指令字长

#### 1️⃣指令的一般格式

![image-20250618160656523](https://img.tynote.cn/img/typora/20250618160657770.png#400h)

#### 2️⃣指令字长

![image-20250618161104834](https://img.tynote.cn/img/typora/20250618161105970.png#400h)

![image-20250618161225562](https://img.tynote.cn/img/typora/20250618161226670.png#400h)

#### 3️⃣总结

![image-20250618161401429](https://img.tynote.cn/img/typora/20250618161402500.png#400h)

### 指令中的地址码

![image-20250618161505528](https://img.tynote.cn/img/typora/20250618161506846.png#400h)

![image-20250618161519023](https://img.tynote.cn/img/typora/20250618161520075.png#400h)

- 三地址指令

![image-20250618162021375](https://img.tynote.cn/img/typora/20250618162022403.png#400h)

![image-20250618162635839](https://img.tynote.cn/img/typora/20250618162636924.png#400h)

- 二地址指令

![image-20250618162743004](https://img.tynote.cn/img/typora/20250618162744353.png#400h)

![image-20250618163026576](https://img.tynote.cn/img/typora/20250618163028165.png#400h)

- 一地址指令

![image-20250618163111452](https://img.tynote.cn/img/typora/20250618163112781.png#400h)

![image-20250618163306444](https://img.tynote.cn/img/typora/20250618163307338.png#400h)

- 零地址指令

![image-20250618164016642](https://img.tynote.cn/img/typora/20250618164017714.png#400h)

### 指令中的操作码

![image-20250618164106528](https://img.tynote.cn/img/typora/20250618164107849.png#400h)

#### 1️⃣指令中的操作码字段

![image-20250618164211151](https://img.tynote.cn/img/typora/20250618164212213.png#400h)

![image-20250618165231661](https://img.tynote.cn/img/typora/20250618165232699.png#400h)

![image-20250618165331098](https://img.tynote.cn/img/typora/20250618165332408.png#400h)

#### 2️⃣变长操作码的常见实现方法-扩展操作码技术

![image-20250618165455117](https://img.tynote.cn/img/typora/20250618165456142.png#400h)

​	**可以使用扩展操作码技术来实现变长操作码，也就是将地址码地段中的部分地址码作为操作码的一部分，例如，将地址码字段中的地址码A1作为操作码的一部分，共有如下$2^4=16$个状态，这样可以形成二地址指令。现在的问题是，对于本例，每条二地址指令的操作码的高4位，其取值是什么呢？我们给出取值规则，那就是短操作码不能是长操作码的前缀，否则指令译码时无法区分(类似于数据结构中的前缀编码)**

![image-20250618165601962](https://img.tynote.cn/img/typora/20250618165603181.png#400h)

​	**假设我们想给每条二地址指令的操作码的高4位取值为1111，则该取值就不能作为三地址指令的操作码，而是作为二地址指令的操作码的高4位，也可以理解成，从三地址指令的操作码的16个状态中取走4位取值为1111的这个状态，作为二地址指令的操作码的高4位，这样就会减少1条三地址指令，因此本例中的指令系统包含有15条三地址指令，由于二地址指令的操作码的低4位共有$2^4=16$个状态，而高4位只有1个状态，因此可组合出$1×2^4=16$个状态，每个状态后跟2个地址码作为一条二地址指令，因此共有16条二地址指令。当然了，如果我们之前减少的是2条三地址指令，则可以扩展出$2×2^4=32$条二地址指令，以此类推，我们就不再赘述了**

![image-20250618165835111](https://img.tynote.cn/img/typora/20250618165836349.png#400h)

​	**在此基础上，如何扩展出一地址指令呢?那就是将地址码字段中的地址码A3作为操作码的一部分，共有如下$2^4=16$个状态，这样可以形成一地址指令**

![image-20250618171432575](https://img.tynote.cn/img/typora/20250618171433640.png#400h)

​	**同样的问题又来了，对于本例，每条一地址指令的操作码的高8位，其取值是什么呢，我们还是采用同样的取值规则，即短操作码不能是长操作码的前缀，否则指令译码时无法区分。假设我们想给每条一地址指令的操作码的高8位取值为1111 1111，则该取值就不能作为二地址指令的操作码，而是作为一地址指令的操作码的高8位，也可以理解成，从二地址指令的操作码的16个状态中，取走8位取值为1111 1111的这个状态，作为一地址指令的操作码的高8位，这样就会减少1条二地址指令，因此本例中的指令系统，包含有15条二地址指令，由于一地址指令的操作码的低4位共有$2^4=16$个状态，而高8位只有1个状态，因此可组合出$1×2^4=16$个状态，每个状态后跟1个地址码，作为一条一地址指令，因此共有16条一地址指令。当然了，如果我们之前减少的是2条二地址指令，则可以扩展出$2×2^4=32$条一地址指令，以此类推，我们就不再赘述了**

![image-20250618172347264](https://img.tynote.cn/img/typora/20250619161648946.png#400h)

​	**在此基础上，如何扩展出零地址指令呢？原理同上，我们就不再赘述了**

![image-20250618172533415](https://img.tynote.cn/img/typora/20250618172534651.png#400h)

#### 3️⃣例题

![image-20250618173250777](https://img.tynote.cn/img/typora/20250618173252295.png#400h)

![image-20250618173513258](https://img.tynote.cn/img/typora/20250618173514619.png#400h)

![image-20250618173930212](https://img.tynote.cn/img/typora/20250618173931361.png#400h)

![image-20250618180544909](https://img.tynote.cn/img/typora/20250618180546288.png#400h)

![image-20250618180616173](https://img.tynote.cn/img/typora/20250618180617256.png#400h)

## 寻址方式

### 寻址方式概述

![image-20250618181616825](https://img.tynote.cn/img/typora/20250618181617976.png#400h)

​	**需要说明的是，由于指令寻址方式比较简单，一般情况下很少提到，因此当我们提到寻址方式时，除特别说明，往往指的是操作数的寻址方式，这也是我们之前将寻址方式分为上述两大类时，将寻址方式称为广义的寻址方式的原因**

### 指令寻址方式

#### 1️⃣顺序寻址

![image-20250618212640201](https://img.tynote.cn/img/typora/20250618212641410.png#400h)

![image-20250618212652256](https://img.tynote.cn/img/typora/20250618212653422.png#400h)

- 例1

​	**本例给定采用8位指令字长的指令系统，因此每条指令的长度为1字节，占用1个存储单元，下图是某程序包含的指令序列的一部分，它们按序存放在主存中，假设某个时刻，程序计数器PC的值为0x16，它指向指令1所在的存储单元，当指令1的前一条指令执行完成后，就可对指令1取指了，取指完之后PC的值会自动加1，进而指向指令1的下一条指令所在的存储单元**

![image-20250618214023721](https://img.tynote.cn/img/typora/20250618214025219.png#400h)

![image-20250618214038768](https://img.tynote.cn/img/typora/20250618214040381.png#400h)

- 例2

​	**本例给定采用16位指令字长的指令系统，因此每条指令的长度为2字节，占用2个存储单元，下图是某程序包含的指令序列的一部分，它们按序存放在主存中，假设某个时刻，程序计数器PC的值为0x16，它指向指令1所在的两个存储单元的第一个，当指令1的前一条指令执行完成后，就可对指令1取指了，取指完之后PC的值会自动加2，进而指向指令1的下一条指令所在的两个存储单元的第一个**

![image-20250618214137787](https://img.tynote.cn/img/typora/20250618214138980.png#400h)

![image-20250618214253983](https://img.tynote.cn/img/typora/20250618214255747.png#400h)

​	**为了简单起见，对于指令的顺序寻址，通常我们会描述为，每读取一条指令，PC会自动加1，以算出下一条指令的有效地址。这里的1是一条指令字长所占用的存储单元的个数，如上述两个例子所述**

![image-20250618214405724](https://img.tynote.cn/img/typora/20250618214406937.png#400h)

#### 2️⃣习题

![image-20250618214733155](https://img.tynote.cn/img/typora/20250618214734309.png#400h)

#### 3️⃣跳跃寻址

![image-20250618214847540](https://img.tynote.cn/img/typora/20250618214849070.png#400h)

​	**假设某个时刻，程序计数器PC的值为0x16,它指向指令1所在的存储单元，当指令1的前一条指令执行完成后，就可对指令1进行取指了，取指完之后，PC的值会自动加1，进而指向指令1所在的下一条指令所在的存储单元，我们知道，CPU取指完成后会对取到的指令进行译码，译码完成后，CPU就知道了应该进行怎样的操作，于是执行该操作，也就是跳转到主存地址0x18处，这需要将pc的值设置为0x18，当指令执行完成后，PC的值被设置为0x18，进而指向了指令3.本例为了简单起见，为无条件跳转指令**

![image-20250618215113198](https://img.tynote.cn/img/typora/20250618215114483.png#400h)

![image-20250618215436440](https://img.tynote.cn/img/typora/20250618215437638.png#400h)

![image-20250618215558772](https://img.tynote.cn/img/typora/20250618215559906.png#400h)

### 操作数寻址方式

![image-20250618220319947](https://img.tynote.cn/img/typora/20250618220321304.png#400h)

#### 1️⃣立即寻址

![image-20250618220510230](https://img.tynote.cn/img/typora/20250618220511571.png#400h)

#### 2️⃣直接寻址

![image-20250618220710743](https://img.tynote.cn/img/typora/20250618220712062.png#400h)

![image-20250618220733273](https://img.tynote.cn/img/typora/20250618220734427.png#400h)

#### 3️⃣寄存器寻址

![image-20250618221020504](https://img.tynote.cn/img/typora/20250618221021725.png#400h)

![image-20250618221032083](https://img.tynote.cn/img/typora/20250618221033582.png#400h)

![image-20250618221111893](https://img.tynote.cn/img/typora/20250618221113061.png#400h)

#### 4️⃣间接寻址

![image-20250619101834147](https://img.tynote.cn/img/typora/20250619101842448.png#400h)

![image-20250619102126927](https://img.tynote.cn/img/typora/20250619102127827.png#400h)

![image-20250619102442518](https://img.tynote.cn/img/typora/20250619102443446.png#400h)

![image-20250619102547987](https://img.tynote.cn/img/typora/20250619102548978.png#400h)

#### 5️⃣寄存器间接寻址

![image-20250619102917936](https://img.tynote.cn/img/typora/20250619102919061.png#400h)

![image-20250619102932097](https://img.tynote.cn/img/typora/20250619102933200.png#400h)

![image-20250619103028366](https://img.tynote.cn/img/typora/20250619103029785.png#400h)



#### 6️⃣小结1

![image-20250619103242633](https://img.tynote.cn/img/typora/20250619103243741.png#400h)

#### 7️⃣相对寻址

![image-20250619103503642](https://img.tynote.cn/img/typora/20250619103505075.png#400h)

![image-20250619103526040](https://img.tynote.cn/img/typora/20250619103527433.png#400h)

![image-20250619103539319](https://img.tynote.cn/img/typora/20250619103540443.png#400h)

![image-20250619104332975](https://img.tynote.cn/img/typora/20250619104334198.png#400h)

![image-20250619104420196](https://img.tynote.cn/img/typora/20250619104421314.png#400h)

![image-20250619104610036](https://img.tynote.cn/img/typora/20250619104611209.png#400h)

![image-20250619104727061](https://img.tynote.cn/img/typora/20250619104728333.png#400h)

#### 8️⃣变址寻址

![image-20250619105034481](https://img.tynote.cn/img/typora/20250619105035642.png#400h)

![image-20250619105217496](https://img.tynote.cn/img/typora/20250619105218645.png#400h)

#### 9️⃣基址寻址

![image-20250619105704012](https://img.tynote.cn/img/typora/20250619105705227.png#400h)

![image-20250619105856737](https://img.tynote.cn/img/typora/20250619105858073.png#400h)

![image-20250619110248608](https://img.tynote.cn/img/typora/20250619110249797.png#400h)

#### 1️⃣0️⃣堆栈寻址

![image-20250619110528479](https://img.tynote.cn/img/typora/20250619110529976.png#400h)

- 入栈

![image-20250619110753792](https://img.tynote.cn/img/typora/20250619110754927.png#400h)

![image-20250619110828332](https://img.tynote.cn/img/typora/20250619110829523.png#400h)

- 出栈

![image-20250619110927703](https://img.tynote.cn/img/typora/20250619110928906.png#400h)

![image-20250619111034367](https://img.tynote.cn/img/typora/20250619111035849.png#400h)

![image-20250619111047809](https://img.tynote.cn/img/typora/20250619111049246.png#400h)

- 完整过程

![image-20250619111121490](https://img.tynote.cn/img/typora/20250619111122569.png#400h)

#### 1️⃣1️⃣其他寻址

![image-20250619111448125](https://img.tynote.cn/img/typora/20250619111449250.png#400h)

![image-20250619111517143](https://img.tynote.cn/img/typora/20250619111518723.png#400h)

#### 1️⃣2️⃣总结2

![image-20250619111554853](https://img.tynote.cn/img/typora/20250619111555965.png#400h)

### 习题课

####  习题1️⃣

![image-20250619113403342](https://img.tynote.cn/img/typora/20250619113404423.png#400h)

#### 习题2️⃣

![image-20250619113514801](https://img.tynote.cn/img/typora/20250619113516036.png#400h)

#### 习题3️⃣

![image-20250619113931968](https://img.tynote.cn/img/typora/20250619113933054.png#400h)

#### 习题4️⃣

![image-20250619114448094](https://img.tynote.cn/img/typora/20250619114449176.png#400h)

#### 习题5️⃣

![image-20250619114550417](https://img.tynote.cn/img/typora/20250619114551903.png#400h)

![image-20250619114602506](https://img.tynote.cn/img/typora/20250619114603635.png#400h)

#### 习题6️⃣

![image-20250619115255554](https://img.tynote.cn/img/typora/20250619115256700.png#400h)

![image-20250619115333032](https://img.tynote.cn/img/typora/20250619115334175.png#400h)

![image-20250619115350755](https://img.tynote.cn/img/typora/20250619115351915.png#400h)

![image-20250619115413127](https://img.tynote.cn/img/typora/20250619115414660.png#400h)

![image-20250619115434165](https://img.tynote.cn/img/typora/20250619115435666.png#400h)

#### 习题7️⃣

![image-20250619115829602](https://img.tynote.cn/img/typora/20250619115830758.png#400h)

![image-20250619115935354](https://img.tynote.cn/img/typora/20250619115936638.png#400h)

![image-20250619120001529](https://img.tynote.cn/img/typora/20250619120002890.png#400h)

#### 习题8️⃣

![image-20250619120735650](https://img.tynote.cn/img/typora/20250619120736777.png#400h)

![image-20250619121023496](https://img.tynote.cn/img/typora/20250619121024625.png#400h)

![image-20250619121108458](https://img.tynote.cn/img/typora/20250619121109538.png#400h)

#### 习题9️⃣

![image-20250619154831225](https://img.tynote.cn/img/typora/20250619154832384.png#400h)

## 指令的操作类型

#### 1️⃣指令的操作类型



![image-20250619160429009](https://img.tynote.cn/img/typora/20250619160431064.png#400h)

![image-20250619160519683](https://img.tynote.cn/img/typora/20250619160521783.png#400h)

![image-20250621102403724](https://img.tynote.cn/img/typora/20250621102411498.png#400h)

![image-20250619160643843](https://img.tynote.cn/img/typora/20250619160645813.png#400h)

![image-20250619160709094](https://img.tynote.cn/img/typora/20250619160710401.png#400h)

![image-20250619161030052](https://img.tynote.cn/img/typora/20250619161032235.png#400h)

![image-20250619161053066](https://img.tynote.cn/img/typora/20250619161054832.png#400h)

![image-20250619161201844](https://img.tynote.cn/img/typora/20250619161203790.png#400h)

![image-20250619161235859](https://img.tynote.cn/img/typora/20250619161237663.png#400h)

![image-20250619161534107](https://img.tynote.cn/img/typora/20250619161535922.png#400h)

![image-20250619161627280](https://img.tynote.cn/img/typora/20250619161628679.png#400h)

#### 2️⃣习题

- 习题1

![image-20250619162330874](https://img.tynote.cn/img/typora/20250619162332668.png#400h)

- 习题2

![image-20250619162831363](https://img.tynote.cn/img/typora/20250619162833301.png#400h)

![image-20250619162915219](https://img.tynote.cn/img/typora/20250619162916849.png#400h)

![image-20250619163104657](https://img.tynote.cn/img/typora/20250619163106777.png#400h)

![image-20250619163154754](https://img.tynote.cn/img/typora/20250619163156270.png#400h)

**此处有同学会问，CF标志位不是用于无符号标志位的运算吗？可是我们现在进行的是有符号数的运算啊。这个疑问我们稍后会做出解释**

![image-20250619163336599](https://img.tynote.cn/img/typora/20250619163338335.png#400h)

![image-20250619163410861](https://img.tynote.cn/img/typora/20250619163412381.png#400h)

![image-20250619163456275](https://img.tynote.cn/img/typora/20250619163457836.png#400h)

**此处有同学会问，OF标志位不是用于有符号标志位的运算吗？可是我们现在进行的是无符号数的运算啊。接下来我们就对CF标志位和OF标志位的疑问做出解释**

​	**我们在第3章有关串行进位加法器的硬件逻辑实现的那节课中介绍过加法器的硬件实现， 对于硬件实现，它并不知道参与加法运算的操作数是无符号数还是有符号数，换句话说，同一硬件实现，既可用于无符号数的加法运算，也可以用于有符号数的加法运算，那么参与运算的数到底是无符号数还是有符号数呢？又该如何区分呢？这实际上属于软件视角，例如编译器根据汇编指令的类型，或者从程序员的视角来看。了解了上述知识后，我们还进一步引出了同一硬件实现在进行无符号加法运算时，如何判断溢出的方法，在进行有符号数加法运算时，如何判断溢出的方法。**

![image-20250619165421296](https://img.tynote.cn/img/typora/20250619165422811.png#400h)

​	**另外我们还介绍了如何对加法器进行简单改造，使其既可以做加法运算，也可以做减法运算，改造后的硬件，仍然既可用于有符号数的加/减法运算，也可以用于无符号数的加/减法运算，综上所述，对于溢出标志位OF和进位/借位标志位CF，如果从软件角度来看，OF用于表示有符号数运算溢出，CF用于表示无符号数运算产生进位/借位，但从硬件角度看，它并不知道OF用于有符号数，CF用于无符号数，请注意，该图仅给出了溢出标志位OF的产生方法，也就是最高位的进位与次高位的进位进行异或，从软件角度看，这是补码加法运算判断溢出的方法，即最高数值位的进位与符号位的进位相同则表示没有溢出，OF=0，否则表示溢出，OF=1**

![image-20250619170310337](https://img.tynote.cn/img/typora/20250619170311539.png#400h)

#### 3️⃣带有标志位CF/OF的串行进位加法器的硬件逻辑实现

​	**下图给出的是带有溢出标志位OF和进位/借位标志位CF的串行进位加法器的硬件逻辑实现，将该硬件逻辑实现用于有符号数进行加/减法运算时，从软件角度看，最高位为补码的符号位，这是符号位产生的进位，溢出标志位OF就是最高数值位的进位与符号位的进位进行异或的结果，尽管从硬件角度看，除了溢出标志位OF，还会生成进位/借位标志位CF，但从软件角度，我们并不用关心该标志位**

![image-20250619170859585](https://img.tynote.cn/img/typora/20250619170900821.png#400h)

​	**再来看将该硬件逻辑实现用于无符号数加/减法运算的情况，若电路右侧的加/减法选择控制端Sub的输入为0，则表示进行加法运算，该位还会作为向最低位的进位，但这并不会影响加法运算结果，由于Sub输入的是0，这会使得操作数Y的各个位直接通过相应的异或门进行输出，进而可以使得与操作数X的各个位通过相应的1位全加器FA进行加法运算，Sub输入的0作为进位/借位标志位异或门的一个输入，最高位的进位Cn作为该异或门的另一个输入，此时，最高位的Cn通过该异或门直接输出，作为进位/借位标志位CF，若最高位的进位Cn为0，则CF为0，换句话说，做加法时，若最高位的进位Cn为0，表示没有产生进位，也可认为无符号数加法运算没有产生溢出，若最高位的进位Cn为1，则CF为1，换句话说，做加法时，若最高位的进位Cn为1，表示产生了进位，也可认为无符号数加法运算产生了溢出**

![image-20250619172443675](https://img.tynote.cn/img/typora/20250619172444866.png#400h)

​	**若电路右侧的加/减法选择控制端Sub的输入为1，则表示进行减法运算，由于Sub输入的是1，这会使得操作数Y的各个位直接通过相应的异或门进行取反输出，进而可以使得与操作数X的各个位通过相应的1位全加器FA进行加法运算，Sub输入的1还会作为向最低位的进位，这样就利用加法器实现了减法运算。Sub输入的1作为进位/借位标志位异或门的一个输入，最高位的进位Cn作为该异或门的另一个输入，此时，最高位的Cn通过该异或门取反输出，作为进位/借位标志位CF，若最高位的进位Cn为0，则CF为1，换句话说，做减法时，若最高位的进位Cn为0，表示产生了进位，也可认为无符号数减法运算产生了溢出，若最高位的进位Cn为1，则CF为0，换句话说，做减法时，若最高位的进位Cn为1，表示没有产生进位，也可认为无符号数减法运算没有产生溢出，尽管从硬件角度看，除了进位/借位标志位CF，还会生成溢出标志位OF，但从软件角度，我们并不用关心该标志位**

## 复杂指令集计算机CISC和精简指令集计算机RISC

![image-20250619173918203](https://img.tynote.cn/img/typora/20250619173919604.png#400h)

![image-20250619174222002](https://img.tynote.cn/img/typora/20250619174223679.png#400h)

![image-20250619174325024](https://img.tynote.cn/img/typora/20250619174327181.png#400h)

![image-20250619185413405](https://img.tynote.cn/img/typora/20250619185414594.png#400h)

## 习题课

#### 习题1️⃣

![image-20250619202921101](https://img.tynote.cn/img/typora/20250619202922418.png#400h)

![image-20250619203249774](https://img.tynote.cn/img/typora/20250619203251318.png#400h)

![image-20250619203412614](https://img.tynote.cn/img/typora/20250619203413941.png#400h)

![image-20250619203604644](https://img.tynote.cn/img/typora/20250619203606137.png#400h)

![image-20250619203646161](https://img.tynote.cn/img/typora/20250619203647404.png#400h)

![image-20250619205705630](https://img.tynote.cn/img/typora/20250619205706792.png#400h)

![image-20250619210059240](https://img.tynote.cn/img/typora/20250619210100460.png#400h)

#### 习题2️⃣

![image-20250619211131509](https://img.tynote.cn/img/typora/20250619211132722.png#400h)

![image-20250619211614837](https://img.tynote.cn/img/typora/20250619211616045.png#400h)

![image-20250619212244284](https://img.tynote.cn/img/typora/20250619212245505.png#400h)

![image-20250619212134830](https://img.tynote.cn/img/typora/20250619212136001.png#400h)

![image-20250619212313671](https://img.tynote.cn/img/typora/20250619212315000.png#400h)

![image-20250619212428481](https://img.tynote.cn/img/typora/20250619212429656.png#400h)

​	**若条件转移指令的测试条件为真，则转移执行，也就是PC的内容被设置为转移目标地址，进而跳转到转移目标地址处**

![image-20250619212647292](https://img.tynote.cn/img/typora/20250619212648460.png#400h)

![image-20250619212852280](https://img.tynote.cn/img/typora/20250619212853665.png#400h)

![image-20250619213925887](https://img.tynote.cn/img/typora/20250619213927007.png#400h)

![image-20250619214406872](https://img.tynote.cn/img/typora/20250619214408064.png#400h)

![image-20250619214943798](https://img.tynote.cn/img/typora/20250619214945005.png#400h)

![image-20250619215010593](https://img.tynote.cn/img/typora/20250619215012222.png#400h)

​	**可以看到，指令中的C检测位作为左侧第1个与门的一个输入端，因此不难想到，该与门的另一个输入端就是标志寄存器中的进位/借位标志CF，该与门的输出端就是CF与C相与的结果，这样就实现了题目给定的，当指令的C检测位为1时，需要检测标志寄存器的相应标志位CF，此时CF通过该与门输出，以此类推，第二个是标志寄存器中的零标志位ZF，它由指令中的Z检测位决定是否被检测而输出，同理，第三个是标志寄存器中的符号标志位NF，它由指令中的N检测位决定是否被检测而输出。至此，就得到了下面或门的输出，该或门的输出就决定了程序是转移执行还是不转移。从硬件框图可知，该或门的输出，作为多路选择器的选择输出控制端，③号和加法器作为多路选择器的另外两个数据输入端，该或门的结果就决定了将哪一个数据输入端输入的数据进行输出，输出的数据会被送入程序计数器PC，PC的值与2通过加法器进行相加,该输出结果还会作为多路选择器的其中一个数据输入，该或门的输出结果若为0，则会控制多路选择器会将来自加法器的这个数据输入端的数据进行输出，也就是将PC的值加上2得到的顺序执行的地址再送入PC，以便之后载入相邻的下一条指令，这样就实现了题目给定的条件转移指令测试转移条件为假，则顺序执行的操作逻辑；该或门的输出结果若为1，则会控制多路选择器会将来自③号的这个数据输入端的数据进行输出，这样就实现了题目给定的条件转移指令测试转移条件为真，则转移执行的操作逻辑，题目已给定转移执行时计算转移目标地址的表达式，因此可知，部件③的输出就是通过该表达式计算出的转移目标地址，这样，转移目标地址就通过多路选择器输出给程序计数器PC，实现程序的转移执行，而转移目标地址的计算，是通过图中蓝色框中部件实现的**

![image-20250619220025684](https://img.tynote.cn/img/typora/20250619220027257.png#400h)

![image-20250619220601342](https://img.tynote.cn/img/typora/20250619220602564.png#400h)

![image-20250619221024329](https://img.tynote.cn/img/typora/20250619221026028.png#400h)

​	**下图给出了部件③的两个输入，这样，如果部件③是加法器，其输出就是转移目标地址，稍微难想一点的就是，偏移量OFFSET的8位补码需要进行符号扩展，由于题目并未给出相关具体信息，因此我们并不知道扩展出了多少个符号位，但这并不影响我们解题，最后，不难得出，部件②是用来将符号扩展后的OFFSET进行算术左移一位的部件，也就是实现了将符号扩展后的OFFSET乘以2后进行输出，至此本题解析完毕。需要说明的是，我们在解答第2小问时，并未使用上述符号扩展算术左移一位的方法，而采用了更符合人类思维的方法**

![image-20250619221606328](https://img.tynote.cn/img/typora/20250619221607560.png#400h)

#### 习题3️⃣

![image-20250620114647569](https://img.tynote.cn/img/typora/20250620114648518.png#400h)

![image-20250620115202536](https://img.tynote.cn/img/typora/20250620115203483.png#400h)

![image-20250620121117589](https://img.tynote.cn/img/typora/20250620121118549.png#400h)

![image-20250620121203445](https://img.tynote.cn/img/typora/20250620121204386.png#400h)

![image-20250620121328057](https://img.tynote.cn/img/typora/20250620121329025.png#400h)

![image-20250620122041641](https://img.tynote.cn/img/typora/20250620122042974.png#400h)

![image-20250620122121951](https://img.tynote.cn/img/typora/20250620122123284.png#400h)

![image-20250620122153440](https://img.tynote.cn/img/typora/20250620122154927.png#400h)

![image-20250620122429089](https://img.tynote.cn/img/typora/20250620122430569.png#400h)

​	**我们做进一步举例**

![image-20250620122624895](https://img.tynote.cn/img/typora/20250620122626275.png#400h)

![image-20250620122809385](https://img.tynote.cn/img/typora/20250620122810715.png#400h)

![image-20250620122840137](https://img.tynote.cn/img/typora/20250620122841541.png#400h)

![image-20250620122946056](https://img.tynote.cn/img/typora/20250620122947174.png#400h)

#### 习题4️⃣

![image-20250620160339173](https://img.tynote.cn/img/typora/20250620160340635.png#400h)

![image-20250620160756307](https://img.tynote.cn/img/typora/20250620160757450.png#400h)

![image-20250620160859961](https://img.tynote.cn/img/typora/20250620160900910.png#400h)

![image-20250620161025626](https://img.tynote.cn/img/typora/20250620161026750.png#400h)

![image-20250620161120035](https://img.tynote.cn/img/typora/20250620161121205.png#400h)

![image-20250620161651464](https://img.tynote.cn/img/typora/20250620161652658.png#400h)

![image-20250620161809521](https://img.tynote.cn/img/typora/20250620161810771.png#400h)

![image-20250620161836657](https://img.tynote.cn/img/typora/20250620161837853.png#400h)

![image-20250620161929130](https://img.tynote.cn/img/typora/20250620161930460.png#400h)

![image-20250620162009745](https://img.tynote.cn/img/typora/20250620162010930.png#400h)

![image-20250620162047463](https://img.tynote.cn/img/typora/20250620162048682.png#400h)

![image-20250620162135885](https://img.tynote.cn/img/typora/20250620162137158.png#400h)

![image-20250620162218250](https://img.tynote.cn/img/typora/20250620162219412.png#400h)

![image-20250620162418135](https://img.tynote.cn/img/typora/20250620162419246.png#400h)

![image-20250620162532601](https://img.tynote.cn/img/typora/20250620162533646.png#400h)

![image-20250620162641047](https://img.tynote.cn/img/typora/20250620162642336.png#400h)

![image-20250620162708192](https://img.tynote.cn/img/typora/20250620162709415.png#400h)

![image-20250620163000755](https://img.tynote.cn/img/typora/20250620163002198.png#400h)

#### 习题5️⃣

![image-20250620163112751](https://img.tynote.cn/img/typora/20250620163114002.png#400h)

![image-20250620163422351](https://img.tynote.cn/img/typora/20250620163423562.png#400h)

![image-20250620163520720](https://img.tynote.cn/img/typora/20250620163521918.png#400h)

![image-20250620164211664](https://img.tynote.cn/img/typora/20250620164212824.png#400h)

![image-20250620164335646](https://img.tynote.cn/img/typora/20250620164336797.png#400h)

![image-20250620164454623](https://img.tynote.cn/img/typora/20250620164455786.png#400h)

![image-20250620164634642](https://img.tynote.cn/img/typora/20250620164635787.png#400h)

![image-20250620164818599](https://img.tynote.cn/img/typora/20250620164819938.png#400h)

![image-20250620165139585](https://img.tynote.cn/img/typora/20250620165140690.png#400h)

![image-20250620165332584](https://img.tynote.cn/img/typora/20250620165333777.png#400h)

![image-20250620165447849](https://img.tynote.cn/img/typora/20250620165449045.png#400h)

![image-20250620180413289](https://img.tynote.cn/img/typora/20250620180414495.png#400h)

![image-20250620181931407](https://img.tynote.cn/img/typora/20250620181932631.png#400h)

​	**对于这部分可共同表示的真值的补码，我们还可以从另一个角度来分析，我们在第2章有关C语言的数据类型及其转换的那节课中，曾介绍过，数据类型之间的转换应该尽量保持转换前后数值不变，对于小字长转大字长，若原数据为有符号类型，则进行符号扩展，这样扩展后可保持数值不变，这与我们刚刚通过举例而找出来的规律本质上是相同的**

![image-20250620182408075](https://img.tynote.cn/img/typora/20250620182409533.png#400h)

![image-20250620182536009](https://img.tynote.cn/img/typora/20250620182537557.png#400h)

#### 习题6️⃣

![image-20250620202432869](https://img.tynote.cn/img/typora/20250620202434248.png#400h)

![image-20250620202617632](https://img.tynote.cn/img/typora/20250620202618722.png#400h)

![image-20250620203227330](https://img.tynote.cn/img/typora/20250620203228431.png#400h)

![image-20250620204126594](https://img.tynote.cn/img/typora/20250620204128104.png#400h)

## (函数调用的机器级表示)(王道)

### call和ret指令

​	**我们从大家熟悉的高级语言视角出发，看一下函数调用的背后发生了什么。当程序运行的时候，系统会为他分配一片内存区域，我们把这片区域称为函数调用栈。来看下面这个例子，程序都是从main函数开始执行，执行main函数的时候，函数调用栈里面有两块数据，我们把用于存储main函数的这一片区域称为main函数的栈帧，除了main函数的信息之外，在栈底的位置还会保存一些和硬件以及系统相关的其他的一些信息。接下来我们在main函数中调用了P这个函数，因此程序会开始执行P的这些代码，当P函数执行的时候，栈顶就会有和P这个函数相关的栈帧，接下来P函数调用Q函数，Q函数相关的信息被压入栈顶，当Q函数返回之后，就会从栈顶删除Q的栈帧，再往后会调用caller这个函数，caller函数栈帧压入栈顶，每个函数的栈帧主要包含局部变量和函数调用相关的信息，比如caller函数中定义了temp1、temp2和sum三个局部变量，它们就存储在caller函数的栈帧里面，caller函数在调用add函数的时候需要传递两个参数，这两个参数同样是被放在caller函数的栈帧里面，细节之后会具体讲述。接下来执行add函数，可以看到当前执行的函数，它对应的栈帧一定是在栈顶的位置，如果这个函数执行完毕并且返回之后，那这个函数的栈帧也会出栈，此时程序的执行回到caller这个函数，同样，caller返回之后，caller函数的栈帧也出栈，程序回到函数P继续执行，当函数P返回之后，其栈帧出栈，最后就回到了main函数**

![image-20250622210529187](https://img.tynote.cn/img/typora/20250622210530985.png#400h)

![image-20250622210502130](https://img.tynote.cn/img/typora/20250622210504988.png#400h)

![image-20250623100926987](https://img.tynote.cn/img/typora/20250623100929002.png#400h)

![image-20250623101009192](https://img.tynote.cn/img/typora/20250623101011290.png#400h)

![image-20250623101859540](https://img.tynote.cn/img/typora/20250623101901387.png#400h)

![image-20250623101952586](https://img.tynote.cn/img/typora/20250623101954493.png#400h)

### 如何访问栈帧

#### 1️⃣函数调用栈在内存中的位置



![image-20250623102138523](https://img.tynote.cn/img/typora/20250623102141136.png#400h)

![image-20250623102458332](https://img.tynote.cn/img/typora/20250623102459847.png#400h)

#### 2️⃣标记栈帧范围：EBP、ESP寄存器

![image-20250623102756144](https://img.tynote.cn/img/typora/20250623102757740.png#400h)

![image-20250623103328050](https://img.tynote.cn/img/typora/20250623103330404.png#400h)

![image-20250623103507230](https://img.tynote.cn/img/typora/20250623103508961.png#400h)

#### 3️⃣访问栈帧数据：push、pop指令

![image-20250623103828379](https://img.tynote.cn/img/typora/20250623103830072.png#400h)

![image-20250623103850744](https://img.tynote.cn/img/typora/20250623103852156.png#400h)

#### 4️⃣访问栈帧数据：mov指令

![image-20250623104201605](https://img.tynote.cn/img/typora/20250623104203298.png#400h)

![image-20250623104239884](https://img.tynote.cn/img/typora/20250623104241730.png#400h)

![image-20250623105438107](https://img.tynote.cn/img/typora/20250623105439448.png#400h)

#### 5️⃣总结

![image-20250623105750574](https://img.tynote.cn/img/typora/20250623105751929.png#400h)

### 如何切换栈帧

#### 1️⃣函数调用时切换栈帧

![image-20250623113309236](https://img.tynote.cn/img/typora/20250623113311065.png#400h)

​	**接下来执行add函数的第一条指令`push ebp`，ebp是指针，也就是将ebp的值(所指向的地址)压入栈中**

![image-20250623113534676](https://img.tynote.cn/img/typora/20250623113536099.png#400h)

​	**执行第二条指令，将esp的值(所指向的地址)赋值给ebp，也就是让ebp指向esp所指向的地址，即让ebp更新为当前所调用函数的基地址**

![image-20250623113725584](https://img.tynote.cn/img/typora/20250623113727114.png#400h)

![image-20250623113936819](https://img.tynote.cn/img/typora/20250623113938170.png#400h)

​	**好处是当一层函数结束，要返回之前，我们总能在当前函数的栈帧底部找到上一层函数的基地址，这样我们就可以恢复ebp寄存器的值。需要补充的是，这两条先保存上一层函数基地址，再切换为当前函数基地址的指令可以精简为一条指令`enter`，`enter`指令是零地址指令，后面不需要跟任何操作数**

![image-20250623114419433](https://img.tynote.cn/img/typora/20250623114420718.png#400h)

​	**我们已经完成切换成add函数的栈帧，接下来就可以往这个栈帧的顶部压入一些数据**

![image-20250623114537353](https://img.tynote.cn/img/typora/20250623114538621.png#400h)

#### 2️⃣函数返回时切换栈帧

​	**当add函数return返回之前，我们要如何恢复esp和ebp寄存器的值呢？只需要用下面两条指令就可以实现**

![image-20250623114714389](https://img.tynote.cn/img/typora/20250623114715685.png#400h)

​	**第一条指令就是让esp指向当前栈帧的底部**

![image-20250623114858145](https://img.tynote.cn/img/typora/20250623114859378.png#400h)

​	**第二条指令就是让当前esp所指元素出栈，写入寄存器ebp，也就是让ebp重新指回了地址0xA00F0030，即ebp指回了caller函数的栈帧底部，同时esp+4指向上一个存储单元（相当于指向了caller函数的栈帧顶部）。所以当一个函数返回之前，只需要执行这两条指令就可以让ebp和esp重新指回上一层函数的栈帧，这两条指令效果等价于`leave`指令**

![image-20250623115445231](https://img.tynote.cn/img/typora/20250623115446702.png#400h)

![image-20250623115534848](https://img.tynote.cn/img/typora/20250623115536499.png#400h)

​	**接下来看一下`return`指令的执行效果，我们知道caller函数执行`call`指令的时候，已经把IP也就是函数的返回地址压入了caller函数栈顶，所以现在esp所指的数据刚好就是函数的返回地址，所以接下来`return`指令的执行就顺理成章了，它会从函数的栈帧顶部找到IP旧值，并且取出这个值写到IP寄存器当中，也就是让程序的执行流回到`call`指令的下一条指令继续往后执行**

![image-20250623120056229](https://img.tynote.cn/img/typora/20250623120057534.png#400h)

#### 3️⃣总结

![image-20250623120236976](https://img.tynote.cn/img/typora/20250623120238319.png#400h)

![image-20250623120757242](https://img.tynote.cn/img/typora/20250623120758498.png#400h)

![image-20250623120826173](https://img.tynote.cn/img/typora/20250623120827455.png#400h)

# 中央处理器

## 中央处理器概述

### 1️⃣概念

![image-20250803170403714](https://img.tynote.cn/img/typora/20250803171024443.png#800w)

![image-20250803171611046](https://img.tynote.cn/img/typora/20250803171612436.png#800w)

**上述四个方面主要功能的实现与CPU的结构密切相关，其中任何一项功能都需要相关硬件来实现**

### 2️⃣CPU的具体组成

![image-20250803171812289](https://img.tynote.cn/img/typora/20250803171813869.png#800w)

​	**CPU的基本组成可划分为控制器和运算器两大部分**

![image-20250803172239095](https://img.tynote.cn/img/typora/20250803172240290.png#800w)

​	**我们知道构成程序的指令和数据位于主存中，CPU内的存储器地址寄存器MAR通常用来存放要访问的存储单元的地址，不管CPU是读取指令还是存取数据 ，都需要先将要访问的主存单元的地址送入MAR，进而通过主存地址总线告知主存，直到访存操作结束。因此，<font color='blue'>MAR的位宽与主存地址总线的位宽是相同的。</font>需要说明的是，MAR并不是必需的，某些计算机可以直接将主存地址送到地址总线上来实现访存。CPU内的存储器数据寄存器MDR通常用来存放待写入主存的数据或者从主存中读出的数据，<font color='blue'>其位宽通常与及其字长相同</font>，MDR与主存之间通过主存数据总线传输数据。需要说明的的是，MDR也不是必需的，这取决于具体的CPU结构。**

![image-20250803173943564](https://img.tynote.cn/img/typora/20250803173945367.png#800w)

​	**假设从主存中读取的数据为指令，则还会将指令放在指令寄存器IR中，因此，<font color='blue'>IR的位宽与指令字长相同</font>。指令中的地址码会送入地址生成逻辑部件，通过该部件对操作数寻址方式译码，进而生成操作数的相关地址，根据寻址方式的不同，操作数的相关地址会被送入程序计数器PC或存储器地址寄存器MAR，当然了，对于立即寻址方式，该部件生成的就是操作数本身，会送入运算部件。需要说明的是，有些架构的计算机，需要将操作码和地址码一起送入地址生成逻辑部件，才能确定地址码的作用，指令中的操作码和地址码还会被一起送入指令译码器，译码成若干个指令译码信号，请注意，<font color='blue'>同一时刻 只有一个指令译码信号有效，用来唯一表示一条指令</font>，这一点与我们在第4章有关[用于地址译码的译码结构](#用于地址译码的译码结构)的那节课中曾给同学们介绍过的地址译码器的译码输出信号特点是一致的。 **

![image-20250803175358676](https://img.tynote.cn/img/typora/20250803175400148.png#800w)

​	**操作控制器接收来自指令译码器的译码信号,根据测试条件、状态信息等，通过时序发生器产生各种具有严格时间先后顺序的操作控制信号，称为微操作控制信号序列，微操作控制信号序列会被传送到计算机各功能部件的控制端，例如运算器中的相关功能部件，用于控制各功能部件按指令要求依序进行动作，进而实现指令索要完成的功能。通过之前的学习我们知道，CPU取指令时会使用程序计数器PC的值作为访问主存的地址，宋瑞主存地址寄存器MAR中，以便从主存中读取指令，当然了，有些没有MAR的CPU会将PC中的主存地址直接送到地址总线上，因此PC的位宽与主存地址总线的位宽是相同的，取值完成后，还要修改PC的值，以形成下一条指令的地址，当程序顺序执行时，PC的值会被加1，注意，这里的加1，本质上是加上指令字长，也就是指令所包含的字节数量，在做习题或考试时，我们要根据题目的叙述，例如主存按字节编址还是按存储字编址，指令字长是多少、指令按边界对齐等，来最终确定加1到底是加多少。另外，对于变长指令系统中的指令，需要进行指令译码后才能确定PC的值应该增加多少，当程序顺序执行到分支跳转处时，PC的值需要基于分支指令所提供的分支地址进行修改，形成跳转后的新指令地址，至此，我们就介绍了CPU中构成控制器的主要部件各自的功能以及它们之间的关系。**

​	**接下来我们看CPU中的运算器，在控制器的控制下，运算器主要完成以下任务：**

![image-20250803214816841](https://img.tynote.cn/img/typora/20250803214818456.png#800w)

​	**运算器的上述任务需要由相关硬件来完成，我们知道，算术逻辑单元ALU是运算器的核心，参与运算的操作数，经过多路选择器MUX的挑选进入ALU，我们在第5章曾学习过[指令中操作数的寻址方式](#操作数寻址方式)，因此我们知道，操作数可能来自存储器数据寄存器MDR，也就是来自于主存，也有可能来自于通用用寄存器组中的通用寄存器。多路选择器MUX在控制器发出的相关控制信号的控制下，选择相应操作数送入算术逻辑单元ALU，ALU在控制器发出的相关控制信号的控制下执行相应运算，运算结果会根据寻址方式送入通用寄存器组中的通用寄存器或存储器数据寄存器MDR，进而送入主存。当然了，通用寄存器组中的通用寄存器的内容， 也可以通过MDR送入主存。通过我们之前的学习不难发现，通用寄存器具有多种用途，例如可作为变址寄存器、基址寄存器、地址指针、ALU的累加器、数据缓冲器等 ，用于存放各种地址信息、操作数、中间结果等，除运算结果外，ALU还会产生算术运算指令、逻辑运算指令、测试指令执行后所建立的各种条件标志，例如 溢出标志OF，进位/借位标志CF、运算结果为负数标志SF，结果为零标志ZF等，这些标志位，我们在第5章有关[指令的操作类型](#指令的操作类型)的那节课中已经练习了很多次。上述这些条件标志会被送入程序状态字寄存器PSW，一般情况下，条件分支指令会根据PSW的值来决定是顺序执行还是转移执行，PSW还可用于保存中断和系统工作的状态信息，这些信息被送入操作控制器，另外，I/O状态也会被送入操作控制器，以便CPU能及时了解计算机的运行状态并进行相应控制。至此，我们就给同学们介绍了一种非常简单的CPU的基本组成，需要说明的是，除上述部件外，现代COU还包含有高速缓冲存储器Cache，存储管理单元MMU，浮点运算器等部件，另外，CPU内包含哪些寄存器与具体的处理器架构、指令集、实现方法等有较大的关系。**

![image-20250803221636797](https://img.tynote.cn/img/typora/20250803221639085.png#800w)

![image-20250803222434790](https://img.tynote.cn/img/typora/20250803222436295.png#800w)

![image-20250803222828378](https://img.tynote.cn/img/typora/20250803222830769.png#800w)

![image-20250803222857948](https://img.tynote.cn/img/typora/20250803222900054.png#800w)

![image-20250803222924772](https://img.tynote.cn/img/typora/20250803222926953.png#800w)

​	**请同学们注意，控制器中的村存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR是用户不可见的，由控制器内部使用，用于控制指令的执行，而程序计数器PC是用户可见的，运算器中的程序状态字寄存器PSW和通用寄存器组也是用户可见的。这里的用户一般指汇编语言程序员，而用户可见的寄存器在进行汇编语言程序设计时可以直接使用。至此，我们就对中央处理器CPU进行了概述。**

![image-20250803222948132](https://img.tynote.cn/img/typora/20250803222949465.png#800w)

### 3️⃣习题

![image-20250803223103313](https://img.tynote.cn/img/typora/20250803223104867.png#800w)

![image-20250803223720632](https://img.tynote.cn/img/typora/20250803223722954.png#800w)

![image-20250803223742209](https://img.tynote.cn/img/typora/20250805124113267.png#800w)

![image-20250803224010388](https://img.tynote.cn/img/typora/20250803224011936.png#800w)

![image-20250803224144839](https://img.tynote.cn/img/typora/20250803224146464.png#800w)

## 指令的执行过程

### 指令执行的一般流程

![image-20250804132013393](https://img.tynote.cn/img/typora/20250804132015163.png#800w)

![image-20250804132413999](https://img.tynote.cn/img/typora/20250804132415868.png#800w)

![image-20250804133055140](https://img.tynote.cn/img/typora/20250804133057141.png#800w)

![image-20250804133134130](https://img.tynote.cn/img/typora/20250804133212572.png#800w)

![image-20250804133155003](https://img.tynote.cn/img/typora/20250804133156812.png#800w)

### 指令周期

![image-20250804133901301](https://img.tynote.cn/img/typora/20250804133903086.png#800w)

![image-20250804134049312](https://img.tynote.cn/img/typora/20250804134051146.png#800w)

![image-20250804134146289](https://img.tynote.cn/img/typora/20250804134148220.png#800w)

![image-20250804134301969](https://img.tynote.cn/img/typora/20250804134303750.png#800w)

​	**如何表示一个指令周期的具体时长呢？那就是利用我们在第1章有关[与运算速度相关的性能指标](#与运算速度相关的性能指标)那节课中曾给同学们介绍过的CPU时钟周期，来表示一个指令周期的具体时长。我们来举例说明**

![image-20250804134839500](https://img.tynote.cn/img/typora/20250804134840983.png#800w)

![image-20250804135157002](https://img.tynote.cn/img/typora/20250804135158794.png#800w)

![image-20250804135247791](https://img.tynote.cn/img/typora/20250804135249488.png#800w)

![image-20250804135536206](https://img.tynote.cn/img/typora/20250804135537730.png#800w)

![image-20250804135938822](https://img.tynote.cn/img/typora/20250804135940067.png#800w)

### 指令周期各阶段的数据流

![image-20250804211626239](https://img.tynote.cn/img/typora/20250804211634575.png#800w)

​	**通过上节课的学习我们知道，指令周期可划分为取指周期、间址周期、执行周期、中断周期。我们首先来看取指周期的数据流，在取指周期阶段需要完成的任务是，根据程序计数器PC的值，从主存中取出指令并送入指令寄存器IR。我们在下图的基础上画出取指周期阶段的数据流，①将程序计数器PC的值，也就是当前指令的地址送到存储器地址寄存器MAR中，②进而可以通过地址总线③传送到主存，④之后由控制单元CU通过控制总线⑤向主存发送读命令，⑥使得PC所指向的主存单元，其内容，也就是指令，通过数据总线⑦传送到存储器数据寄存器MDR中，⑧再送入指令寄存器IR中，这样，IR中的内容就是取到的指令，⑨之后控制单元CU控制PC的内容加1，形成下一条指令的地址。**

![image-20250804212945267](https://img.tynote.cn/img/typora/20250804212946498.png#800w)

​	**再来看间址周期的数据流，在间址周期阶段需要完成的任务是，根据指令中的地址码从主存中获取操作数的有效地址。①将指令寄存器IR中的内容，也就是指令，其形式地址部分，记作Ad(IR)，送到存储器地址寄存器MAR中，②进而可以通过地址总线③传送到主存，④之后由控制单元CU通过控制总线⑤向主存发送读命令，⑥使得形式地址所指向的主存单元，其内容，也就是操作数的有效地址，通过数据总线⑦传送到存储器数据寄存器MDR中，这样 ，MDR中的内容就是取到的操作数的有效地址。**

![image-20250804213706308](https://img.tynote.cn/img/typora/20250804213707683.png#800w)

​	**再来看执行周期的数据流。**

![image-20250804213828904](https://img.tynote.cn/img/typora/20250804213830602.png#800w)

​	**再来看中断周期的数据流，在中断周期阶段需要完成的任务是，保存断点、将中断服务程序的入口地址送入PC。我们在下图的基础上，画出中断周期阶段的数据流。在控制单元CU的控制下，首先将程序断点进行压栈操作，将堆栈指针SP的内容减1后重新进入SP，以便SP指向栈顶，减1的原因不知同学们是否还记得，我们在前一章有关操作数寻址方式的第二次课中曾给同学们介绍过[堆栈寻址方式](#1️⃣0️⃣堆栈寻址)，我们知道栈是向下增长的，也就是向低地址增长的，这就是SP的内容减1以便 SP指向栈顶的原因。①将SP的内容送到存储器地址寄存器MAR中，②进而可以通过地址总线③传送到主存，④之后由控制单元CU通过控制总线⑤向主存发送写命令，⑥并将PC的值，也就是程序断点，送到存储器数据寄存器MDR中，⑦进而可以通过数据总线⑧存入主存，具体来说就是，将程序断点存入了位于主存的栈中，⑨此外，CU还要将中断服务程序的入口地址送入PC中，为下一条指令周期的取指周期做好准备。**

![image-20250804214958112](https://img.tynote.cn/img/typora/20250804214959524.png#800w)

## 数据通路

### CPU内部单总线结构

#### 数据通路概念

![image-20250804215240561](https://img.tynote.cn/img/typora/20250804215242514.png#800w)

​	**接下来我们就围绕下面这幅图来介绍总线结构的数据通路。如下图所示，灰色虚线框部分是CPU，CPU的内部总线连接运算器和各类寄存器，构成了CPU内部的单总线结构的数据通路。CPU的外部总线用于连接CPU、主存以及I/O设备等部件，也称为系统总线或外部总线。CPU内部的算术逻辑单元ALU与其配套的有暂存寄存器$X_{in}$和$Z_{out}$，其中X用于暂存ALU的其中一个操作数，Z用于ALU的运算结果，而ALU的另一个操作数来自CPU的内部总线。CPU内部的程序状态字寄存器PSW，用于暂存ALU的运算状态标志，状态标志将送入操作控制器。CPU内部的通用寄存器组，也称为寄存器堆，它包含一组通用寄存器，可通过通用寄存器的编号对相应的通用寄存器进行读写操作，$R_{\#}$端口为输出寄存器编号，$W_{\#}$端口为写入寄存器编号。指令寄存器IR中的指令经过指令译码器的译码，送入操作控制器，在时钟信号的配合下产生操作控制信号，例如CPU内部的各种控制信号(CPU中的所有蓝色字均为控制信号)，又例如，CPU外的通过控制总线传送给主存的读、写控制信号($Mem_{R}和Mem_{W}$)。另外，CPU内的存储器地址寄存器MAR和存储器数据寄存器MDR不仅与CPU内的部的单总线相连，还通过外部总线中的数据总线和地址总线与主存相连。**

![image-20250804221103175](https://img.tynote.cn/img/typora/20250804221104670.png#800w)

​	**为了简单起见以及方便描述，我们作以下假设，1️⃣主存和所有寄存器都是32位的，2️⃣写入操作由统一时钟控制，上升沿有效。请注意，对于采用单总线结构的CPU内部总线，CPU内的运算器、控制器、专用寄存器、通用寄存器等核心部件都通过这条内部的公共总线连接。同一时刻只能有一个部件向总线发送数据，否则会出现数据冲突。因此，连接到总线上的部件都需要进行输出控制（使用图中所示的三态门），以防止总线上出现数据冲突。而各部件可同时接收总线上的数据。另外，本例中的单总线并不是指由一根物理传输线构成的总线，而是指CPU内各部件都共享该公共总线来传输信号。**

![image-20250804221636063](https://img.tynote.cn/img/typora/20250804221637799.png#800w)

#### 以MIPS32指令为例的单总线结构的数据通路

​	**接下来，我们以MIPS32指令为例，基于上述所示的CPU内部单总线结构，分析不同类型指令的执行流程及所涉及到的数据通路。请注意，实际上，MIPS32架构处理器内部采用的并不是单总线结构，但这并不影响我们学习，我们之所以这样举例，是因为我们之后会介绍数据通路的另一种基本结构，也就是专用通路，在介绍专用通路时，我们仍然采用MIPS32指令，以方便与采用单总线结构的数据通路进行对比。可能同学们还会有疑问，即我们并没有学过MIPS32指令集，直接以MIPS32指令为例介绍相应的数据通路能行吗？大家放心，我们一样能够学习的很好。例如我们在第5章指令系统的第2次综合习题课中一起分析过这道408考研综合大题（5.6习题4），该题并没有告诉我们采用的具体指令集是什么，只是给出了R型、I型、J型三种指令格式及其相应的指令功能，但这并不影响我们解题，实际上，该题所采用的指令集与MIPS32指令集比较相似，只不过是16位定长指令集，而MIPS32是32位定长指令集。**

![image-20250804224331785](https://img.tynote.cn/img/typora/20250804224333343.png#800w)

​	**接下来，我们就以MIPS32指令为例，分析不同类型指令，基于CPU内部单总线结构的执行流程及其所涉及到的数据通路。首先来看lw指令，lw是load word的英文缩写词。**

![image-20250804224024494](https://img.tynote.cn/img/typora/20250804224026190.png#800w)

​	**接下来我们就用基于下图来介绍lw指令的执行流程。我们首先给出该指令的指令周期，如下图所示，前4个CPU时钟周期构成取指周期，用于从主存取出一条指令，接下来的2个CPU时钟周期构成计算周期，用于计算操作数的有效地址，接下来的3个CPU时钟周期构成执行周期，用于实现指令功能。为了后续描述方便，我们将每个CPU时钟周期比喻为一个节拍，我们来看看对于lw指令，其指令周期的各个节拍所要执行的操作。节拍$T_1$所要执行的操作就是将程序计数器PC的值送入存储器地址寄存器MAR，同时还要送入暂存寄存器X，节拍$T_2$所要执行的操作是以MAR的内容为地址，从主存取出指令并送入存储器数据寄存器MDR，同时将暂存器X的内容与4相加（即PC+1，因为指令字长为32位，也就是4个字节，形成下一条指令的地址），运算结果送入暂存寄存器Z。后续各节拍所要执行的操作已在图中给出，稍后我们会将每个节拍所执行的操作都带入之前的那幅图中进行演示，因此，目前就不再介绍每个节拍所要执行的具体操作了 。**

![image-20250805123727723](https://img.tynote.cn/img/typora/20250805123729180.png#800w)

​	**要完成每个节拍所要执行的操作，需要操作控制器产生相应的控制信号，例如，这是lw指令取指周期的第1个节拍所需要的相关控制信号，一般情况下，值为1表示信号有效**

![image-20250805123856738](https://img.tynote.cn/img/typora/20250805123858174.png#800w)

​	**又例如，这是lw指令取指周期的第2个节拍所需要的相关控制信号**

![image-20250805124232308](https://img.tynote.cn/img/typora/20250805124234071.png#800w)

​	**这是后续各节拍所需要的相关控制信号。需要说明的是，为了简单起见，值为0的控制信号在该图中并未给出**

![image-20250805124509055](https://img.tynote.cn/img/typora/20250805124510514.png#800w)

##### 1️⃣lw指令的取指周期

- lw指令取指周期的第1个节拍

​	**接下来我们将lw指令取指周期的第1个节拍所要执行的操作，在基于CPU内部单总线结构的图中进行演示。**

![image-20250805124641020](https://img.tynote.cn/img/typora/20250805124642684.png#800w)

​	**这是该节拍执行操作所需的相关控制信号，它们是CPU内部的操作控制器产生的，由于控制信号$PC_{out}$为有效信号，因此其所控制的三态门打开，这样，程序计数器PC的内容就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，PC的内容会传送到CPU内部单总线上，经过单总线的传送，PC的内容会传送到CPU内部与单总线相连的所有寄存器，以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250805124826175](https://img.tynote.cn/img/typora/20250805124827711.png#800w)

![image-20250805183119541](https://img.tynote.cn/img/typora/20250805183121130.png#800w)

​	**由于控制信号$MAR_{in}$为有效信号，因此，在该节拍中，当CPU时钟信号的上升沿到来时，CPU内单总线上传送来的内容，会被写入存储器地址寄存器MAR。**

![image-20250805183302089](https://img.tynote.cn/img/typora/20250805183323880.png#800w)

​	**同理，由于控制信号$X_{in}$为有效信号，因此，在该节拍中，当CPU时钟信号的上升沿到来时，CPU内单总线上传送来的内容 ，会被写入暂存寄存器X，此时MAR和X的内容都是PC的值。**

![image-20250805191938667](https://img.tynote.cn/img/typora/20250805191940164.png#800w)

​	**MAR的内容还会通过CPU外部的地址总线传送到主存的地址输入端，X的内容会传送到ALU的另一个操作数的输入端，至此，就完成了lw指令取指周期的第1个节拍所需要执行的操作。**	

![image-20250805192138681](https://img.tynote.cn/img/typora/20250805192140335.png#800w)

- lw指令取指周期的第2个节拍

​	**之后，进入lw指令取指周期的第2个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250805192441170](https://img.tynote.cn/img/typora/20250805192442609.png#800w)

​	**这是该节拍执行操作所需的相关控制信号，它们是由CPU内部的操作控制器产生的。**

![image-20250805193618318](https://img.tynote.cn/img/typora/20250805193619849.png#800w)

​	**由于通过CPU外部的控制总线传送到主存读控制端口的控制信号$Mem_R$为有效信号，因此根据之前主存地址输入端所送入的地址，也就是程序计数器PC的值，相应存储单元的内容从主存的数据输出端输出到CPU外部的数据总线，并从数据总线传送到CPU内部的存储器数据寄存器MDR。**

![image-20250805194055786](https://img.tynote.cn/img/typora/20250805194057444.png#800w)

​	**由于控制信号$MDR_{in}E$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU外部的数据总线上传送来的内容会被写入MDR，此时，MDR中的内容就是从主存中取出的指令。**

![image-20250805201206468](https://img.tynote.cn/img/typora/20250805201207861.png#800w)

​	**与此同时，由于算术逻辑单元ALU的+4控制端为有效信号，因此，ALU来自暂存寄存器X的操作数，也就是之前送入的程序计数器PC的值会与4进行加法运算，运算结果会送入暂存寄存器Z进行寄存，具体内容为PC+4，这实际上是下一条指令的地址，至此，就完成了lw指令取指周期的第2个节拍所要执行的操作。此时，存储器数据寄存器MDR中的内容就是从主存中取出的指令，暂存器Z中的内容，就是下一条指令的主存地址。**

![image-20250805202747999](https://img.tynote.cn/img/typora/20250805202749362.png#800w)

- lw指令取指周期的第3个节拍

​	**之后，进入lw指令取指周期的第3个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250805203037096](https://img.tynote.cn/img/typora/20250805203038540.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$Z_{out}$为有效信号，因此其所控制的三态门打开，这样，暂存器Z的内容就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，Z的内容会传送到CPU内部，与单总线相连的所有寄存器以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250805205243427](https://img.tynote.cn/img/typora/20250805205245291.png#800w)

​	**由于控制信号$PC_{in}$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU内部单总线上传送来的内容会被写入程序计数器PC，此时，PC中的内容为PC之前的值加4，也就是下一条指令的主存地址，至此，就完成了lw指令取指周期的第3个节拍所需要执行的操作。此时，程序计数器PC指向了主存中的下一条指令，而存储器数据寄存器MDR中的内容，仍是之前从主存中取出的指令。**

![image-20250805205540290](https://img.tynote.cn/img/typora/20250805205541715.png#800w)

- lw指令取指周期的第4个节拍

​	**之后，进入lw指令取指周期的第4个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250805210045566](https://img.tynote.cn/img/typora/20250805210047094.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$MDR_{out}$为有效信号，因此其所控制的三态门打开，这样，存储器数据寄存器MDR的内容就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，MDR的内容会传送到CPU内部，与单总线相连的所有寄存器以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250805210430967](https://img.tynote.cn/img/typora/20250805210432431.png#800w)

​	**由于控制信号$IR_{in}$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU内部单总线上传送来的内容会被写入指令寄存器IR，此时IR中的内容为之前从主存取出的那条指令，至此就完成了取指周期的第4个节拍各自所执行的全部操作。最终取到了指令，指令经过指令译码器的译码，送入操作控制器，以便为后续操作产生相应的控制信号序列。这部分内容，我们将在本章有关控制器的几次课中进行具体介绍。**

![image-20250805212022382](https://img.tynote.cn/img/typora/20250805212024406.png#800w)

​	**另外，指令中rs字段、rt字段、rd字段各自的值会传送到寄存器组的相关多路选择器的相应输入端。需要说明的是，在MIPS32指令中,rs通常作为第一个源寄存器，用于提供指令操作的第一个操作数，rt既可以作为第二个源寄存器来提供第二个操作数，也可以作为目标寄存器来存放某些指令执行后的结果，在大多数MIPS指令中，rd通常作为目标寄存器用于存放指令执行后的结果。对于lw指令，寄存器组的两个多路选择器各自的输出控制端的控制信号为0，因此它们各自0号端口的输入被选择输出，这样，rs字段的值被送入寄存器组的$R_{\#}$端口，作为输出寄存器的编号，rt字段的值被送入寄存器组的$W_{\#}$端口，作为写入寄存器组的编号。**

![image-20250805212214192](https://img.tynote.cn/img/typora/20250805212215647.png#800w)

​	**我们再来核对一下lw指令的操作描述，可以看到，编号为rs的通用寄存器作为源寄存器，用于提供操作数，是输出寄存器，编号为rt的通用寄存器作为目标寄存器，用于存放从主存中取到的操作数，经过之前的演示可以看出，<font color='blue'>在lw指令的取指周期使用了两条数据通路，一条数据通路用于从主存取出指令到指令寄存器IR，另一条数据通路用于计算并更新程序计数器PC的值，以便PC指向下一条指令</font>。**

![image-20250806145651536](https://img.tynote.cn/img/typora/20250806145701297.png#800w)

##### 2️⃣lw指令的计算周期

​	**接下来进入lw指令的计算周期，以便计算操作数的有效地址。**

- lw指令计算周期的第1个节拍

​	**首先进入的是lw指令计算周期的第1个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250806151757638](https://img.tynote.cn/img/typora/20250806151759341.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$R_{out}$为有效信号，因此其所控制的三态门打开，这样，编号为rs的通用寄存器，其内容就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，编号为rs的通用寄存器的内容会传送到CPU内部与单总线相连的所有寄存器，以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250806162544740](https://img.tynote.cn/img/typora/20250806164930000.png#800w)

​	**由于控制信号$X_{in}$为有效信号，因此，在该节拍中，当CPU时钟信号的上升沿到来时，CPU内单总线上传送来的内容，会被写入暂存寄存器X，至此就完成了lw指令计算周期的第1个节拍所需要执行的操作。此时暂存寄存器X的内容就是编号为rs通用寄存器的内容，并被送入算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250806165359980](https://img.tynote.cn/img/typora/20250806165401571.png#800w)

- lw指令计算周期的第2个节拍

​	**之后，进入指令计算周期的第2个节拍，我们将该节拍所要执行的操作在这基于CPU内部单总线结构的图中进行演示。**

![image-20250806165631318](https://img.tynote.cn/img/typora/20250806165632585.png#800w)

​	**需要说明的是，在本节拍所需要执行的操作中，首先需要将指令的16位立即数imm进行符号扩展（需要有相应的硬件支持），扩展为32位有符号数，这需要由相应的硬件来完成，在本图中为了简单起见并未画出，我们禁用IR(I)来表示扩展后的32位有符号数。**

![image-20250806170149028](https://img.tynote.cn/img/typora/20250806170151063.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$IR_{out}$为有效信号，因此其所控制的三态门打开，这样，指令中已被扩展为32位的有符号立即数，就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，32位有符号立即数会传送到CPU内部与单总线相连的所有寄存器，以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250806171353556](https://img.tynote.cn/img/typora/20250806171354917.png#800w)

​	**由于ALU的ADD控制端为有效信号，因此，ALU将32位有符号立即数与来自暂存寄存器X的操作数，也就是之前送入的编号为RS的通用寄存器的内容进行加法运算，运算结果会送入暂存寄存器Z进行暂存，至此，就完成了lw指令计算周期的第2个节拍所需要执行的操作。计算周期结束，此时，暂存寄存器Z的内容就是编号为rs的通用寄存器的内容与指令中已被扩展为32位有符号立即数的加法结果，这实际上就是指令中源操作数的主存地址。**

![image-20250806172403809](https://img.tynote.cn/img/typora/20250806172405135.png#800w)

​	**经过之前的演示可以看出，这是lw指令的计算周期所使用的数据通路。**

![image-20250806172344495](https://img.tynote.cn/img/typora/20250806172345860.png#800w)

##### 3️⃣lw指令的执行周期

​	**接下来进入lw指令的执行周期，以便将主存指定地址处的32位存储字读取到编号为rt的通用寄存器。**

- lw指令计算周期的第1个节拍

​	**首先进入的是lw指令计算周期的第1个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250806173052210](https://img.tynote.cn/img/typora/20250806173053518.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$Z_{out}$为有效信号，因此其所控制的三态门打开，这样，暂存寄存器Z的内容，也就是指令中源操作数的主存地址，就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，源操作数的主存地址会传送到CPU内部与单总线相连的所有寄存器，以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250806173347789](https://img.tynote.cn/img/typora/20250806173349172.png#800w)

​	**由于控制信号$MAR_{in}$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU内单总线上传送来的内容，会被写入存储器地址寄存器MAR，至此就完成了lw指令执行周期的第1个节拍所要执行的操作。此时存储器地址寄存器MAR的内容就是指令中源操作数的主存地址，MAR的内容还会通过CPU外部的地址总线传送到主存的地址输入端。**

![image-20250806174200794](https://img.tynote.cn/img/typora/20250806174202536.png#800w)

- lw指令计算周期的第2个节拍

​	**之后，进入指令执行周期的第2个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250806174350895](https://img.tynote.cn/img/typora/20250806174352313.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于通过CPU外部的控制总线传送到主存读控制端口的控制信号信号为有效信号，因此根据之前主存地址输入端所送入的地址，也就是指令中源操作数的主存地址，相应存储单元的内容从主存的数据输出端，输出到CPU外部的数据总线，并从数据总线传送到CPU内部的存储器数据寄存器MDR。**

![image-20250806175039853](https://img.tynote.cn/img/typora/20250806175040929.png#800w)

​	**由于控制信号$MDR_{in}E$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU外部的数据总线上传送来的内容会被写入MDR，至此就完成了lw指令执行周期的第2个节拍所需要执行的操作。此时存储器数据寄存器MDR中的内容，就是从主存中取出的指令的源操作数。**

![image-20250806175655803](https://img.tynote.cn/img/typora/20250806175657203.png#800w)

- lw指令执行周期的第3个节拍

​	**之后，进入指令执行周期的第2个节拍，我们将该节拍所要执行的操作在基于CPU内部单总线结构的图中进行演示。**

![image-20250806175919781](https://img.tynote.cn/img/typora/20250806175921138.png#800w)

​	**这是该节拍执行操作所需要的相关控制信号，它们是由CPU内部的操作控制器产生的。由于控制信号$MDR_{out}$为有效信号，因此其所控制的三态门打开，这样，存储器数据寄存器MDR的内容，也就是指令中的源操作数，就会通过该三态门传送到CPU内部单总线上，经过单总线的传送，MDR的内容会传送到CPU内部与单总线相连的所有寄存器，以及算术逻辑单元ALU的其中一个操作数输入端。**

![image-20250806233911628](https://img.tynote.cn/img/typora/20250806233913188.png#800w)

​	**由于控制信号$R_{in}$为有效信号，因此在该节拍中，当CPU时钟信号的上升沿到来时，CPU内部单总线上传送来的内容会被写入编号为rt的通用寄存器，至此就完成了lw指令执行周期的第3个节拍所需要执行的操作。此时编号为rt的通用寄存器的内容，就是从主存指定地址处读取到的32位存储字。**

![image-20250806180549970](https://img.tynote.cn/img/typora/20250806180551936.png#800w)

​	**经过之前的演示可以看出，这是lw指令的执行周期所使用的数据通路。**

![image-20250806180637373](https://img.tynote.cn/img/typora/20250806180638919.png#800w)

##### 4️⃣其他MIPS指令

​	**至此,lw指令的指令周期，包括取指周期、计算周期、执行周期全部结束。接下来我们再给同学们介绍几条MIPS32指令。**

- sw指令(Store Word)

![image-20250806181427221](https://img.tynote.cn/img/typora/20250806181428561.png#800w)

​	**这是sw指令周期的各个节拍所要执行的操作及其所需要的控制信号。对比之前的lw指令，可以发现，sw指令仅执行周期的操作与lw指令不同。请同学们将其代入之前的基于CPU内部单总线结构的图中进行分析。**

![image-20250806181810745](https://img.tynote.cn/img/typora/20250806181812587.png#800w)

- beq指令(Branch If Equal)

![image-20250806183252524](https://img.tynote.cn/img/typora/20250806183253799.png#800w)

**我们知道，指令顺序执行时程序计数器PC的值会在取指阶段被更新为下一条指令的地址（本例中指令为4字节，所以PC=PC+4），而当要进行跳转时，我们为了计算出要跳转到的分支目标地址，我们需要知道下一条指令到分支目标指令之间隔了多少条指令，本例中已知用立即数imm的值来表示，而要把指令条数转换为字节偏移量，进而计算出分支目标地址，就需要把以“指令条数”为单位的立即数imm转换为以“字节为单位”，本例中每条指令4字节，所以imm乘4，也就是imm左移两位，即可得到相对下一条指令的字节偏移量，再与下一条指令的地址PC+4进行相加，即可得到所要跳转的分支目标地址。**

​	**这是beq指令周期的各个节拍所要执行的操作及其所需要的控制信号。请同学们将其代入之前的基于CPU内部单总线结构的图中进行分析。**

![image-20250806184102105](https://img.tynote.cn/img/typora/20250807161832664.png#800w)

- addi指令(Add Immediate)

![image-20250806184313021](https://img.tynote.cn/img/typora/20250806184314790.png#800w)

​	**这是addi指令周期的各个节拍所要执行的操作及其所需要的控制信号。请同学们将其代入之前的基于CPU内部单总线结构的图中进行分析。**

![image-20250806184419480](https://img.tynote.cn/img/typora/20250806184420868.png#800w)

- add指令

![image-20250806210232933](https://img.tynote.cn/img/typora/20250806210234249.png#800w)

​	**这是add指令周期的各个节拍所要执行的操作及其所需要的控制信号。请同学们将其代入之前的基于CPU内部单总线结构的图中进行分析。**

![image-20250806210308732](https://img.tynote.cn/img/typora/20250806210310196.png#800w)

​	**我们将上述5条MIPS32指令其指令周期的各节拍所要执行的操作画在一张图中，可以发现每条指令的取值周期完全相同，下面是lw指令、sw指令、beq指令各自的计算周期及其所包含的各节拍所要执行的操作，对于addi指令和add指令，没有计算周期，最后是每条指令的执行周期及其所包含的各节拍所要执行的操作。在单总线结构中，<font color='blue'>最慢的数据通路是访存通路</font>font>，例如，每条指令的取指周期的第个节拍就包含有访存通路，lw指令的执行周期的第2个节拍包含有访存通路，sw指令的执行周期的第3个节拍包含有访存通路；另外，<font color='blue'>运算通路也是最慢的数据通路</font>，例如每条指令的取指周期的第2个节拍就包含有运算通路，lw指令、sw指令、beq指令，各自的计算周期的第2个节拍包含有运算通路，beq指令、addi指令、add指令各自的执行周期的第2个节拍包含有运算通路。需要说明的是，实际上每条指令执行完毕后，还会进行一些公共操作，通常用于处理设备的I/O请求，如果在公共操作阶段发现有外部设备中断请求则会进入中断响应阶段，进行保存断点和载入中断服务程序入口地址到PC的操作，否则直接进入下一条指令的取指操作，有关中断的相关知识，将在本章后续部分进行详细介绍。另外，取指令也属于公共操作，也就是每条指令都会进行的操作。**

![image-20250806212206181](https://img.tynote.cn/img/typora/20250806212207578.png#800w)

### 习题课 1

#### 习题1

![image-20250806212936704](https://img.tynote.cn/img/typora/20250806212938432.png#800w)

![image-20250806213157591](https://img.tynote.cn/img/typora/20250806213159148.png#800w)

![image-20250806213253215](https://img.tynote.cn/img/typora/20250806213254345.png#800w)

![image-20250806213519410](https://img.tynote.cn/img/typora/20250806213520805.png#800w)

![image-20250806213617300](https://img.tynote.cn/img/typora/20250806213618752.png#800w)

#### 习题2

![image-20250806213846636](https://img.tynote.cn/img/typora/20250806213848120.png#800w)

#### 习题3

![image-20250806214104251](https://img.tynote.cn/img/typora/20250806214152919.png#800w)

##### 1️⃣ADD指令的取指周期

- ADD指令取指周期的第1个节拍

​	**本题所给ADD指令取值周期的第1个节拍过程同[lw指令取指周期的第1个节拍](#1️⃣lw指令的取指周期)相同，此处不再赘述。**

![image-20250806232241205](https://img.tynote.cn/img/typora/20250806232242649.png#800w)

- ADD指令取指周期的第2个节拍

​	**ADD指令取值周期的第1个节拍过程同[lw指令取指周期的第2个节拍](#1️⃣lw指令的取指周期)相同，此处不再赘述。**

![image-20250806232842853](https://img.tynote.cn/img/typora/20250806232844641.png#800w)

- ADD指令取指周期的第3个节拍

​	**ADD指令取值周期的第1个节拍过程同[lw指令取指周期的第4个节拍](#1️⃣lw指令的取指周期)相同，此处不再赘述**

![image-20250806233507805](https://img.tynote.cn/img/typora/20250806233610478.png#800w)

- ADD指令取指周期的第4个节拍

​	**在该节拍中，指令寄存器IR中的ADD指令会被送到指令译码部件进行译码，题目给定，无需控制信号。至此，题目所给ADD指令取指和译码阶段结束。在lw指令中，指令译码过程是包含在其取指周期的第4个节拍中的。**

![image-20250806234545989](https://img.tynote.cn/img/typora/20250806234547699.png#800w)

##### 2️⃣ADD指令的执行周期

- ADD指令执行周期的第1个节拍

![image-20250806235005816](https://img.tynote.cn/img/typora/20250806235207770.png#800w)

- ADD指令执行周期的第2个节拍

![image-20250806235210187](https://img.tynote.cn/img/typora/20250806235211873.png#800w)

![image-20250806235657595](https://img.tynote.cn/img/typora/20250806235659041.png#800w)

**注意，1️⃣上图中节拍C6可以同时进行两个操作是因为一个是外部总线，一个是内部总线，所以可以同时进行，只要不同时占用CPU内部总线导致总线冲突就可以同时进行。2️⃣$A←(R_0)$也可以作为C5节拍，但是由于$MAR←(R_1)和MDR←M(MAR)$都有使用到CPU内部总线，所以需要两个节拍才能完成，从而比上图中要多使用1个节拍。**

- ADD指令执行周期的第3个节拍

![image-20250807001808546](https://img.tynote.cn/img/typora/20250807001810488.png#800w)

- ADD指令执行周期的第4个节拍

![image-20250807001913865](https://img.tynote.cn/img/typora/20250807001946466.png#800w)

- ADD指令执行周期的第5个节拍

​	**在该节拍中，运算结果会被送入寄存器R1的内容所指向的存储单元，也就是将存储器数据寄存器MDR中的运算结果送入存储器地址寄存器MAR的内容所指向的存储单元，而MAR的内容，是在节拍C5中就已送入MAR中的寄存器R1的内容。由于控制信号$MDR_{out}E$为有效信号，因此其所控制的三态门打开，这样，存储器数据寄存器MDR的内容就会通过该三态门传送到CPU外部的数据总线DB上，并通过数据总线传送到主存的数据端口，由于CPU外部的控制总线CB传送到主存写控制端口的控制信号$MemW$为有效信号，因此，根据之前主存地址输入端所送入的地址，也就是寄存器R1的内容，从主存数据端口输入的内容，也即是运算结果，会被写入相应的主存单元。至此，ADD指令的指令周期结束。**

![image-20250807003343826](https://img.tynote.cn/img/typora/20250807003345181.png#800w)

**注意，上图中C8和C9不可以在一个时钟周期，因为而这都用到了寄存器，并且有先后顺序，而在同一个时钟周期的操作是同时进行的。**

### 习题课2

#### 习题 1

![image-20250807161817928](https://img.tynote.cn/img/typora/20250807161827622.png#800w)

​	**关于哪些寄存器是程序员可见的问题，我们在本章第1次课[中央处理器概述](#中央处理器概述)中就有介绍，并练习了相关真题。**

![image-20250807165957281](https://img.tynote.cn/img/typora/20250807165959251.png#800w)

![image-20250807170228229](https://img.tynote.cn/img/typora/20250807170230428.png#800w)

​	**有关给算术逻辑单元ALU配套提供暂存寄存器的问题，实际上我们在上上节有关[CPU内部采用单总线数据通路](#CPU内部单总线结构)的那节课中就有介绍，此外，在上节习题课[习题3](#习题课 1)的硬件框图中算术逻辑单元ALU也配套提供了暂存寄存器。相信我们在分析基于CPU内部单总线结构的数据通路时，同学们已经领会到了为什么要给ALU配套提供暂存寄存器。**

![image-20250807170650186](https://img.tynote.cn/img/typora/20250807170651593.png#800w)

![image-20250807171325208](https://img.tynote.cn/img/typora/20250807171327339.png#800w)

**另外，ALU的运算结果会送入图中所示的移位寄存器SR，可将SR看作是比我们之前所遇到的给ALU的运算结果配套提供的暂存寄存器具有更多功能的暂存寄存器。**

![image-20250807171915417](https://img.tynote.cn/img/typora/20250807171917301.png#800w)

​	**我们在上上节有关[CPU内部采用单总线结构的数据通路](#CPU内部单总线结构)的那节课中就介绍过，CPU内部各个寄存器的内容需要通过响应的三态门才能送到CPU内部的单总线上，各三态门在其相应2控制信号的控制下打开或关闭，这样就可以确保同一时刻仅有一个寄存器访问单总线，以避免数据冲突，此外，在上节习题课习题3的硬件框中需要向CPU内部单总线发送信息的寄存器都有其各自相应的三态门，相信我们在分析基于CPU内部单总线结构的数据通路时，同学们已经领会了三态门的作用，综上所述，本题中的该部件为三态门。**

![image-20250807172956006](https://img.tynote.cn/img/typora/20250807231951855.png#800w)

![image-20250807173003806](https://img.tynote.cn/img/typora/20250807232004093.png#800w)

![image-20250807173436882](https://img.tynote.cn/img/typora/20250807173438898.png#800w)

​	**本图中的端点④、端点⑦、端点⑨、端点⑥还没有完成连接，我们需要在它们之间进行相应连接，以完善单总线数据通路，单总线上的端点⑥连接到多路选择器MUX的其中一路输入，也就是端点⑨，多路选择器MUX的输出，也就是端点⑦，连接到算术逻辑单元ALU的操作数B的输入端，也就是端点④，这样，在多路选择器MUX的控制信号$MUX_{OP}$的控制下，多路选择器可选择来自单总线的数据或数值2进入ALU的操作数B的输入端。**

![image-20250807180310480](https://img.tynote.cn/img/typora/20250807180313380.png#800w)

​	**第(6)问要求我们回答图中为什么多路选择器MUX的一个输入端是2，类似 该问题，我们在上上节有关CPU内部采用单总线结构数据通路的那节课所举的例子中也遇到过，只不过在该例子中，ALU自带加4的功能，用于更新程序计数器PC的值，以便PC指向主存中的下一条指令。对于本题，题目给定，主存按字节编码，存取单位为16位，16位定长指令字，综上所述，程序顺序执行时，下一条指令的地址为$(PC)+2$，在当前指令的取指周期中，PC的值会通过单总线传送，并在相应控制信号的控制下，被分别写入暂存器T和存储器地址寄存器MAR中，进而通过T算术逻辑单元ALU的操作数A的输入端，为了简单起见，图中并未演示存入MAR的情况，多路选择器的控制信号$MUX_{op}$取指为0，则多路选择器0号端口输入的数值2，被多路选择器输出到算术逻辑单元ALU的操作数B的输入端，以便后续进行PC的值加2，并将运算结果也就是PC的更新值通过移位寄存器SR及其相应的三态门送入单总线，进而将其写入PC，我们就不再演示了。**

![image-20250807181705898](https://img.tynote.cn/img/typora/20250807181707620.png#800w)

#### 习题2

![image-20250807181743643](https://img.tynote.cn/img/typora/20250807181745750.png#800w)

​	**由上题题43可知，指令字长为16位，本题给定，Md、Ms1、Ms2为寻址方式位，支持寄存器直接和寄存器间接两种寻址方式，寻址方式位分别为0和1，因此可知，指令中的Md、Ms1、Ms2字段各占1位，当取值为0时，表明相应的操作数采用寄存器直接寻址方式，当取值为1时，表明相应的操作数采用寄存器间接寻址方式；题目给定，Rd、Rs1、Rs2为寄存器编号，该计算机有编号0 ~ 3共4个通用寄存器，记作$R_0~R_3$，因此可知，指令格式中的Rd、Rs1、Rs2字段各占2位，因为$2^2=4$，也就是采用2个二进制位，共有4种组合状态，每种组合状态作为一个通用寄存器的编号，这样我们就可以得出指令操作码OP字段所占的位数为7，进而可以得出，该计算机的指令系统最多可定义的指令数量为$2^7=128$，也就是采用7个二进制位，共有128种组合状态，每种组合状态作为一个指令操作码。**

![image-20250807183534864](https://img.tynote.cn/img/typora/20250807183536940.png#800w)

​	**第(2)问要求inc、shl和sub指令对应的机器代码，这需要我们结合题目给定的指令格式机器说明进行分析。首先来看第1条指令，根据该指令的操作说明不难看出，该指令属于单地址指令，题目给定，单地址指令的末6位均为0，这相当于对于单地址指令，指令格式中的源操作数1和源操作数2都是无效的，根据该指令的操作说明可知，其所执行的操作是将通用寄存器R1中的操作数加1结果再送入R1，因此，操作数寻址方式为题目给定的寄存器直接寻址方式，因此，指令中的Md字段的取指应为0，由于该指令仅使用了通用寄存器R1，而R1编号为1，因此指令中的Rd字段的取值应为01，表明所用的寄存器为R1，题目给定，inc指令的操作码为十六进制01，因此指令格式中的指令操作码OP字段的取值应为0000001，至此我们就得到了第一条指令所对应的机器代码，我们将其写成十六进制形式，并标记在该指令操作说明的右侧。**

![image-20250807215915072](https://img.tynote.cn/img/typora/20250807215916618.png#800w)

​	**再来看第二条指令，根据该指令的操作说明不难看出，该指令属于二地址指令，题目给定，二地址指令的末3位均为0，这相当于对于二地址指令，指令格式中的源操作数2是无效的，根据该指令的操作说明可知，其所执行的操作是将通用寄存器R1中的操作数左移一位结果送入通用寄存器R2，因此，操作数寻址方式为题目给定的寄存器直接寻址方式，因此，指令格式中的Md和Ms1字段各自的取值应为0，由于该指令源操作数使用了通用寄存器R1，目的操作数使用了通用寄存器R2，而R1编号为1，因此指令格式中的Rd字段的取值应为01，表明源操作数所用的寄存器为R1，R2编号为2，因此指令格式中的Rs1字段的取值应为10，表明目的操作数所用的寄存器为R2,题目给定，shl指令的操作码为十六进制02，因此指令格式中的指令操作码OP字段的取值应为0000010，至此我们就得到了第二条指令所对应的机器代码，我们将其写成十六进制形式，并标记在该指令操作说明的右侧。**

![image-20250807220448627](https://img.tynote.cn/img/typora/20250807220449940.png#800w)

​	**再来看三条指令，根据该指令的操作说明不难看出，该指令属于三地址指令，题目给定，通用寄存器R1用于源操作数1，通用寄存器R2用于源操作数2，通用寄存器R3用于目的操作数，根据该指令的源操作数1的操作说明可知，源操作数1采用的寻址方式是寄存器间接寻址方式，也就是说，通用寄存器R1的内容是源操作数1的有效地址，因此指令格式中Ms1字段的取值应为1，Rs1字段的取值应为01，表明源操作数所用的寄存器为R1；根据该指令的源操作数2的操作说明可知，源操作数2采用的寻址方式是寄存器直接寻址方式，也就是说，通用寄存器R2的内容是源操作数2，因此指令中Ms2字段的取值应为0，Rs2字段的取值应为10，表明源操作数所用的寄存器为R2；根据该指令的目的操作数的操作说明可知，目的操作数采用的寻址方式是寄存器直接寻址方式，也就是说，源操作数1和源操作数2的运算结果，也即是目的操作数存放在通用寄存器R3中，因此指令格式中的Md字段的取值应为0，Rd字段的取值应为11，表明目的操作数所用的寄存器为R3,题目给定，shl指令的操作码为十六进制03，因此指令格式中的指令操作码OP字段的取值应为0000011，至此我们就得到了第三条指令所对应的机器代码，我们将其写成十六进制形式，并标记在该指令操作说明的右侧。**

![image-20250807222210074](https://img.tynote.cn/img/typora/20250807222211634.png#800w)

​	**第(3)问要求我们给出图a中①~⑧处的控制信号或控制信号的取值，这需要我们基于之前题43的硬件框图进行分析。在左侧图中包含有2条指令，它们的 取指阶段是相同的，但是执行阶段不同。接下来我们将指令shl R2,R1的取指阶段和执行阶段依次带入右侧的图中进行分析，找出各阶段的基于CPU内部单总线的数据通路，进而得出标号①~④处的控制信号或控制信号的取值，之后，请同学们将指令sub R0,R2,(R1)代入右侧的图中进行分析，以便得出标号⑤~⑧处的控制信号或控制信号的取值。**

![image-20250807223002757](https://img.tynote.cn/img/typora/20250807223004545.png#800w)

![image-20250807225020027](https://img.tynote.cn/img/typora/20250807225021707.png#800w)

**此处MDR与主存总线之间并没有设置三态门及其控制信号，这与我们之前所学的情况稍有不同，这是因为本题中使用的是主存专用总线其他外设不能使用，因此不会产生数据冲突，进而可以不使用三态门，而各寄存器向CPU内部单总线传送内容的线路是需要设置三态门及其控制信号的，只不过为了简单起见，题目所给的图中并未画出相应的三态门。**

![image-20250807225300348](https://img.tynote.cn/img/typora/20250807225301877.png#400h)

**取指阶段第二个节拍的目的是计算出下一条指令的地址。**

![image-20250807225448914](https://img.tynote.cn/img/typora/20250807225450477.png#800w)

**取指阶段第3各节拍目的是更新程序计数器PC的值**

![image-20250807230006963](https://img.tynote.cn/img/typora/20250807230008457.png#800w)

​	**取指阶段第4个节拍的目的是将指令送往指令译码器进行译码并产生后续 需要的控制信号序列，这里可简单认为控制部件中包含有指令译码器。**

![image-20250807230413200](https://img.tynote.cn/img/typora/20250807230415189.png#800w)

![image-20250807230436856](https://img.tynote.cn/img/typora/20250807230438448.png#800w)

​	**接下来，请自行完成对sub R0,R2,(R1)的数据通路的分析。由于取指阶段相同，所以只需分析执行阶段。**

![image-20250807230746522](https://img.tynote.cn/img/typora/20250807230748489.png#800w)

![image-20250807230815489](https://img.tynote.cn/img/typora/20250807230818214.png#800w)

![image-20250807230833498](https://img.tynote.cn/img/typora/20250807230834842.png#800w)

![image-20250807231022671](https://img.tynote.cn/img/typora/20250807231024535.png#800w)

![image-20250807231118470](https://img.tynote.cn/img/typora/20250807231120324.png#800w)

![image-20250807231209674](https://img.tynote.cn/img/typora/20250807231211284.png#800w)

![image-20250807231258609](https://img.tynote.cn/img/typora/20250807231300077.png#800w)

### 习题课3

![image-20250807231911620](https://img.tynote.cn/img/typora/20250807231913100.png#800w)

![image-20250809190101197](https://img.tynote.cn/img/typora/20250809190110029.png#800w)

![image-20250809190500070](https://img.tynote.cn/img/typora/20250809190501292.png#800w)

![image-20250809190557220](https://img.tynote.cn/img/typora/20250809190558973.png#800w)

**由于0表示符号为正，而在真值表中我们通常认为正的即为真的(true)，也就是1，同理1表示符号为负，我们认为其真值为假，即真值为0(false)，所以符号与真值的关系是逻辑非的关系。**

![image-20250809191400816](https://img.tynote.cn/img/typora/20250809191402899.png#800w)

![image-20250809192651481](https://img.tynote.cn/img/typora/20250809192653215.png#800w)

![image-20250809192754602](https://img.tynote.cn/img/typora/20250809192756793.png#800w)

![image-20250809192828244](https://img.tynote.cn/img/typora/20250809192830375.png#800w)

![image-20250809192919270](https://img.tynote.cn/img/typora/20250809192921408.png#800w)

![image-20250809193214119](https://img.tynote.cn/img/typora/20250809193216117.png#800w)

![image-20250809193343056](https://img.tynote.cn/img/typora/20250809193345006.png#800w)

​	**题目给定，rd为所要写入内容的通用寄存器的编号，共4位，根据我们在第4章存储系统有关[用于地址译码的译码结构](#用于地址译码的译码结构)的那节课所学的知识可知，rd应连接地址译码器的输入端，而地址译码器的译码输出端用于选中所要写入信息的通用寄存器。例如rd为0000时和rd为0001时的情况如下图所示，1表示被选中，0表示不选中。**

![image-20250809194055508](https://img.tynote.cn/img/typora/20250809194057693.png#800w)

![image-20250809194118131](https://img.tynote.cn/img/typora/20250809194120463.png#800w)

​	**那作为要读取内容的通用寄存器的编号rs应该如何连接呢？rs应连接到多路选择器的选择控制端，用于选择将哪一路输入进行输出。例如当rs为0000时和rs为0001时的情况如下图所示。**

![image-20250809194531003](https://img.tynote.cn/img/typora/20250809194532909.png#800w)

![image-20250809194610523](https://img.tynote.cn/img/typora/20250809194612247.png#800w)

![image-20250809194816200](https://img.tynote.cn/img/typora/20250809194818395.png#800w)

![image-20250809194932135](https://img.tynote.cn/img/typora/20250809194934003.png#800w)

![image-20250809195034341](https://img.tynote.cn/img/typora/20250809195036122.png#800w)

​	**对于取指阶段的节拍①③各自至少需要一个时钟周期，因为这两个步骤中都需要使用一次CPU内部单总线，为避免单总线数据冲突，每个时钟周期只能使用一次单总线，综上所述，取指令阶段至少需要7个时钟周期。**

![image-20250809195349532](https://img.tynote.cn/img/typora/20250809195351420.png#800w)

​	**从本题所给的硬件框图可以看出指令寄存器IR的输出信号会连接到控制部件CU的输入端，题目所给的标志寄存器FR，也就是之前介绍过的程序状态字寄存器PSW，它的输出信号也会连接到控制部件CU的输入端，我们在之前的理论课中举例时所采用的硬件框图中也有涉及，如下图所示，可以看到，指令寄存器IR的输出信号经过指令译码器译码，输出到操作控制器，可认为本题中的控制部件CU就包含了指令译码器和操作控制器，另外，程序状态字寄存器PSW的输出信号也连接到了操作控制器。**

![image-20250809204641607](https://img.tynote.cn/img/typora/20250809204643520.png#800w)

![image-20250809204710825](https://img.tynote.cn/img/typora/20250809204713034.png#800w)

## 控制器

### CPU的时序及其控制方式

#### CPU的时序

​	**在之前的几次课中，我们介绍了基于CPU内部单总线结构的数据通路的相关知识，当时，为了将重点放在数据通路上，我们仅简单介绍了CPU内部的控制器的作用，那就是产生操作控制信号序列，以控制对CPU内部单总线的使用，例如图中所示的取指周期的第一个节拍数据通路中相关部件所要执行的caozuo以及所需的相关操作控制信号，那么我们当时仅简单介绍了这些操作控制信号是由CPU内部的控制器产生的，但并没有进一步介绍它们是如何产生的，我们当时将重点放在了指令、数据或运算结果等是如何在相应操作控制信号的控制下基于CPU内部单总线进行传送的，那么从本节课开始，我们将重点从数据通路转移到CPU内部的控制器，因为它是CPU的重要组成部分。**

​	**从该图可以看出，控制器有多个输入源，其中CPU时钟是最基本的输入源，控制器何时产生操作控制信号，这些操作控制信号持续多长时间，都取决于CPU的时序，因此，本节课我们介绍CPU的时序及其控制方式。**

![image-20250809205726886](https://img.tynote.cn/img/typora/20250809205728888.png#800w)

![image-20250809205900899](https://img.tynote.cn/img/typora/20250809205903222.png#800w)

![image-20250809210025001](https://img.tynote.cn/img/typora/20250809210026925.png#800w)

​	**接下来，我们给出一个三级时序的时序图，进一步帮助大家理解三级时序的相关概念。如下图所示，这是某个三级时序系统的示意图，其中每个指令周期包含有取指周期、计算周期和执行周期这三个状态周期，我们在图中看到的是它们各自的信号，高电平有效。**

​	**例如这段时间取指周期信号处于高电平，用于指示当前处于取指令的操作阶段。**

![image-20250809210445641](https://img.tynote.cn/img/typora/20250809210447568.png#800w)

​	**之后的这段时间，计算周期信号处于高电平，用于指示当前处于计算操作数有效地址的操作阶段。以此类推。**

![image-20250809210610274](https://img.tynote.cn/img/typora/20250809210612373.png#800w)

![image-20250809210640592](https://img.tynote.cn/img/typora/20250809210642526.png#800w)

​	**之后的这段时间，取指周期信号再次处于高电平，用于指示当前处于取下一条指令的操作阶段。以此类推，计算周期信号和执行周期信号也是周期性地出现高电平并维持一段时间，用于指示处于当前指令周期中的具体操作阶段。**

![image-20250809210800683](https://img.tynote.cn/img/typora/20250809210802537.png#800w)



​	**从图中还可以看出，每个状态周期包含4个节拍电位信号，也是高电平有效，例如取指周期信号有效的这段时间，又被划分成了节拍电位1的信号有效、节拍电位2的信号有效、节拍电位3的信号有效、节拍电位4的信号有效这4个更小的时间单元，分别用于指示当前处于取指周期的哪个步骤，同理，计算周期和执行周期同样被划分成4个更小的时间单元。**

![image-20250809211304385](https://img.tynote.cn/img/typora/20250809211305884.png#800w)

![image-20250809211456463](https://img.tynote.cn/img/typora/20250809211458423.png#800w)

​	**从图中还可以看出，每个节拍电位包含1个节拍脉冲，需要说明的是，节拍脉冲可能直接来自CPU的时钟，也可能是其分频信号。我们给该图中添加一些分隔线，以方便看出状态周期、节拍电位、节拍脉冲这三级时序的对应关系，对于本例，取指周期这个状态周期包含4个节拍电位，每个节拍电位包含1个节拍脉冲；计算周期这个状态周期包含4个节拍电位，每个节拍电位包含1个节拍脉冲；执行周期这个状态周期包含4个节拍电位，每个节拍电位包含1个节拍脉冲。**

![image-20250809211846027](https://img.tynote.cn/img/typora/20250809211848087.png#800w)

![image-20250809211936451](https://img.tynote.cn/img/typora/20250809211938509.png#800w)

![image-20250809211957250](https://img.tynote.cn/img/typora/20250809211959417.png#800w)

​	**之后，又进入下一条指令的取指周期。**

![image-20250809212059215](https://img.tynote.cn/img/typora/20250809212100839.png#800w)

#### 定长指令周期的三级时序

​	**请注意，我们刚刚举例的这个三级时序系统是定长指令周期的三级时序系统，也就是说，所有指令的指令周期包含相同状态数量的状态周期和节拍电位，我们对三级时序进行如下比喻，以帮助大家理解。**

![image-20250809212349646](https://img.tynote.cn/img/typora/20250809212351318.png#800w)

![image-20250809212415678](https://img.tynote.cn/img/typora/20250809212418080.png#800w)

​	**请注意，对于指令集中 包含有大量功能简单的指令而言，采用定长指令周期的三级时序，会造成时间浪费，这是因为，一般来说，功能简单的指令比功能复杂的指令的指令周期短，然而如果采用定长指定周期，则对于那些功能简单的指令而言就会造成时间浪费，尤其是指令中包含有大量功能简单的指令，而仅有少数功能复杂的指令的情况。**

![image-20250809212812271](https://img.tynote.cn/img/typora/20250809212814203.png#800w)

#### 变长指令周期的三级时序

![image-20250809212952816](https://img.tynote.cn/img/typora/20250809212954974.png#800w)

![image-20250809213022952](https://img.tynote.cn/img/typora/20250809213024309.png#800w)

![image-20250809213750779](https://img.tynote.cn/img/typora/20250809224006744.png#800w)

​	**另外，需要注意的是，不要将定长指令周期和变长指令周期与我们之前在第5章中介绍的定长指令系统和变长指令系统搞混淆了。定长指令系统和变长指令系统是针对指令长度而言的，而定长指令周期和变长指令周期是针对指令相关时间而言的。**

![image-20250809214048417](https://img.tynote.cn/img/typora/20250809214050651.png#800w)

![image-20250809214137535](https://img.tynote.cn/img/typora/20250809214139723.png#800w)

#### 传统多级时序控制方式

![image-20250809214332816](https://img.tynote.cn/img/typora/20250809214334309.png#800w)

### 时序发生器

#### 时序发生器的设计

​	**上节课中介绍了早期计算机采用状态周期、节拍电位和节拍脉冲三级时序对操作控制信号进行定时控制。本节课我们介绍能够产生这三级时序的硬件，也就是时序发生器的工作原理和设计方法。如下图所示，这是传统三级时序中时序发生器的组成框图，其中，晶体振荡器作为脉冲源经过时序整形和分频后得到三级时序中的节拍脉冲信号，它作为时序发生器的其中一个输入源，经过时序发生器，产生三级时序中的状态周期信号和节拍电位信号，对于定长指令周期的同步控制方式，状态周期信号和节拍电位信号仅与节拍脉冲信号相关。对于变长指令周期的同步控制方式，状态周期信号和节拍电位信号的产生还可能与指令译码信号和反馈信息信号相关。除上述输入信号外，时序发生器还应具有启动、停止、复位等控制信号，以确保节拍电位，从第一个节拍开始，到最后一个节拍结束，这样可以确保状态周期的完整性。在了解了时序发生器的输入/输出信号后，那么如何实现时序发生器呢，实际上，时序发生器就是一个同步时序电路，这是数电课程中的一个重点内容。**

![image-20250809221834531](https://img.tynote.cn/img/typora/20250809221836486.png#800w)

![image-20250809223037768](https://img.tynote.cn/img/typora/20250809223040647.png#800w)

![image-20250809223327207](https://img.tynote.cn/img/typora/20250809223441709.png#800w)

**需要说明的是，本例与在数电课程中设计计数器时稍有不同的是，对于本例中的各状态，我们关心的是哪些时序信号有效，而不是计数值。**

![image-20250809225330432](https://img.tynote.cn/img/typora/20250809225857789.png#800w)

![image-20250809225729271](https://img.tynote.cn/img/typora/20250809225936757.png#800w)

**从该图可以看出，在取指周期的最后一个状态，也就是状态S3，进行了分支，如果当前指令是lw指令，或sw指令，或beq指令，则进入计算周期的第一个状态，也就是状态S4；如果当前指令是add指令或addi指令，则进入执行周期的第一个状态。**

![image-20250809225637222](https://img.tynote.cn/img/typora/20250809230011002.png#800w)

**对于变长指令周期的同步控制方式，状态周期信号和节拍电位信号的产生还可能与指令译码信号和反馈信息信号相关，现在通过本例就可以很好地说明，在取值周期的最后一个状态，还要根据指令译码信号进行状态分支。**

![image-20250811165433497](https://img.tynote.cn/img/typora/20250811165443994.png#800w)

​	**接下来就是根据状态转换图写出状态转换表，这样做的目的是方便我们找出时序发生器的输入信号与输出信号之间的逻辑关系，也就是写出它们之间的逻辑表达式，进而可以根据逻辑表达式构建相应的组合逻辑电路，最终构建出时序发生器。假设当前处于状态S0，我们将其记录到状态转换表中的现态，我们将该状态的有效输出信号，包括状态周期信号和节拍电位信号我们将该状态的有效输出信号也相应地记录在状态转换表中，在节拍脉冲的下降沿，会从现态S0转换到次态S1，该转换对于本例中的5条MIPS32指令情况都是一样的，我们将其记录在状态转换表中；现在将S1看作是现态，我们将其记录到状态转换表中，我们将该状态的有效输出信号也相应地记录在状态转换表中，在节拍脉冲的下降沿，会从现态S1转换到次态S2，该转换对于本例中的5条MIPS32指令情况都是一样的，我们将其记录在状态转换表中；现在将S2看作是现态，我们将其记录到状态转换表中，我们将该状态的有效输出信号也相应地记录在状态转换表中，在节拍脉冲的下降沿，会从现态S2转换到次态S3，该转换对于本例中的5条MIPS32指令情况都是一样的，我们将其记录在状态转换表中。**

![image-20250811172409578](https://img.tynote.cn/img/typora/20250811172411643.png#800w)

​	**现在将S3看作是现态，我们将其记录到状态转换表中，我们将该状态的有效输出信号也相应地记录在状态转换表中，在节拍脉冲的下降沿，现态S3会根据指令译码的结果转换到相应的次态，如下图所示**

![image-20250811172610350](https://img.tynote.cn/img/typora/20250811173155607.png#800w)

![image-20250811173009132](https://img.tynote.cn/img/typora/20250811173825027.png#800w)

​	**从状态转换图可以看出，若为lw指令，或sw指令，或beq指令，则次态为S4，若为add指令或addi指令，则次态为S6，我们将上述两种情况记录到状态转换表中**

![image-20250811174215710](https://img.tynote.cn/img/typora/20250811174217156.png#800w)

​	**假设之前进入的次态为S4，现在将S4看作是现态，我们将其记录到状态转换表中，我们将该状态的有效输出信号也相应地记录在状态转换表中，在节拍脉冲的下降沿，会从现态S4转换到次态S5，我们将其记录在状态转换表中。请大家将表补充完整。**

![image-20250811174428479](https://img.tynote.cn/img/typora/20250811174430145.png#800w)

![image-20250811174435966](https://img.tynote.cn/img/typora/20250811174437720.png#800w)

​	**从刚刚的状态转换表可以得出，有现态和次态的对应关系，因此我们需要使用状态寄存器来记录状态，从状态转换表还可以看出，每个现态都有相应的输出信号，因此我们可以设计相应的组合逻辑电路，该组合逻辑电路的输入，就是来自于状态寄存器输出的现态，而该组合逻辑电路的输出，就是我们所需要的三级时序中的状态周期信号和节拍电位信号。那么该组合逻辑电路该如何设计呢，我们来举例说明，为了方便描述，我们将状态编码的各位从高到低依次记为$b_3b_2b_1b_0$，它们由状态寄存器进行输出。**

![image-20250811175147214](https://img.tynote.cn/img/typora/20250811175149051.png#800w)

​	**假设我们要写出执行周期信号MEX的逻辑表达式，可以看出，MEX仅在S6S7S8这三个状态有效，我们写出这三个状态编码的逻辑表达式，进而我们可以写出MEX的逻辑表达式。**

![image-20250811175402725](https://img.tynote.cn/img/typora/20250811175404346.png#800w)

​	**接下来，写出节拍电位T3的逻辑表达式，从状态转换表可以看出，节拍电位T3仅在S2和S8这两个状态有效，因此我们可以写出T3的逻辑表达式。**

![image-20250811175717106](https://img.tynote.cn/img/typora/20250811175718965.png#800w)

​	**按照上述方法，我们可以写出状态转换表中所有输出信号，也就是各状态周期信号和各节拍电位信号各自的逻辑表达式，进而设计出相应的组合逻辑电路。另外，我们还要根据状态转换表中的现态与次态的转换关系，设计实现有限状态机的组合逻辑电路，状态寄存器输出的现态，作为有限状态机的输入，而有限状态机的输出，也就是次态，作为状态寄存器的输入，作为下一个现态，除状态寄存器的输出作为有限状态机的输入外，反馈信息信号和指令译码信号也作为有限状态机的输入。例如，根据指令译码信号的结果，来决定现在S3转换到的次态是S4还是S6，另外，状态转换是在节拍脉冲的下降沿进行的，因此需要给状态寄存器输入节拍脉冲，至此，我们就设计出了一种变长指令周期三级时序的时序发生器。**

![image-20250811180331304](https://img.tynote.cn/img/typora/20250811180333107.png#800w)

​	**我们来总结一下上述设计流程。第一步是划分三级时序中的各状态周期和节拍电位，也就是画出三级时序图，第二步是根据三级时序图构建Moore型有限状态机，第三步是根据状态转换图写出状态转换表，第四步是根据状态转换表构建时序发生器。**

![image-20250811180615780](https://img.tynote.cn/img/typora/20250811180617823.png#800w)

![image-20250811180650075](https://img.tynote.cn/img/typora/20250811180652098.png#800w)

​	**另外，TCP的三报文握手建立连接和四报文挥手释放连接，同学们都已经非常熟悉了，同学们对于其中的报文类型，发送顺序，以及报文首部中的序号、确认号以及标志位等相关知识在复习备考时比较重视，但却忽视了其中的状态转换，然而在408考验中，却偏偏出现了相关考查，例如2021年的题38，希望同学们引起重视。**

![image-20250811181113569](https://img.tynote.cn/img/typora/20250811181115456.png#800w)

#### 习题

![image-20250811181255876](https://img.tynote.cn/img/typora/20250811181257861.png#800w)

![image-20250811181335549](https://img.tynote.cn/img/typora/20250811181337545.png#800w)

![image-20250811181547928](https://img.tynote.cn/img/typora/20250811181549894.png#800w)

​	**选项D的叙述是错误的，用本节课我们介绍过的三级时序划分的例子就能说明，可将三级时序中的节拍脉冲简单看作是CPU时钟脉冲，在该图最下面一行的多个时钟脉冲信号中，只有当这个时钟脉冲信号到来时，才处于执行周期的第一个节拍电位。**

![image-20250811181856235](https://img.tynote.cn/img/typora/20250811181858086.png#800w)

**<font color='blue'>顺便提一下，408考研对于单选题的描述是，下列每题所给的四个选项中，只有一个选项最符合试题要求，那么从这个意义上说，对于本题，尽管选项A的叙述并不完全正确，但是选项D的叙述错误更严重，因此本题应该选D。</font>**

### 三级时序硬布线控制器

#### 概述

![image-20250811185631899](https://img.tynote.cn/img/typora/20250811185633740.png#800w)

![image-20250811185710152](https://img.tynote.cn/img/typora/20250811185711854.png#800w)

![image-20250811185741781](https://img.tynote.cn/img/typora/20250811185743494.png#800w)

![image-20250811185902058](https://img.tynote.cn/img/typora/20250811185903558.png#800w)

**从该图可以看出，硬布线控制器组合逻辑单元基于指令译码信号、反馈信息信号，以及三级时序发生器产生的状态周期信号和节拍电位信号，产生指令执行所需要的所有控制信号序列。例如下图中控制器产生的这些控制信号。**

![image-20250811190246567](https://img.tynote.cn/img/typora/20250811190248387.png#800w)

![image-20250811190313380](https://img.tynote.cn/img/typora/20250811190315072.png#800w)

![image-20250811190419545](https://img.tynote.cn/img/typora/20250811190421615.png#800w)

**我们给上图中这些输入信号标上不同的颜色吗，以方便查看控制信号的逻辑表达式。这里给出的是数字逻辑中典型的积之和范式，它是实现组合逻辑电路的核心，是直接从真值表推导逻辑表达式的基础，也是逻辑化简的主要目标形式。从该逻辑表达式可以看出，状态周期信号和节拍电位信号参与了逻辑与操作，这样就限定了各操作控制信号的产生时间和持续时间。**

![image-20250811190919015](https://img.tynote.cn/img/typora/20250811190920615.png#800w)

​	**综上所述**

![image-20250811191045116](https://img.tynote.cn/img/typora/20250811191046813.png#800w)

#### 一般设计流程

![image-20250811191252359](https://img.tynote.cn/img/typora/20250814154048847.png#800w)

**实际上在之前的基于CPU内部单总线的数据通路的那节课中，我们学习的就是步骤1。**

![image-20250811191506114](https://img.tynote.cn/img/typora/20250811191508054.png#800w)

​	**步骤②③我们在上上节有关时序发生器的那节课中也已经学习过了。**

![image-20250811191659173](https://img.tynote.cn/img/typora/20250811191701432.png#800w)

![image-20250811191728407](https://img.tynote.cn/img/typora/20250811191730340.png#800w)

​	**接下来，我们就来举例说明步骤4，在上节课中，我们已经得出了三级时序硬布线控制器中的核心，也就是硬布线控制器组合逻辑单元，其输出信号，也就是微操作控制信号序列，与输入信号，包括指令译码信号、状态周期信号、节拍电位信号、反馈信息信号之间的逻辑表达式。**

![image-20250811192117225](https://img.tynote.cn/img/typora/20250811192119290.png#800w)

​	**经过之前介绍的步骤① ~ 步骤③，就可以得出该表达式中各输入信号与输出信号之间的逻辑关系，例如下表所示，这是我们之前在多次课中都用到过的例子，也就是基于CPU内部单总线的数据通路以及MIPS32指令集中的5条典型指令进行的三级时序划分，根据该表，我们就可以写出硬布线控制器组合逻辑单元输出的每一个控制信号与其每一个输入信号的逻辑表达式。**

![image-20250811192350485](https://img.tynote.cn/img/typora/20250814154109955.png#800w)

​	**例如，我们来写出控制信号$X_{in}$的逻辑表达式。首先在表格中找出控制信号$X_{in}$，，可以发现，对于5条指令中的任何一条指令，都需要在取指周期中的节拍电位1使控制信号$X_{in}$有效，我们将其记为取值周期信号$M_{if}$与节拍电位1信号T1的逻辑与，还可以发现，对于lw指令、sw以及beq这三条指令，都需要在计算周期中的节拍电位1使控制信号$X_{in}$有效，而add指令和addi指令没有计算周期，因此可以不用关心$X_{in}$是否有效，我们将其记为计算周期信号$M_{cal}$与节拍电位1信号T1的逻辑与，还可以发现，对于beq、addi和add这三条指令，都需要在执行周期中的节拍电位1使控制信号$X_{in}$有效，而lw指令和sw指令则需要使$X_{in}$无效，我们将其记为$M_{EX}•T1•(beq+addi+add)$，其中$M_{EX}$是执行周期信号，T1是节拍电位1信号，beq、addi、add是指令译码信号，这样我们就得到了控制信号$X_{in}$的逻辑表达式。**

![image-20250811194434434](https://img.tynote.cn/img/typora/20250811194436344.png#800w)

​	**可以发现，控制信号$X_{in}$的逻辑表达式与我们上节课介绍的硬布线控制器组合逻辑单元的输出信号与输入信号的积之和范式是一致的，换句话说，上节课介绍的是一个通用的逻辑表达式，本节课，我们会将其具体化到每一个控制信号的逻辑表达式。请注意，在控制信号$X_{in}$的逻辑表达式中，没有出现反馈信息信号FB，也就是说控制信号$X_{in}$与反馈信息信号无关。**

![image-20250811195146411](https://img.tynote.cn/img/typora/20250811195148666.png#800w)

​	**接下来，请参照之前写出控制信号$X_{in}$的逻辑表达式的方式，写出控制信号$Z_{out}$的逻辑表达式。相信大家都能正确完成，此处不再赘述。**

![image-20250812170846353](https://img.tynote.cn/img/typora/20250812170854698.png#800w)

​	**写出控制信号$PC_{in}$的逻辑表达式。框选部分解释，$M_{EX}$是执行周期信号，T3是节拍电位3信号，beq是指令译码信号，这三种信号在之前的举例和练习中已经出现过了，而PSW.ZF是程序状态字寄存器中ZF标志位的输出信号，它属于硬布线控制器组合逻辑单元的其中一种输入信号，也就是反馈信息信号。**

![image-20250812171823124](https://img.tynote.cn/img/typora/20250812171824634.png#800w)

​	**大家可将$PC_{in}$的逻辑表达式与我们上节课介绍过的硬布线控制器组合逻辑单元的输出信号与输入信号的积之和的范式进行对比，我们已经用颜色进行了区分，可以发现他们是一致的。**

![image-20250812171847559](https://img.tynote.cn/img/typora/20250812171849017.png#800w)

​	**按照之前的举例和练习所使用的方法，对于每一个控制信号，都要分析其在不同指令、不同状态周期以及不同节拍电位下是否有效，进而写出每一个控制信号的逻辑表达式。至此，我们就完成了三级时序硬布线控制器设计流程的前4个步骤，之后就可以进入步骤5。**

![image-20250812173020339](https://img.tynote.cn/img/typora/20250812173021868.png#800w)

### 现代时序硬布线控制器

#### 概述

​	**对于现代时序硬布线控制器，就不再需要状态周期信号和节拍电位信号了，因此，传统三级时序硬布线控制器中的时序发生器的用于产生状态周期信号和节拍电位信号的这部分组合逻辑电路对于现代时序硬布线控制器也就不再需要了，而将状态寄存器输出的现态直接作为硬布线控制器组合逻辑单元的输入，用于产生相应的操作控制信号，这样我们就得到了现代时序硬布线控制器的组成框图。现在需要解决的问题是，如何设计有限状态机组合逻辑，如何设计硬布线控制器组合逻辑单元。**

![image-20250812173729977](https://img.tynote.cn/img/typora/20250812173731452.png#800w)

![image-20250812174014098](https://img.tynote.cn/img/typora/20250812174015591.png#800w)

#### 现代时序硬布线控制器设计

​	**接下来我们就介绍现代时序硬布线控制器的设计流程。下面是上节课介绍的三级时序硬布线控制器的一般设计流程，我们来对比给出现代时序硬布线控制器的一般设计流程。**

![image-20250812174627489](https://img.tynote.cn/img/typora/20250812174629320.png#800w)

​	**接下来我们仍然以基于CPU内部单总线的数据通路和MIPS32指令集中的5条典型指令为例，介绍现代时序硬布线控制器的设计。如图所示，这是我们上节课设计传统三级时序硬布线控制器时就分析过的内容，这可以作为现代时序硬布线控制器设计流程中的前两个步骤，只不过，左侧表格中的状态周期和节拍电位对于现代时序硬布线控制器而言是不存在的，这样我们就可以基于左侧表格进行现代时序硬布线控制器设计流程中的步骤3和步骤4，进而通过步骤5来实现现代时序硬布线控制器。**

![image-20250812175202232](https://img.tynote.cn/img/typora/20250812175203879.png#800w)

​	**从这张表格可以看出，分别是取指令过程中所需要的控制信号，计算操作数有效地址过程中所需要的控制信号，指令执行过程中所需要的控制信号。为了看得清楚，我们只保留表格中的这些控制信号即可。**

![image-20250812175614712](https://img.tynote.cn/img/typora/20250812175616385.png#800w)

![image-20250812175659159](https://img.tynote.cn/img/typora/20250812175700710.png#800w)

​	**接下来我们就可以时钟周期为单位画出指令执行的状态转换图，得出状态转换表，构造相应的有限状态机了。首先来看lw指令，这是每个时钟周期各自所对应的状态以及在各状态下需要有效的控制信号，进入状态S8后，S8为当前状态，则在该状态所在时钟周期结束时，也就是时钟信号下降沿时进行状态切换，切换到次态S0，此时S0成现态，这样我们就可以画出相应的状态转换图了，如图所示。**

![image-20250812180237009](https://img.tynote.cn/img/typora/20250812180238626.png#800w)

![image-20250812180309350](https://img.tynote.cn/img/typora/20250812180310623.png#800w)

​	**再来看sw指令，实际上，对于每一条指令，它们的取指令过程是相同的，因此，具有相同的状态S0 ~ S3，以及在相应状态下需要有效的控制信号，S9 ~ S10为计算操作数有效地址的过程中以及指令执行过程中，每个时钟周期各自所对应的状态以及在各状态下需要有效的控制信号，进入状态S13后，S13为当前状态，则在该状态所在时钟周期结束时，也就是时钟信号下降沿时进行状态切换，切换到次态S0，此时S0成现态，这样我们就可以画出相应的状态转换图了，由于对于每一条指令，取值过程所包含的4个状态S0 ~ S3都是相同的，因此我们从取指令过程的最后一个状态，也就是S3开始，画出sw指令所涉及的其他状态，如图所示。**

![image-20250812181931860](https://img.tynote.cn/img/typora/20250812181933632.png#800w)

![image-20250812181045995](https://img.tynote.cn/img/typora/20250812181351323.png#800w)

​	**再来看beq指令，同理，S0 ~ S3相同，S14 ~ S18为计算操作数有效地址的过程中以及指令执行过程中，每个时钟周期各自所对应的状态以及在各状态下需要有效的控制信号，进入状态S18后，S18为当前状态，则在该状态所在时钟周期结束时，也就是时钟信号下降沿时进行状态切换，切换到次态S0，此时S0成现态，需要说明的是，对于beq指令，上述状态转换还有一个条件，那就是程序状态字寄存器PSW的ZF标志位的值为1，此时才会包含指令执行过程，也就是执行跳转，否则不包含指令执行过程，从计算操作数有效地址的最后一个状态，也就是S15切换到取指令过程的第一个状态，也就是S0，这样我们就可以画出相应的状态转换图了，由于对于每一条指令，取值过程所包含的4个状态S0 ~ S3都是相同的，因此我们从取指令过程的最后一个状态，也就是S3开始，画出beq指令所涉及的其他状态，如图所示，这是程序状态字寄存器PSW的ZF标志位值为1时的状态转换情况以及程序状态字寄存器PSW的ZF标志位值为0时的状态转换情况。**

![image-20250812181841832](https://img.tynote.cn/img/typora/20250812181843520.png#800w)

![image-20250812182139535](https://img.tynote.cn/img/typora/20250812182141157.png#800w)

​	**再来看addi指令，同理，S0 ~ S3相同，S19 ~ S21为指令执行过程中，每个时钟周期各自所对应的状态以及在各状态下需要有效的控制信号，进入状态S21后，S21为当前状态，则在该状态所在时钟周期结束时，也就是时钟信号下降沿时进行状态切换，切换到次态S0，此时S0成现态，这样我们就可以画出相应的状态转换图了，由于对于每一条指令，取值过程所包含的4个状态S0 ~ S3都是相同的，因此我们从取指令过程的最后一个状态，也就是S3开始，画出addi指令所涉及的其他状态，如图所示。**

![image-20250812182606997](https://img.tynote.cn/img/typora/20250812182608561.png#800w)

![image-20250812182515779](https://img.tynote.cn/img/typora/20250812182517625.png#800w)

​	**再来看add指令，同理，S0 ~ S3相同，S22 ~ S24为指令执行过程中，每个时钟周期各自所对应的状态以及在各状态下需要有效的控制信号，进入状态S21后，S21为当前状态，则在该状态所在时钟周期结束时，也就是时钟信号下降沿时进行状态切换，切换到次态S0，此时S0成现态，这样我们就可以画出相应的状态转换图了，由于对于每一条指令，取值过程所包含的4个状态S0 ~ S3都是相同的，因此我们从取指令过程的最后一个状态，也就是S3开始，画出add指令所涉及的其他状态，如图所示。**

![image-20250812182802344](https://img.tynote.cn/img/typora/20250812182804098.png#800w)

![image-20250812182902026](https://img.tynote.cn/img/typora/20250812182903651.png#800w)

**至此，我们就得到了本例中完整的状态转换图，也就是有限状态机的图形化表示，接下来，就可以根据状态转换图写出状态转换表了，类似工作，我们在之前的有关时序发生器的那节课中进行过详细介绍，此处不再赘述。**

![image-20250812183405873](https://img.tynote.cn/img/typora/20250812183407599.png#800w)

![image-20250812183309018](https://img.tynote.cn/img/typora/20250812183310451.png#800w)

![image-20250812183428826](https://img.tynote.cn/img/typora/20250812183430664.png#800w)

![image-20250812183507232](https://img.tynote.cn/img/typora/20250812183509147.png#800w)

![image-20250812183545127](https://img.tynote.cn/img/typora/20250812183547065.png#800w)

​	**至此我们就完成了现代时序硬布线控制器设计流程中的前4个步骤，之后就可以进入步骤5了。**

![image-20250812183730248](https://img.tynote.cn/img/typora/20250812183731863.png#800w)

### 微程序控制器

#### 相关基本概念

![image-20250812191459643](https://img.tynote.cn/img/typora/20250812191501180.png#800w)

![image-20250812191541312](https://img.tynote.cn/img/typora/20250812191543129.png#800w)

​	**我们可将各组控制信号编码成微指令，而这些微指令就构成了lw指令的微程序，用以实现lw指令的指令功能。右图为CPU内部的控制存储器，用于存储指令集中每一条指令相应的微程序。**

![image-20250812192013979](https://img.tynote.cn/img/typora/20250812192015538.png#800w)

![image-20250812192041662](https://img.tynote.cn/img/typora/20250812192043052.png#800w)

![image-20250812192203238](https://img.tynote.cn/img/typora/20250812192205192.png#800w)

​	**在我们之前多次课中经常使用的这幅基于CPU内部单总线的数据通路的图中就包含有大量的操作控制点，从微程序控制的思想来看，这些操作控制点收到控制器产生的各种控制信号就属于微命令，收到微命令后，相关执行部件会执行相应的微操作，例如，指令寄存器IR的相关操作控制点收到$IR_{in}$微命令时就执行相应的微操作，那就是将单总线上传来的数据写入指令寄存器。**

![image-20250812193003823](https://img.tynote.cn/img/typora/20250812193005268.png#800w)

![image-20250812203144244](https://img.tynote.cn/img/typora/20250812203146050.png#800w)

![image-20250812203257131](https://img.tynote.cn/img/typora/20250812203346883.png#800w)

![image-20250812203414979](https://img.tynote.cn/img/typora/20250812203416396.png#800w)

![image-20250812203500454](https://img.tynote.cn/img/typora/20250812203502111.png#800w)

![image-20250812204306185](https://img.tynote.cn/img/typora/20250812204308140.png#800w)

![image-20250812204329380](https://img.tynote.cn/img/typora/20250812204331270.png#800w)

![image-20250812204530333](https://img.tynote.cn/img/typora/20250812204532303.png#800w)

![image-20250812204629894](https://img.tynote.cn/img/typora/20250812204631702.png#800w)

#### 微程序控制器的组成

​	**微程序控制器主要由控制存储器(Control Storage)、地址转移逻辑以及微地址寄存器三大部分组成。**

![image-20250812210340111](https://img.tynote.cn/img/typora/20250812210342139.png#800w)

![image-20250812210428422](https://img.tynote.cn/img/typora/20250812210430123.png#800w)

![image-20250813114106228](https://img.tynote.cn/img/typora/20250813114115389.png#800w)

​	**例如在我们之前多次课中都用来举例说明基于CPU内部单总线的数据通路的那幅图中，红色框选部分都是相关执行部件的控制点。**

![00w](https://img.tynote.cn/img/typora/20250813144033718.png#800w)

![image-20250813144041646](https://img.tynote.cn/img/typora/20250813144043955.png#800w)

![image-20250813144130211](https://img.tynote.cn/img/typora/20250813144131932.png#800w)

![image-20250813144241081](https://img.tynote.cn/img/typora/20250813144243424.png#800w)

![image-20250813144615091](https://img.tynote.cn/img/typora/20250813144617229.png#800w)

![image-20250813144754451](https://img.tynote.cn/img/typora/20250813144756044.png#800w)

![image-20250813145001376](https://img.tynote.cn/img/typora/20250813145003258.png#800w)

![image-20250813145940182](https://img.tynote.cn/img/typora/20250813145942066.png#800w)

![image-20250813145957991](https://img.tynote.cn/img/typora/20250814154025342.png#800w)

![image-20250813164940405](https://img.tynote.cn/img/typora/20250813164941791.png#800w)

![image-20250813165048952](https://img.tynote.cn/img/typora/20250813165050545.png#800w)

![image-20250813165735110](https://img.tynote.cn/img/typora/20250813165736787.png#800w)

#### 下一个微地址的形成

##### 下一个微地址形成的两种方法

​	**本节课介绍微程序控制器中下一条微指令的微地址的产生方法，也就是地址转移逻辑给微地址寄存器输入的下一个微地址是如何产生的，我们将其简称为下一个微地址的形成。主要包含两种方法，一种是下址字段法（断定法），另一种方法是计数器法。**

![image-20250813170602657](https://img.tynote.cn/img/typora/20250813170604833.png#800w)

![image-20250813170755179](https://img.tynote.cn/img/typora/20250813170756936.png#800w)

![image-20250813170812944](https://img.tynote.cn/img/typora/20250813170814743.png#800w)

​	**从下图可以看出，这两种方法相应的微程序控制器中的地址转移逻辑是不同的，大家至少可以发现，除指令、外部状态条件这两种输入外，这两种地址转移逻辑的其他输入并不完全相同，那么接下来就介绍分别采用这两种方法的微程序控制器其地址转移逻辑的实现方法。**

![image-20250813171151059](https://img.tynote.cn/img/typora/20250813171152793.png#800w)

##### 下址字段法(断定法)地址转移逻辑

​	**如图所示，这是一种采用下址字段法的微程序控制器的组成框图，其中紫色框选部分就是下址字段法转移逻辑，它主要由微程序入口查找组合逻辑、多路选择器以及条件判别测试组合逻辑这三部分构成。**

![image-20250813171720546](https://img.tynote.cn/img/typora/20250813171722323.png#800w)

![image-20250813171931700](https://img.tynote.cn/img/typora/20250813171933406.png#800w)

**根据上述规定可以列出判别测试条件与用于多路选择器的选择输出端控制信号之间的关系，进而可以设计出条件判别测试组合逻辑电路。**

![image-20250813172259018](https://img.tynote.cn/img/typora/20250813172301043.png#800w)

![image-20250813172621854](https://img.tynote.cn/img/typora/20250813172623795.png#800w)

​	**在之前有关微程序控制器的第一次课中，我们介绍过，微指令中的下址字段用于存放下一条微指令的地址，其长度，也就是二进制位数，取决于微程序的规模，也就是指令集中每一条指令的微程序以及公共的取指令的微程序所包含的微指令的数量总和，对于本题，共有130条微指令。**

![image-20250813172907778](https://img.tynote.cn/img/typora/20250813172909839.png#800w)

​	**接下来介绍计数器法地址转移逻辑，主要介绍计数器发地址转移逻辑与下址字段法转移逻辑的不同之处。如图所示，这是一种采用计数器法的微程序控制器的组成框图，之前已经介绍过，与下址字段法相比，计数器法不再需要微指令中包含下址字段，而只包含判别测试字段和操作控制字段即可，这样有利于减少微指令的额长度。默认情况下，下一条微指令的微地址是通过微地址寄存器输出的当前微地址加1得到的顺序地址，将其送入地址转移逻辑中的多路选择器，为了确保每一条指令的微程序的最后一条微指令都能跳转到取指令微程序的入口地址，需要给微指令的判别测试字段增加一个用于判别其所在微程序结束的判别测试位$P_{end}$，当该位为1时， 表示当前微指令是其所在微程序的最后一条微指令，当这条微指令执行完毕，并且没有其他判别测试条件或其他判别测试条件不成立，例如没有中断请求，地址转移逻辑中的条件判别测试组合逻辑应控制多路选择器，将取指令微程序的入口地址，也就是控制存储器中0号存储单元的地址作为下一个微地址进行输出。**

![image-20250813173937724](https://img.tynote.cn/img/typora/20250813173939796.png#800w)

![image-20250813174009452](https://img.tynote.cn/img/typora/20250813174011456.png#800w)

![image-20250813174111241](https://img.tynote.cn/img/typora/20250813174112984.png#800w)

![image-20250813174206455](https://img.tynote.cn/img/typora/20250813174207946.png#800w)

#### 微指令设计

​	**本节课介绍微指令设计，我们仍然以之前在多次课中使用过的基于CPU内部单总线的数据通路这幅图示意图，以及MIPS32指令集中的这5条典型指令为例介绍如何设计相应的微指令的格式，以便我们在下节课中为这5条典型的MIPS32指令设计各自相应的微程序，进而实现这5条指令各自的功能。从下图可以看出，红色框选部分均为接受微命令的微操作控制点，需要说明的是，控制指令寄存器IR向CPU内部单总线输出的这个微操作控制带你，实际上还应细分为$IR(I)_{out}$和$IR(A)_{out}$，其中一个用于控制指令寄存器中的立即数输出到CPU内部单总线，我们在其名称中的括号内用大写字母$I$表示，另一个用于控制指令寄存器中的分支目标地址输出到CPU内部单总线，我们在其名称中的括号内用大写字母$A$表示，之前没有细分，目的是降低大家初学数据通路时的难度。这样共有22个微操作控制点。**

![image-20250813191139485](https://img.tynote.cn/img/typora/20250813191141442.png#800w)

![image-20250813191315137](https://img.tynote.cn/img/typora/20250813191317036.png#800w)

​	**这是我们在有关微程序控制器的第一次课，也就是微程序控制器相关基本概念那节课中介绍过的微指令的一般格式，对于本例，微指令的操作控制字段应包含22个微命令位，每一位对应一个微操作信号。**

![image-20250813191631882](https://img.tynote.cn/img/typora/20250813191633851.png#800w)

![image-20250813191754488](https://img.tynote.cn/img/typora/20250813191756102.png#800w)

​	**$P_0$位被称为指令译码测试位$P_{IR}$，这个知识点我们在上节课已经介绍过了。另外对于判别字段的其他测试位，当被置1时，则需要检测其相应外部状态条件反馈信号，条件满足，则在当前指令的微程序内跳转到相应微指令处，对于本例，只需要检测一个外部状态条件反馈信号，因此，除$P_0$位，判别测试字段中还应包含有一个指示是否检测该外部状态条件反馈信号的判别测试位$P_1$，当$P_1$位为1时，表示要检测相应的外部状态条件反馈信号，在本例中，这个外部状态条件反馈信号就是程序状态字寄存器PSW的ZF标志位输出信号，该反馈信号用于beq指令执行周期的最后一步，若该反馈信号有效，暂存寄存器T的内容通过CPU内部单总线送到程序计数器PC。当判别测试字段的内容为全0时，下一条微指令的地址由当前微指令的下址字段给出，即顺序执行。**

![image-20250813192836738](https://img.tynote.cn/img/typora/20250813192838436.png#800w)

![image-20250813192738485](https://img.tynote.cn/img/typora/20250813192740201.png#800w)

![image-20250813192747982](https://img.tynote.cn/img/typora/20250813192749776.png#800w)

![image-20250813192923091](https://img.tynote.cn/img/typora/20250813192924827.png#800w)

![image-20250813193004258](https://img.tynote.cn/img/typora/20250813193005916.png#800w)

​	**接下来我们直接给出本例中为计数器法设计的微指令格式。**

![image-20250813193234939](https://img.tynote.cn/img/typora/20250813193236755.png#800w)

![image-20250813193301962](https://img.tynote.cn/img/typora/20250813193303715.png#800w)

![image-20250813193330094](https://img.tynote.cn/img/typora/20250813193332095.png#800w)

**上述内容实际上我们在上节有关下址字段法和计数器法及其各自的地址转移逻辑的那节课中就都介绍过了，本节课我们是以CPU内部单总线的数据通路和MIPS32指令集中的5条典型指令为例，将重点放到了下址字段法和计数器法各自相应的微指令格式的设计上。**

​	

#### 微程序设计

![image-20250814080502612](https://img.tynote.cn/img/typora/20250814080504477.png#800w)

​	**下图是我们之前在有关现代时序硬布线控制器设计的那节课中以基于CPU内部单总线的数据通路和MIPS32指令集中的条典型指令为例得出的状态转换图，本节课我们仍然以该图为例介绍微程序控制器中的微程序设计。**

![image-20250814080809938](https://img.tynote.cn/img/typora/20250814080812160.png#800w)

![image-20250814080908185](https://img.tynote.cn/img/typora/20250814081644142.png#800w)

​	**每一个状态$S_x$需要给出的微操作控制信号应该映射到相应微指令的操作控制字段中的微命令位。例如，这是我们上节课得出的采用下址字段法的微指令格式，对于取指令微程序中的第一条微指令，微操作控制信号$PC_{out}$在微指令的操作控制字段中的相应微命令位应设置为1，同理，另外两个微操作控制信号的相应微命令位也应设置为1。**

![image-20250814081601011](https://img.tynote.cn/img/typora/20250814081603600.png#800w)

​	**我们首先来设计公共的取指令微程序，从状态转换图可以看出，取指令过程包含4个状态，即状态S0 ~ S3，每个状态对应一条微指令，我们首先写出这4条微指令在控制存储器中的地址，如图所示，需要说明的是，由于状态转换图中包含S0 ~ S24共25个状态，给每个状态编号，共需要5个比特，也就是说，每个状态的编号由5个二进制位构成。之前我们已经介绍过了，状态转换图中的每个状态对应一条微指令，每一个状态的编号值作为微指令在控制存储器中的地址，接下来就写出这4个地址所对应的控制存储器中的存储单元应存放的微指令，而微指令中下址字段的内容应设置为下一条微指令在控制存储器中的地址。首先来写地址00000所对应存储单元中应存放的微指令，也就是状态S0所对应的微指令，根据状态转换图可以知道状态S0所需要的相关微操作控制信号，因此微指令的操作字段中相应的微命令位应该置1，而微指令的下址字段的内容应设置为下一条微指令的地址，也就是00001，接下来写状态S1所对应的微指令，操作同状态S0，状态S2，S3对应的微指令也同理。**

![image-20250814083719689](https://img.tynote.cn/img/typora/20250814083721858.png#800w)

​	**由于状态S3所对应的微指令是取指微程序的最后一条微指令 ，这条微指令执行完毕后，就完成了取指令的操作，之后就应该根据所取指令通过地址转移逻辑中的微程序入口查找组合逻辑产生该指令的微程序的入口地址，因此，微指令的判别测试字段中的P0位应该置1，相应地，微指令的下址字段无效。上述有关判别测试字段红P0位的相关知识点，我们在之前有关[下一个微地址的形成方法](#下一个微地址的形成)的那节课中已经介绍过。**

![image-20250814085422282](https://img.tynote.cn/img/typora/20250814085424682.png#800w)

![image-20250814085530886](https://img.tynote.cn/img/typora/20250814085533214.png#800w)

​	**接下来设计lw指令的微程序，该指令包含计算操作数有效地址和执行指令两个过程，计算操作数的有效地址包含S4 ~ S5两个状态，执行指令过程包含S6 ~ S8三个状态，一共五个状态，各自对应一条微指令，最后一条微指令执行完毕后，进入S0状态，其相应的微指令为公共过的取指令微程序的第一条微指令。这是5条微指令各自在控制存储器中的地址，我们按照之前设计取指令微程序的方法就可以设计出lw指令的微程序，其最后一条微指令的下址字段的内容就是之前设计公共的取指令微程序的入口地址，也就是取指令微程序中的第一条微指令的地址。**

![image-20250814090302292](https://img.tynote.cn/img/typora/20250814090304646.png#800w)

​	**接下来设计sw指令的微程序，该指令包含计算操作数有效地址和执行指令两个过程，计算操作数的有效地址包含S9 ~ S10两个状态，执行指令过程包含S11 ~ S13三个状态，一共五个状态，各自对应一条微指令，最后一条微指令执行完毕后，进入S0状态，其相应的微指令为公共过的取指令微程序的第一条微指令。这是5条微指令各自在控制存储器中的地址，我们按照之前设计lw指令微程序的方法就可以设计出sw指令的微程序，其最后一条微指令的下址字段的内容就是之前设计公共的取指令微程序的入口地址，也就是取指令微程序中的第一条微指令的地址。**

![image-20250814090431503](https://img.tynote.cn/img/typora/20250814090433914.png#800w)

​	**接下来设计beq指令的微程序，该指令的计算操作数的有效地址包含S14 ~ S15两个状态，计算操作数有效地址的过程结束后，若程序状态字寄存器PSW的ZF标志位为1，则进入执行指令过程，包含S16 ~ S18三个状态，若程序状态字寄存器PSW的ZF标志位为0，则进入S0状态，其相应的微指令为公共的取指令微程序的第一条微指令，综上所述，就可以设计出beq指令的微程序。在计算操作数的有效地址过程的第二个状态，也就是状态S15，其所对应的微指令中，判别测试字段中的P1测试位应置为1，用来指明这条微指令执行完毕后，需要检查程序状态字寄存器PSW的ZF标志位，若为0，则这条微指令的下址字段有效，按下址字段的内容取出下一条微指令，也就是公共的取指令微程序的第一条微指令，若为1，则应将P1测试位对应的微程序内的分支目标地址送入微地址寄存器。**

![image-20250814100636578](https://img.tynote.cn/img/typora/20250814100637780.png#800w)

​	**接下来设计addi指令的微程序，该指令仅包含执行指令过程，执行指令过程包含S19 ~ S21三个状态，各自对应一条微指令，最后一条微指令执行完毕后，进入S0状态，其相应的微指令为公共的取指令微程序的第一条微指令。下图是设计好的addi指令的微程序，此处不再赘述。**

![image-20250814102730885](https://img.tynote.cn/img/typora/20250814102733062.png#800w)

​	**接下来设计add指令的微程序，该指令仅包含执行指令过程，执行指令过程包含S22 ~ S24三个状态，各自对应一条微指令，最后一条微指令执行完毕后，进入S0状态，其相应的微指令为公共的取指令微程序的第一条微指令。下图是设计好的addi指令的微程序，此处不再赘述。**

![image-20250814103129105](https://img.tynote.cn/img/typora/20250814103131712.png#800w)

​	**如果采用的是计数器法又如何进行微程序设计呢？首先我们需要采用上节课设计好的采用计数器法的微指令格式，也就是不包含下址字段，另外在判别测试字段中添加一个判别测试位$P_{end}$，当该位为1时，表示当前微指令是微程序的最后一条微指令，下一条应进入公共的取指令的微程序。之后就可以设计出公共的取指令的微程序。**

![image-20250814103639117](https://img.tynote.cn/img/typora/20250814103641222.png#800w)

​	**这是lw指令的微程序。**

![image-20250814103709577](https://img.tynote.cn/img/typora/20250814103711793.png#800w)

​	**这是beq指令的微程序。**

![image-20250814103738043](https://img.tynote.cn/img/typora/20250814103740170.png#800w)

​	**sw指令，addi和add指令的微程序的设计就不再赘述了。**

#### 微指令中操作控制字段的表示方法

##### 直接表示法

​	**在上节课中，微指令的操作控制字段采用的是直接表示法。**

![image-20250814104106780](https://img.tynote.cn/img/typora/20250814104109000.png#800w)

![image-20250814104133177](https://img.tynote.cn/img/typora/20250814104135657.png#800w)

​	**本节课介绍微指令中操作控制字段的另一种表示方法，即编码表示法，也称为字段译码法，之后还会介绍将直接表示法和编码表示法结合起来的混合表示法。首先来看编码表示法。**

##### 编码表示法

![image-20250814104407474](https://img.tynote.cn/img/typora/20250814104409723.png#800w)

​	**例如下图所示**

![image-20250814104501071](https://img.tynote.cn/img/typora/20250814104503433.png#800w)

​	**我们在本课程的第四章存储系统的多次课中都用到过译码器，如下图所示。**

![image-20250814104608946](https://img.tynote.cn/img/typora/20250814104611265.png#800w)

![image-20250814104644009](https://img.tynote.cn/img/typora/20250814104646428.png#800w)

​	**假设微指令中用于操作控制的各互斥微命令字段均为3位编码，因此，各互斥微命令字段需要使用3-8译码器进行译码。假设互斥微命令字段1的额内容位2编码001，3-8译码器输出译码结果，1表示有效0表示无效，这相当于集激活一个有效的微操作控制信号；假设互斥微命令字段2的内容编码为101，3-8译码器输出译码结果，1表示有效0表示无效，这相当于集激活一个有效的微操作控制信号，这两个有效的微操作控制信号经时间同步后，再去控制数据通路中的相关部件。**

![image-20250814105318081](https://img.tynote.cn/img/typora/20250814105320241.png#800w)

​	**需要说明的是，由于用于顺序控制的判别测试字段的各判别测试位所对应的外部状态条件一般也是互斥的，因此该字段也可以采用编码表示法。**

![image-20250814105459348](https://img.tynote.cn/img/typora/20250814105501561.png#800w)

​	**如下图所示。**

![image-20250814105533194](https://img.tynote.cn/img/typora/20250814105535304.png#800w)

![image-20250814105639361](https://img.tynote.cn/img/typora/20250814105641653.png#800w)

![image-20250814105939653](https://img.tynote.cn/img/typora/20250814105941347.png#800w)

![image-20250814110149971](https://img.tynote.cn/img/typora/20250814110152082.png#800w)

![image-20250814110312067](https://img.tynote.cn/img/typora/20250814110314471.png#800w)

![image-20250814110417835](https://img.tynote.cn/img/typora/20250814110420231.png#800w)

![image-20250814110450270](https://img.tynote.cn/img/typora/20250814110452709.png#800w)

![image-20250814111355037](https://img.tynote.cn/img/typora/20250814111357393.png#800w)

##### 混合表示法

![image-20250814112123997](https://img.tynote.cn/img/typora/20250814112125903.png#800w)

![image-20250814112202589](https://img.tynote.cn/img/typora/20250814112204635.png#800w)

#### 水平型微指令和垂直型微指令

 	**在上节课的基础上，我们介绍水平型微指令和垂直型微指令的概念。从图中可以看出，对于微指令操作控制字段的这三种表示方法，在一个微指令周期内都可以同时给出多个微命令，这种微指令称为水平型微指令。**

![image-20250814113654403](https://img.tynote.cn/img/typora/20250814113657210.png#800w)

![image-20250814114559136](https://img.tynote.cn/img/typora/20250814114602067.png#800w)

​	**由于垂直型微指令采用类似机器指令的编码方式，因此一条垂直型微指令包含微操作码字段和微地址码字段两部分。**

![image-20250814120434789](https://img.tynote.cn/img/typora/20250814120436973.png#800w)

![image-20250814120540912](https://img.tynote.cn/img/typora/20250814120543369.png#800w)

![image-20250814121107026](https://img.tynote.cn/img/typora/20250814121109026.png#800w)

#### 微程序控制器的设计流程

​	**本节课我们对之前学习过的微程序控制器的相关知识进行一下简单回顾，进而总结出微程序控制器的设计流程。我们在有关微程序控制器的第依次课中介绍了微程序控制器的相关基本概念。**

![image-20250814135926677](https://img.tynote.cn/img/typora/20250814135929296.png#800w)

​	**在了解了上述基本概念后，我们在微程序控制器的第二次课中介绍了微程序控制器的组成，主要包括控制存储器、地址转移逻辑、微地址寄存器。在了解了微程序控制器的组成后，我们在有关微程序控制器的第三次课中介绍了微程序控制器中下一个微地址的产生方法以及其相应的地址转移逻辑的实现。**

![image-20250814142605226](https://img.tynote.cn/img/typora/20250814142606994.png#800w)

​	**下一个微地址的产生方法有两种，这两种方法采用不同的地址转移逻辑来产生下一个微地址。在理解了下址字段法、计数器法以及它们各自的地址转移逻辑后，我们在有关微程序控制器的第四次课中介绍了微指令的设计，例如，这是采用下址字段法设计的微指令格式和采用计数器法设计的微指令格式**

![image-20250814142953492](https://img.tynote.cn/img/typora/20250814142955345.png#800w)

![image-20250814143004827](https://img.tynote.cn/img/typora/20250814143007317.png#800w)

​	

![image-20250814143748140](https://img.tynote.cn/img/typora/20250814143750802.png#800w)

​	**在了解了微指令设计的相关知识后，我们在有关微程序控制器的第五次课中介绍了微程序的设计，例如，这是采用下址字段法的微指令格式设计出的beq指令的微程序和采用计数器法的微指令格式设计出的beq指令的微程序。**

![image-20250814144130010](https://img.tynote.cn/img/typora/20250814144132342.png#800w)

![image-20250814144156176](https://img.tynote.cn/img/typora/20250814144158180.png#800w)

​	**在了解了微程序设计的相关知识后，我们在有关微程序控制器的第六次课中进一步对微指令中操作控制字段的表示方法进行了介绍。**

![image-20250814144334409](https://img.tynote.cn/img/typora/20250814144336891.png#800w)

​	**在理解了微指令中操作控制字段的上述三种表示方法后，我们在有关微程序控制器的第七次课中介绍了水平型微指令和垂直型微指令，并对二者进行了对比。**

![image-20250814144548770](https://img.tynote.cn/img/typora/20250814144551064.png#800w)

​	**在具备了上述有关微程序控制器的全部知识后，接下来我们可以总结出微程序控制器的设计流程。对于前三个步骤，微程序控制器与在其之前介绍的硬布线控制器是基本相同的。** 

![image-20250814145249220](https://img.tynote.cn/img/typora/20250814145250960.png#800w)

![image-20250814145318207](https://img.tynote.cn/img/typora/20250814145320307.png#800w)

## 异常与中断

### 相关基本概念

![image-20250814145650404](https://img.tynote.cn/img/typora/20250814145652814.png#800w)

![image-20250814145955100](https://img.tynote.cn/img/typora/20250814145957496.png#800w)

![image-20250814150023731](https://img.tynote.cn/img/typora/20250814150026425.png#800w)

![image-20250814150203710](https://img.tynote.cn/img/typora/20250814150205906.png#800w)

**缺页，是我们之前在第4章中有关虚拟存储器的多次课中介绍并使用的概念。**

![image-20250814150338957](https://img.tynote.cn/img/typora/20250814150341712.png#800w)

**相信很多同学都进行过程序的单步调试，特别是有过嵌入式系统开发经历的同学，之所以可以实现单步调试，其背后利用的就是自陷异常。**

![image-20250814150955708](https://img.tynote.cn/img/typora/20250814150958017.png#800w)

**机器校验错误是CPU通过其内部监控机制，检测到与其，例如与其自身或密切相关硬件，例如内存、总线、欧肯那根之气相关的致命性、不可纠正的物理错误或数据损坏时，所引发的一种最高优先级异常，例如，由于上述硬件故障导致的Windows系统蓝屏。**

![image-20250814151058490](https://img.tynote.cn/img/typora/20250814151100915.png#800w)

**在后续课程中，为了描述简单，除必要情况，我们将异常，也就是内部中断和外部中断都简称为中断。**

![image-20250814151250631](https://img.tynote.cn/img/typora/20250814151252865.png#800w)

![image-20250814151553695](https://img.tynote.cn/img/typora/20250814151555877.png#800w)

![image-20250814151631064](https://img.tynote.cn/img/typora/20250814151633212.png#800w)

### 异常与中断的处理过程

![image-20250814151745763](https://img.tynote.cn/img/typora/20250814151748433.png#800w)

![image-20250814151852808](https://img.tynote.cn/img/typora/20250814151855519.png#800w)

![image-20250814152554341](https://img.tynote.cn/img/typora/20250814152556447.png#800w)

**所谓中断嵌套，是指在支持中断优先级的系统中，当一个较低优先级的中断服务程序执行过程中，主动重新打开了中断允许，通常是在必要的关键代码之后，此时如果出现了一个更高优先级的中断请求，CPU将暂停当前，也就是较低优先级中断服务程序的执行，保存其上下文，并立即响应处理该更高优先级中断的中断服务程序，处理完毕后，CPU返回并继续执行被暂停的低优先级中断服务程序，最后再返回到主程序。**
