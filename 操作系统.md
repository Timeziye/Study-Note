---
title: 操作系统
author: TimeYe
tags: ["note"]
---



[TOC]

# 计算机系统概述

## 操作系统的基本概念

### 操作系统的概念、功能和目标

![image-20250815202153855](https://img.tynote.cn/img/typora/20250815202153979.png#800w)

#### 概念

![image-20250815204947340](https://img.tynote.cn/img/typora/20250815204947478.png#800w)

**可以发现，用户和操作系统的边界是有一些相连的部分，应用程序和操作系统也会有一些相连的部分，具体原因我们之后会进行进一步解释。**

![image-20250815205248552](https://img.tynote.cn/img/typora/20250815205248734.png#800w)

#### 功能和目标

##### 1️⃣作为系统资源的管理者

​	**操作系统作为软件和硬件的中间层次，是系统资源的一个管理者。此处以用QQ和朋友视频聊天的过程进行举例。可以看到，第一步，我们是通过了这些一层一层的文件夹目录来找到我们的QQ启动程序，那除了$QQ.exe$文件之外，系统当中还有各式各样的其他文件，但是这些文件的组织和管理其实是操作系统在帮我们完成的，所以就这涉及到了操作系统作为系统资源的管理者所要提供的一个功能叫做文件管理的功能。第二步，当我们双击$QQ.exe$的时候，这个程序就可以开始正常的运行，此处补充一个知识，那就是程序在执行之前，其实是需要把这个程序的数据放到内存里面，所以在我们双击打开$QQ.exe$的时候，其实在背后操作系统帮我们做了一件很重要的事情，就是把这个程序的数据从我们的磁盘放入了内存当中，并且这些数据要放入内存中的什么位置，这些其实都是操作系统再帮我们完成的，所以这一步就涉及到了操作系统它所要提供的第二个功能叫做存储器管理或内存管理；那当QQ运行过程当中，其实是需要被CPU进行处理，而什么时候给QQ程序分配CPU资源，是操作系统在背后替我们完成的，因此这就涉及到了第三个功能叫做处理机(CPU)管理；而第四步我们在视频聊天的过程中，肯定需要把摄像头这个设备分配给QQ程序使用，因此像摄像头这一类设备资源也是要由操作系统替我们管理，由操作系统来决定应该要把这些设备分配给哪个程序使用，所以这就涉及到了操作系统要提供的第四个功能叫做设备管理，我们王道书的第二章讲的其实就是处理机(CPU)管理，而第三章讲的是存储器管理，第四章讲的是文件管理，第五章讲的是设备管理。所以其实操作系统这门课在后期我们要重点学习的就是他作为系统资源的管理者要如何设计和实现这些功能。**

![image-20250818183211456](https://img.tynote.cn/img/typora/20250818183218704.png#800w)

##### 2️⃣向上层提供方便易用的服务

​	**在安装了操作系统之后，我们的用户和应用程序不需要直接和硬件打交道，我们只需要告诉操作系统我们想要得到的服务即可，而操作系统会把用户的命令和需求翻译成二进制来告诉硬件，然后由硬件来执行我们想要的这些操作，这其实是一个很典型的封装思想。**

![image-20250818193819298](https://img.tynote.cn/img/typora/20250818193819501.png#800w)

​	**接下来我们看一下操作系统在屏蔽了底层硬件细节之后，对上层提供了哪些方便易用的服务。**

![image-20250818195747871](https://img.tynote.cn/img/typora/20250818195748264.png#800w)

![image-20250818215751906](https://img.tynote.cn/img/typora/20250818215752073.png#800w)

![image-20250818215831294](https://img.tynote.cn/img/typora/20250818215831474.png#800w)

![image-20250818220003401](https://img.tynote.cn/img/typora/20250818220003564.png#800w)

![image-20250818220427078](https://img.tynote.cn/img/typora/20250818220427244.png#800w)



**这也就可以理解为什么用户和操作系统中间有一段相接的部分了，因为用户通过这些方式可以直接地和操作系统进行交互，而应用程序需要通过系统调用的方式，也就是通过程序接口来和操作系统进行交互。**

##### 3️⃣作为最接近硬件的层次

![image-20250818220807791](https://img.tynote.cn/img/typora/20250818220807936.png#800w)

#### 总结

![image-20250818221028320](https://img.tynote.cn/img/typora/20250818221028465.png#800w)

### 操作系统的特征

![image-20250820190518219](https://img.tynote.cn/img/typora/20250820190525375.png#800w)

#### 并发

![image-20250820190557686](https://img.tynote.cn/img/typora/20250820190557842.png#800w)

![image-20250820190751161](https://img.tynote.cn/img/typora/20250820190751408.png#800w)

#### 共享

![image-20250820191917704](https://img.tynote.cn/img/typora/20250820191917858.png#800w)

![image-20250820203636297](https://img.tynote.cn/img/typora/20250820203636467.png#800w)

#### 虚拟

![image-20250820203935501](https://img.tynote.cn/img/typora/20250820203935687.png#800w)

![image-20250820204011255](https://img.tynote.cn/img/typora/20250820204011390.png#800w)

#### 异步

![image-20250820204242050](https://img.tynote.cn/img/typora/20250820204242238.png#800w)

#### 总结

![image-20250820204408487](https://img.tynote.cn/img/typora/20250820204408621.png#800w)

## 操作系统的发展与分类

![image-20250820205049275](https://img.tynote.cn/img/typora/20250820205049431.png#800w)

### 手工操作阶段

![image-20250820205659166](https://img.tynote.cn/img/typora/20250820205659354.png#800w)

### 批处理阶段

#### 单道批处理系统

​	**手工操作阶段，计算机这种昂贵的资源大量时间处于空闲状态，显然是一种很不经济很低效的方式，因此为了解决这个问题，人们发明了单道批处理系统。这个阶段诞生了操作系统的雏形。**

![image-20250820210121475](https://img.tynote.cn/img/typora/20250820210121616.png#800w)

![image-20250820210655185](https://img.tynote.cn/img/typora/20250820210655359.png#800w)

#### 多道批处理系统

​	**为了改进单道批处理系统的缺点，人们又发明了多道批处理系统。这个阶段，操作系统正式诞生。**

![image-20250820211312407](https://img.tynote.cn/img/typora/20250820211312585.png#800w)

#### 分时操作系统

​	**为了实现人机交互，人们又发明了分时操作系统。**

![image-20250820211529978](https://img.tynote.cn/img/typora/20250820211530165.png#800w)

#### 实时操作系统

​	**为了能够优先处理一些紧急任务，人们又发明了实时操作系统。**

![image-20250820211755987](https://img.tynote.cn/img/typora/20250820211756144.png#800w)

#### 其他操作系统

![image-20250820211850962](https://img.tynote.cn/img/typora/20250820211851118.png#800w)

### 总结

![image-20250820211923387](https://img.tynote.cn/img/typora/20250820211923558.png#800w)

## 操作系统的运行环境

### 操作系统的运行机制

![image-20250820212101048](https://img.tynote.cn/img/typora/20250820212101194.png#800w)

![image-20250820212216387](https://img.tynote.cn/img/typora/20250820212216580.png#800w)

#### 内核程序vs应用程序

![image-20250820212615342](https://img.tynote.cn/img/typora/20250820212615642.png#800w)

#### 特权指令vs非特权指令

![image-20250820212824422](https://img.tynote.cn/img/typora/20250820212824658.png#800w)

#### 内核态vs用户态

![image-20250820212958343](https://img.tynote.cn/img/typora/20250820212958568.png#800w)

#### 内核态、用户态的切换

![image-20250820213409328](https://img.tynote.cn/img/typora/20250820213409666.png#800w)

#### 总结

![image-20250820213535374](https://img.tynote.cn/img/typora/20250820213535545.png#800w)

### 中断和异常

![image-20250821105243397](https://img.tynote.cn/img/typora/20250821105243568.png#800w)

#### 中断的作用

![image-20250821105446092](https://img.tynote.cn/img/typora/20250821105446346.png#800w)

#### 中断的类型

![image-20250821105516429](https://img.tynote.cn/img/typora/20250821105516606.png#800w)

![image-20250821105614973](https://img.tynote.cn/img/typora/20250821105615175.png#800w)

![image-20250821105725535](https://img.tynote.cn/img/typora/20250821105725739.png#800w)

​	**外中断例一：时钟部件每隔一个时间(比如50ms)会给CPU发送一个时钟中断信号。当程序1运行了50ms后，时钟部件发来中断信号，进入处理时钟中断的内核程序，处理完后运行程序2，50ms后再次进入中断，然后程序1再运行50ms，如此循环....这也是程序并发执行的原理。**

![image-20250821110108759](https://img.tynote.cn/img/typora/20250821110108975.png#800w)

![image-20250821113428126](https://img.tynote.cn/img/typora/20250821113642772.png#800w)

![image-20250821120812091](https://img.tynote.cn/img/typora/20250821120812283.png#800w)

![image-20250821121041811](https://img.tynote.cn/img/typora/20250821121042034.png#800w)

### 系统调用

![image-20250821143500516](https://img.tynote.cn/img/typora/20250821143500974.png#800w)

![image-20250821143633411](https://img.tynote.cn/img/typora/20250821143633748.png#800w)

![image-20250821143746951](https://img.tynote.cn/img/typora/20250821143747290.png#800w)

![image-20250821144058932](https://img.tynote.cn/img/typora/20250821144059274.png#800w)

![image-20250821150312520](https://img.tynote.cn/img/typora/20250821150312758.png#800w)

​	**假设一个应用程序想要进行系统调用，它在背后需要做什么事情呢？它运行在用户态，然后这个应用程序的各个指令会被CPU依次执行，当它想要发出系统调用的时候，它需要用传参数的指令，给CPU的寄存器当中传递一些必要的参数，比如在CPU的某个寄存器当中放入了参数1，这个参数1是指明了此次要进行的系统调用的类型，比如像Linux系统里面的fork系统调用，传递参数的指令可能会有多条，主要取决于这个系统调用需要传递几个参数，操作系统会通过应用程序提供的这些参数来判断它想要的是哪种类型的服务，当参数都放到了寄存器中后，应用程序会执行一条特殊的指令，叫做陷入指令，这个陷入指令的执行会引发一个内中断，CPU在检测到这个内部中断后，发现这个内部中断信号是由trap指令引起的，于是CPU接下来会暂停运行这个应用程序，转而去执行处理陷入指令的那个处理程序，那这个程序就是系统调用入口程序，显然接下来要执行这个程序属于内核程序，因此它需要在内核态下运行，接下来系统调用入口程序会检查寄存器里面的参数，通过第一个参数它会知道此时这个应用程序它想要的系统调用服务的类型，于是接下来这个系统调用入口程序会调用与特定的系统调用类型所对应的处理程序，然后让该程序上CPU运行，这个系统调用处理程序在执行的时候，就可以根据应用程序传递的其他参数来看它所需要的具体是哪些服务，当这个系统调用被处理完之后，CPU又会转回用户态，然后接着执行之前的这个应用程序。**

![image-20250821152031510](https://img.tynote.cn/img/typora/20250821152031766.png#800w)

![image-20250821152056668](https://img.tynote.cn/img/typora/20250821152056940.png#800w)

![image-20250821152115721](https://img.tynote.cn/img/typora/20250821152115991.png#800w)

![image-20250821152150518](https://img.tynote.cn/img/typora/20250821152150735.png#800w)

![image-20250821152400333](https://img.tynote.cn/img/typora/20250821152400567.png#800w)

![image-20250821152442369](https://img.tynote.cn/img/typora/20250821152442583.png#800w)

## 操作系统体系结构

### 大内核与微内核

![image-20250821153342408](https://img.tynote.cn/img/typora/20250821153342643.png#800w)

#### 操作系统的内核

![image-20250821153429093](https://img.tynote.cn/img/typora/20250821153429434.png#800w)

![image-20250821153548977](https://img.tynote.cn/img/typora/20250821153549224.png#800w)

​	**由于这些管理工作更多的是对数据结构的操作，并不会直接涉及硬件。所以有的操作系统并不把这些管理功能放在内核中，而只在内核当中保留与硬件接触最紧密的这些部分，因此这就引出了两种截然不同的内核设计的方法，把所有的功能都包含在操作系统内核当中的这种结构就叫大内核，而如果内核当中只保留与硬件关系最紧密的这些部分，那么这种内核就叫做微内核。需要注意的是，如果采用的是微内核结构，那么属于内核的这些功能是需要运行在内核态的，而不属于内核的上面的这些功能就需要运行在用户态，这会对系统性能造成一定的影响。**

![image-20250821154211936](https://img.tynote.cn/img/typora/20250821154212311.png#800w)

​	**进程管理、存储管理、设备管理这些服务都需要得到内核的支持，因而在使用这些服务的时候会涉及到CPU的用户态和内核态的转换，此处变态为简要描述。**

![image-20250821154552637](https://img.tynote.cn/img/typora/20250821154552902.png#800w)

#### 总结

![image-20250821154815702](https://img.tynote.cn/img/typora/20250821154815906.png#800w)

### 分层结构、模块化与外核

![image-20250821155027020](https://img.tynote.cn/img/typora/20250821155027242.png#800w)

![image-20250821155147655](https://img.tynote.cn/img/typora/20250821155147876.png#800w)

#### 分层结构

​	**最底层是硬件，最高层是用户接口，每一层只能调用相邻的、更低的一层，也就是外层只能调用相邻内层，而不能跨层调用。**

![image-20250821213635823](https://img.tynote.cn/img/typora/20250821213636047.png#800w)

#### 模块化

![image-20250821215052129](https://img.tynote.cn/img/typora/20250821215052348.png#800w)

**模块间的接口定义未必合理、实用，这是因为各模块的接口已经规定好，但是在开发过程中可能发现，其他模块可能还需要用到新的功能，所以各个模块间的相互调用会比较多，因此在开发各个模块的时候，接口的定义可能比较难。**

**模块间相互依赖，更难调试和验证，这是因为调用过程中如果出现问题比较难定位到是具体哪个模块出现了问题。**

#### 大内核、微内核

![image-20250821220101815](https://img.tynote.cn/img/typora/20250821220102233.png#800w)

**大内核结构下，进程管理、存储管理、设备管理等服务之间可以直接相互调用，而微内核结构下，进程管理若要调用存储管理服务，需要通过消息传递的方式，让微内核来协助各个模块间的调用和返回。显然前者要比后者效率更高。**

#### 外核

![image-20250821220544748](https://img.tynote.cn/img/typora/20250821220544962.png#800w)

**不虚拟、不抽象的硬件资源，比如对于存储空间来说，我们通常给文件或者应用程序分配的内存空间，逻辑上是连续的，但在硬盘中实际上是离散的，这就是经过虚拟化、经过抽象的资源，相对应的，不虚拟、不抽象的硬盘资源就是在磁盘中也是连续的一片内存空间，减少磁头移动举例，从而提升性能。**

**减少了虚拟硬件资源的“映射层，提升效率，由于分配的空间是一片连续的物理空间，不需要像之前那样，先通过虚拟地址，查页表，再转化为物理地址繁琐的映射操作，直接访问即可，从而提升效率。**

**由于有的进程申请的是虚拟空间，需要映射，有的进程申请的是物理空间，不需要映射，从而降低了系统的一致性。**

## 操作系统引导

![image-20250821222240213](https://img.tynote.cn/img/typora/20250821222240562.png#800w)

![image-20250821222555636](https://img.tynote.cn/img/typora/20250821222555893.png#800w)

![image-20250821222805021](https://img.tynote.cn/img/typora/20250821222805230.png#800w)



![image-20250821224237172](https://img.tynote.cn/img/typora/20250821224237378.png#800w)

![image-20250821224339095](https://img.tynote.cn/img/typora/20250821224339323.png#800w)

## 虚拟机

![image-20250821225111755](https://img.tynote.cn/img/typora/20250821225112083.png#800w)

![image-20250821231246774](https://img.tynote.cn/img/typora/20250821231310469.png#800w)

![image-20250821231333163](https://img.tynote.cn/img/typora/20250821231333397.png#800w)

![image-20250821231549941](https://img.tynote.cn/img/typora/20250821231550143.png#800w)

![image-20250821231824974](https://img.tynote.cn/img/typora/20250821231825203.png#800w)

# 进程与线程

## 进程和线程

### 进程的概念、组成、特征

![image-20250822104337791](https://img.tynote.cn/img/typora/20250822104337976.png#800w)

#### 进程的概念

![image-20250822104444306](https://img.tynote.cn/img/typora/20250822104444806.png#800w)

![image-20250822104542468](https://img.tynote.cn/img/typora/20250822104542891.png#800w)

#### 进程的组成

![image-20250822104852802](https://img.tynote.cn/img/typora/20250822104853095.png#800w)

![image-20250822105048826](https://img.tynote.cn/img/typora/20250822105049035.png#800w)



![image-20250822105148487](https://img.tynote.cn/img/typora/20250822105148840.png#800w)

![image-20250822105233766](https://img.tynote.cn/img/typora/20250822105234017.png#800w)

![image-20250822110213902](https://img.tynote.cn/img/typora/20250822110214129.png#800w)

![image-20250822105750582](https://img.tynote.cn/img/typora/20250822105750963.png#800w)

#### 进程的特征

![image-20250822105851872](https://img.tynote.cn/img/typora/20250822105852118.png#800w)

#### 总结

![image-20250822110002803](https://img.tynote.cn/img/typora/20250822110003056.png#800w)

**注意，在引入线程之后，进程不再是独立接受调度的基本单位，但仍然是获得资源的基本单位。**

### 进程的状态与转换

![image-20250822110133584](https://img.tynote.cn/img/typora/20250822110133822.png#800w)

#### 进程的状态

![image-20250822110404196](https://img.tynote.cn/img/typora/20250822110404413.png#800w)

![image-20250822110959687](https://img.tynote.cn/img/typora/20250822111000108.png#800w)

![image-20250822111056179](https://img.tynote.cn/img/typora/20250822111056543.png#800w)

​	**接下来，打印机为别的进程服务已经结束，此时空闲下来，于是就可以分配给进程2，所以当操作系统把打印机这个资源分配给进程2的时候，进程2等待的时间其实就已经发生了，此时操作系统会让进程2从阻塞态再次回到就绪态。也就是说，当它等待的事件发生之后，这个进程就有了再次上处理机运行的条件。**

​	**假设此时在CPU上运行的进程1已经结束了，它会发出一个exit的系统调用，这个系统调用其实就是请求操作系统终止这个进程，此时该进程进入终止态。**

![image-20250822111658647](https://img.tynote.cn/img/typora/20250822111658891.png#800w)

**当终止进程的工作完成之后，这个进程就彻底消失了。**

#### 状态间的转换

![image-20250822114710109](https://img.tynote.cn/img/typora/20250822114710376.png#800w)

![image-20250822114919423](https://img.tynote.cn/img/typora/20250822114919686.png#800w)

#### 进程的组织方式

![image-20250822115218284](https://img.tynote.cn/img/typora/20250822115218517.png#800w)

![image-20250822115328764](https://img.tynote.cn/img/typora/20250822115329022.png#800w)

![image-20250822115356488](https://img.tynote.cn/img/typora/20250822115356698.png#800w)

#### 总结

![image-20250822115516185](https://img.tynote.cn/img/typora/20250822115516447.png#800w)

### 进程控制

#### 什么是进程控制

![image-20250822173150220](https://img.tynote.cn/img/typora/20250822173150560.png#800w)

![image-20250822173233452](https://img.tynote.cn/img/typora/20250822173233688.png#800w)

#### 如何实现进程控制

![image-20250822173355857](https://img.tynote.cn/img/typora/20250822173356119.png#800w)

![image-20250822173513375](https://img.tynote.cn/img/typora/20250822173513782.png#800w)

​	**假设现在PCB2的state已经被设为1了，而在完成这一步后突然检测到一个中断信号，那么系统肯定要对这个中断进行处理，而此时PCB2的state=1，也就是说从state变量来看，PCB2这个进程它的状态是就绪态，但是从它所处的队列来看，这个PCB2此时还是在阻塞队列当中，所以就导致了PCB2当中这个变量所表示的状态和它所处的队列两个信息不一致，这可能会影响操作系统进行后续的一些别的工作，可能会让系统出错，这就是为什么进程的转换要一气呵成的原因，利用这个特性，进而选用原语来实现。**

![image-20250822174102996](https://img.tynote.cn/img/typora/20250822174103538.png#800w)

#### 如何实现原语的原子性

![image-20250822174251426](https://img.tynote.cn/img/typora/20250822174251727.png#800w)

​	**当它执行流关中断指令之后，CPU就不再例行检查中断信号了，所以接下来CPU会继续往下执行，假如在执行指令a的过程中有一个外部中断信号到来了，但是此时不会例行检查中断信号，而是会继续往下处理，一直到CPU执行了开中断指令之后，它才会恢复每执行完一条指令就去例行检查中断信号的习惯，此时发现之前有一个中断信号未进行处理，所以这个时候CPU才会去转向执行中断处理程序。**

![image-20250822174732449](https://img.tynote.cn/img/typora/20250822174732704.png#800w)

![image-20250822174847668](https://img.tynote.cn/img/typora/20250822174847936.png#800w)

#### 进程控制相关的原语

![image-20250822175300553](https://img.tynote.cn/img/typora/20250822175300808.png#800w)

**作业是指此时还放在外存中没有投入运行的程序。**

![image-20250822175516306](https://img.tynote.cn/img/typora/20250822175516612.png#800w)

![image-20250822175637322](https://img.tynote.cn/img/typora/20250822175637601.png#800w)

![image-20250822180450804](https://img.tynote.cn/img/typora/20250822180451058.png#800w)

​	**保存和恢复运行环境的过程如下图所示，假设某个进程的指令执行到一半的时候，另一个程序开始上CPU运行，那么此时就需要保存该进程的运行环境，于是寄存器中与之相关的必要的信息如运算结果等会被保存在其PCB当中，当它再次上CPU运行时，就可以通过PCB来恢复它原来的运行环境。**

![image-20250822180552028](https://img.tynote.cn/img/typora/20250822180552286.png#800w)

![image-20250822180648901](https://img.tynote.cn/img/typora/20250822180649185.png#800w)

![image-20250822181029232](https://img.tynote.cn/img/typora/20250822181029519.png#800w)

#### 总结

![image-20250822181059344](https://img.tynote.cn/img/typora/20250822181059590.png#800w)

### 进程通信

![image-20250822181406248](https://img.tynote.cn/img/typora/20250822181406474.png#800w)

​	**由于进程不可以访问其他进程的地址空间，因此必须要有操作系统的支持才可以完成进程之间的通信。**

![image-20250822182128617](https://img.tynote.cn/img/typora/20250822182128894.png#800w)

#### 共享存储



![image-20250822184121368](https://img.tynote.cn/img/typora/20250822184121617.png#800w)

![image-20250822184322019](https://img.tynote.cn/img/typora/20250822184322295.png#800w)

#### 消息传递

![image-20250822184454255](https://img.tynote.cn/img/typora/20250822184454752.png#800w)

​	**直接通信就是进程P首先在自己的地址空间处完善好消息之后(即完成其中需要格式化的信息)，通过发送原语将该消息挂到进程Q的消息队列中，然后进程Q通过接收原语检查消息队列并找到来自进程P发送的消息，然后从操作系统的内核区复制到进程Q的用户区。**

![image-20250822185022479](https://img.tynote.cn/img/typora/20250822185022853.png#800w)

​	**间接通信：如果进程P和进程Q之间要进行通信，则进程P可以通过系统调用申请一个信箱，也可以申请多个，然后在自己的地址空间里面完善好消息的内容，然后通过发送原语指明要发送的信箱，并没有指明要发送给哪个进程，然后进程Q通过接收原语指明要从哪个信箱接收消息，然后从操作系统复制到自己的进程中。**

![image-20250822185550590](https://img.tynote.cn/img/typora/20250822185551100.png#800w)

#### 管道通信

​	**管道通信和共享通信类似，都开辟了一块共享区域，但是共享通信的共享存储区中数据的存放是任意的，不受限制的，而管道通信的管道本质上是一个循环队列，具有先进先出的特性，且一段时间内数据只能单向流通，如果要同时双向通信，则需要设置两个管道。**

![image-20250822191541282](https://img.tynote.cn/img/typora/20250822191541537.png#800w)

![image-20250822191321920](https://img.tynote.cn/img/typora/20250822191322278.png#800w)

#### 总结

![image-20250822192047733](https://img.tynote.cn/img/typora/20250822192048094.png#800w)

![image-20250822192151124](https://img.tynote.cn/img/typora/20250822192151429.png#800w)

### 信号

![image-20250823180514634](https://img.tynote.cn/img/typora/20250823180514937.png#800w)

#### 信号的作用

![image-20250823180916272](https://img.tynote.cn/img/typora/20250823180916607.png#800w)

![image-20250823180941816](https://img.tynote.cn/img/typora/20250823180942318.png#800w)

#### 信号的发送与保存

![image-20250823181806631](https://img.tynote.cn/img/typora/20250823181806980.png#800w)

**虽然进程P2和内核进程都给进程P1发送了信号序列为1的这个信号，但是对于进程P1来说，它只能接受一个信号1，后到达的信号1会被简单地丢弃，并且从进程P1的位向量当中是无法区分出这个信号到底是由哪个进程发送过来的。另外，除了kill函数外，还有其他函数也可以用于发送信号，只不过kill函数是最灵活最常用的。**

**进程之间允许发送的信号类型是有限制的，比如信号9只能用于父进程杀子进程，，如果每个进程都可以随意地杀掉其他进程的话，那整个系统就会产生很多错误。当然，如果是内核进程给用户进程发送信号的话就没什么限制了，因为操作系统内核拥有最高权限。**

#### 信号的处理

![image-20250823184037822](https://img.tynote.cn/img/typora/20250823184038106.png#800w)

**具体要阻塞哪个信号由进程决定和处理。**

![image-20250823184545079](https://img.tynote.cn/img/typora/20250823184545564.png#800w)

​	**每个进程都可以有自己自定义的信号处理程序，只作用于自身，如果没有自定义信号处理程序，则执行操作系统默认的信号处理程序。**

![image-20250823184834741](https://img.tynote.cn/img/typora/20250823184835128.png#800w)

#### 信号与异常的关系

![image-20250823185035023](https://img.tynote.cn/img/typora/20250823185035354.png#800w)

#### 总结

![image-20250823185226036](https://img.tynote.cn/img/typora/20250823185226420.png#800w)



### 线程的概念与特点

![image-20250823185846976](https://img.tynote.cn/img/typora/20250823185847313.png#800w)

#### 线程概念及引入线程的原因

![image-20250823190136956](https://img.tynote.cn/img/typora/20250823190137234.png#800w)

![image-20250823190224132](https://img.tynote.cn/img/typora/20250823190224735.png#800w)

![image-20250823190317906](https://img.tynote.cn/img/typora/20250823190318320.png#800w)

#### 引入线程带来的变化

![image-20250823190439422](https://img.tynote.cn/img/typora/20250823190439760.png#800w)

#### 线程的属性

![image-20250823190749541](https://img.tynote.cn/img/typora/20250823190749800.png#800w)

### 线程的实现方式和多线程模型

![image-20250823191424845](https://img.tynote.cn/img/typora/20250823191425138.png#800w)

#### 线程的实现方式

​	**用户级线程：当时的线程是由线程库实现的，也就是说，操作系统的视角看到的其实依然只有进程，但是程序员写的这些应用程序当中，可以使用线程库来实现多个线程并发执行。**

​	**如果要让视频、文字聊天、传送文件三件事情并发运行，在不支持线程的系统当中，我们可以分别建立三个进程来完成这三件事情。**

![image-20250823192001645](https://img.tynote.cn/img/typora/20250823192002030.png#800w)

​	**由于每个事情都是用循环来一遍一遍地不断执行的，所以我们可以用下图的方式来实现，让这三段代码并发的运行，我们用一个while循环让它一直不断的循环，由于程序进行while循环的速度是非常快的，所以我们可以把这三段代码看作是并发的运行的代码，它们分别处理了不同的事情。单纯从代码角度看，一个线程就是一段代码逻辑。**

![image-20250823192418540](https://img.tynote.cn/img/typora/20250823192419113.png#800w)

![image-20250823192613184](https://img.tynote.cn/img/typora/20250823192613558.png#800w)

![image-20250823192757916](https://img.tynote.cn/img/typora/20250823192758218.png#800w)

**在用户级线程情况下，进程仍然是CPU调度的基本单位，操作系统是给进程分配CPU时间的，所以即便是多核CPU，由于进程才是CPU调度的基本单位，因此这个进程只能分配给一个CPU核心，所以这些线程并不能并行地运行在多核CPU上。**

​	**内核级线程：由操作系统支持的线程，操作系统的视角看到的是线程，不再是进程。**

![image-20250823193224861](https://img.tynote.cn/img/typora/20250823193225293.png#800w)

![image-20250823193419175](https://img.tynote.cn/img/typora/20250823193419519.png#800w)

#### 多线程模型

​	**有没有可能将两种方式结合起来呢？有，如果在支持内核级线程的操作系统中引入线程库，我们就可以实现把若干个用户级线程映射到某一个内核级线程这样的事情。根据用户级线程和内核级线程的映射关系，又可以划分为多种多线程模型。**

![image-20250823193814752](https://img.tynote.cn/img/typora/20250823193815232.png#800w)

![image-20250823204817016](https://img.tynote.cn/img/typora/20250823204817625.png#800w)

**因为只有内核级线程才是CPU的分配单位，如果一个进程只对应一个内核级线程的话，那么 在同一时刻，这个进程肯定只能被分配一个CPU核心，当然，如果给这个进程分配多个内核级线程的话，那么在多核CPU环境下，这些内核级线程是可以并发运行的。考试中多对一模型默认一个进程只被分配了一个内核级线程。**

![image-20250823205016515](https://img.tynote.cn/img/typora/20250823205016981.png#800w)

#### 总结

![image-20250823205047020](https://img.tynote.cn/img/typora/20250823205047371.png#800w)

### 线程的状态与转换

![image-20250823205650252](https://img.tynote.cn/img/typora/20250823205650492.png#800w)

#### 状态与转换

​	**线程的状态与转换几乎和进程的状态与转换一模一样。并且线程的状态我们通常只关注最核心最主要的的三个状态，也就是就绪态、运行态、阻塞态。**

![image-20250823205725540](https://img.tynote.cn/img/typora/20250823205725789.png#800w)

#### 组织与控制

![image-20250823210524762](https://img.tynote.cn/img/typora/20250823210525032.png#800w)

**线程中还要保存其运行状态，甚至如果是阻塞态，还会保留其阻塞的具体原因。**

**把多个线程的TCB组织起来就可以形成一个线程表，组织的方式有很多种，比如每个进程设置一张线程表，或者系统中所有线程组成一张线程表，当然也可以按照线程状态的不同组成不同的线程表，不同的系统可以采取不同的策略，这就是线程的组织。所谓线程的控制吗，就是让线程在各种状态之间来回切换。**

## CPU调度

### 调度的概念、层次

![image-20250823212154955](https://img.tynote.cn/img/typora/20250823212155230.png#800w)

#### 调度的基本概念

![image-20250823212315345](https://img.tynote.cn/img/typora/20250823212315962.png#800w)

#### 调度的三个层次

![image-20250823212515846](https://img.tynote.cn/img/typora/20250823212516587.png#800w)

![image-20250823212628919](https://img.tynote.cn/img/typora/20250823212629441.png#800w)

![image-20250823212832433](https://img.tynote.cn/img/typora/20250823212833031.png#800w)

#### 进程的挂起态与七状态模型

![image-20250823214746512](https://img.tynote.cn/img/typora/20250823214747166.png#800w)

**处于阻塞挂起的进程，当它等待的阻塞事件发生的时候，这个进程就会直接从阻塞挂起状态转换为就绪挂起。而有的时候当一个进程处于运行态，运行结束之后，可能这个进程下处理机的时候，就会被直接放到外存当中，让它进入就绪挂起的状态；而有的时候，一个处于创建态的进程，当它创建结束之后，创建完PCB之后，有可能出现内存空间不够的状况，这种情况下有可能处于创建态的进程之后会先进入到一个就绪挂起的状态**

#### 三层调度的联系、对比

![image-20250823215239534](https://img.tynote.cn/img/typora/20250823215239927.png#800w)

#### 总结

![image-20250823215537533](https://img.tynote.cn/img/typora/20250823215537858.png#800w)

### 进程调度的时机、切换与过程、方式

![image-20250823220228448](https://img.tynote.cn/img/typora/20250823220228751.png#800w)

#### 进程调度的时机

![image-20250823222244323](https://img.tynote.cn/img/typora/20250823222244779.png#800w)

![image-20250823221912677](https://img.tynote.cn/img/typora/20250823221912983.png#800w)

![image-20250823222100633](https://img.tynote.cn/img/typora/20250823222101244.png#800w)

![image-20250823222014864](https://img.tynote.cn/img/typora/20250823222015221.png#800w)

#### 进程调度的方式

![image-20250823223044390](https://img.tynote.cn/img/typora/20250823223044705.png#800w)

#### 进程的切换与过程

![image-20250823224210185](https://img.tynote.cn/img/typora/20250823224210527.png#800w)

#### 总结

![image-20250823224327760](https://img.tynote.cn/img/typora/20250823224328121.png#800w)

### 调度器和闲逛进程

#### 调度器/调度程序

![image-20250823225847130](https://img.tynote.cn/img/typora/20250823225847449.png#800w)

#### 闲逛进程

![image-20250823230106495](https://img.tynote.cn/img/typora/20250823230106861.png#800w)

### 调度算法的评价指标

![image-20250824192520792](https://img.tynote.cn/img/typora/20250824192521353.png#800w)

#### CPU利用率

![image-20250824192633154](https://img.tynote.cn/img/typora/20250824192633868.png#800w)

#### 系统吞吐量

![image-20250824192723046](https://img.tynote.cn/img/typora/20250824192723335.png#800w)

#### 周转时间

![image-20250824192936729](https://img.tynote.cn/img/typora/20250824192937380.png#800w)

![image-20250824193100257](https://img.tynote.cn/img/typora/20250824193100915.png#800w)

#### 等待时间

![image-20250824193328089](https://img.tynote.cn/img/typora/20250824193328822.png#800w)

**平均等待时间就是所有作业的等待时间或者所有进程的等待时间除以进程或者作业的总数。**

#### 响应时间

![image-20250824193508638](https://img.tynote.cn/img/typora/20250824193509079.png#800w)

#### 总结

![image-20250824193551933](https://img.tynote.cn/img/typora/20250824193552266.png#800w)

### 调度算法 1



![image-20250824193818706](https://img.tynote.cn/img/typora/20250824193818989.png#800w)

#### 先来先服务(FCFS)

![image-20250824194602467](https://img.tynote.cn/img/typora/20250824194603109.png#800w)

![image-20250824194424492](https://img.tynote.cn/img/typora/20250824194425191.png#800w)

#### 短作业优先(SJF/SPF)

![image-20250824200002888](https://img.tynote.cn/img/typora/20250824200003278.png#800w)

​	**0时刻，当前已到达的进程只有P1，因此先运行P1，P1运行完后此时时刻为7，P2、P3、P4均已到达，所以先运行最短的P3，接下来P2和P4运行时间相同，P2先到达，先运行P2，最后运行P4。**



![image-20250824195039844](https://img.tynote.cn/img/typora/20250824195040249.png#800w)

![image-20250824195508440](https://img.tynote.cn/img/typora/20250824195509344.png#800w)

![image-20250824195613107](https://img.tynote.cn/img/typora/20250824195613792.png#800w)

![image-20250824195809773](https://img.tynote.cn/img/typora/20250824195810177.png#800w)

#### 高响应比优先(HRRN)

![image-20250824221933988](https://img.tynote.cn/img/typora/20250824221934541.png#800w)

![image-20250824200119613](https://img.tynote.cn/img/typora/20250824200120003.png#800w)

![image-20250824221816274](https://img.tynote.cn/img/typora/20250824221816765.png#800w)

#### 总结

![image-20250824222036751](https://img.tynote.cn/img/typora/20250824222037143.png#800w)

### 调度算法2

![image-20250824222336844](https://img.tynote.cn/img/typora/20250824222337378.png#800w)

#### 时间片轮转

![image-20250824230006740](https://img.tynote.cn/img/typora/20250824230007223.png#800w)

​	**时间片大小为2。**

![image-20250824224908432](https://img.tynote.cn/img/typora/20250824224908794.png#800w)

![image-20250824225109830](https://img.tynote.cn/img/typora/20250824225110356.png#800w)

![image-20250824225140237](https://img.tynote.cn/img/typora/20250824225140700.png#800w)

​	**时间片大小为5。**

![image-20250824225352678](https://img.tynote.cn/img/typora/20250824225353362.png#800w)

![image-20250824225608419](https://img.tynote.cn/img/typora/20250824225609198.png#800w)

![image-20250824225849014](https://img.tynote.cn/img/typora/20250824225849794.png#800w)

#### 优先级调度算法

![image-20250824230754611](https://img.tynote.cn/img/typora/20250824230755004.png#800w)

![image-20250824230312444](https://img.tynote.cn/img/typora/20250824230313348.png#800w)

![image-20250824230446189](https://img.tynote.cn/img/typora/20250824230446709.png#800w)

![image-20250824230710274](https://img.tynote.cn/img/typora/20250824230710711.png#800w)

#### 多级反馈队列算法

![image-20250824231924293](https://img.tynote.cn/img/typora/20250824231924833.png#800w)

![image-20250824230827187](https://img.tynote.cn/img/typora/20250824230827682.png#800w)

- 完整过程

<video src="https://img.tynote.cn/img/typora/20250824233032872.mp4" width="720" height="405" preload="none" controls>            </video>

 

#### 总结

![image-20250824232455947](https://img.tynote.cn/img/typora/20250824232456494.png#800w)

### 多级队列调度算法

![image-20250827210807262](https://img.tynote.cn/img/typora/20250827210814649.png#800w)

### 多处理机调度

![image-20250827210950328](https://img.tynote.cn/img/typora/20250827210950606.png#800w)

#### 单vs多CPU调度

![image-20250827211057746](https://img.tynote.cn/img/typora/20250827211058272.png#800w)

#### 负载均衡、处理机亲和性

![image-20250827211240178](https://img.tynote.cn/img/typora/20250827211240503.png#800w)

#### 方案一公共就绪队列

​	**CPU空闲时就会访问就绪队列，从中调度程序，同时，CPU对就绪队列的访问是互斥的，避免同一时间内不同CPU调度和运行同一个程序。**

![image-20250827211836223](https://img.tynote.cn/img/typora/20250827211836543.png#800w)

#### 方案二私有就绪队列

​	**在该方案中，若涉及进程迁移，则会牺牲一些处理机亲和性，但程序员也可采用徐通调用的方式去保证硬亲和。**

![image-20250827212139854](https://img.tynote.cn/img/typora/20250827212140157.png#800w)

![image-20250827212222655](https://img.tynote.cn/img/typora/20250827212223184.png#800w)

![image-20250827212326572](https://img.tynote.cn/img/typora/20250827212326910.png#800w)

#### 总结

![image-20250827212624790](https://img.tynote.cn/img/typora/20250827212625204.png#800w)

## 同步与互斥

### 同步与互斥的基本概念

![image-20250827212757334](https://img.tynote.cn/img/typora/20250827212757629.png#800w)

#### 进程同步

![image-20250827213131691](https://img.tynote.cn/img/typora/20250827213132161.png#800w)

![image-20250827213230347](https://img.tynote.cn/img/typora/20250827213230693.png#800w)

#### 进程互斥

![image-20250827213356268](https://img.tynote.cn/img/typora/20250827213356732.png#800w)

![image-20250827213550397](https://img.tynote.cn/img/typora/20250827213550873.png#800w)

![image-20250827213800364](https://img.tynote.cn/img/typora/20250827213800816.png#800w)

#### 总结

![image-20250827213929220](https://img.tynote.cn/img/typora/20250827213929762.png#800w)

### 进程互斥的软件实现方法

![image-20250827214236328](https://img.tynote.cn/img/typora/20250827214236671.png#800w)

#### 进程不互斥的后果

![image-20250827214420959](https://img.tynote.cn/img/typora/20250827214421245.png#800w)

#### 单标志法

![image-20250827221000177](https://img.tynote.cn/img/typora/20250827221000474.png#800w)

![image-20250827221207761](https://img.tynote.cn/img/typora/20250827221208098.png#800w)

#### 双标志先检查法

​	**先检查有没有要使用临界资源的进程，后表示自己需要使用临界资源的意愿，即上锁。**

![image-20250827221942600](https://img.tynote.cn/img/typora/20250827221943102.png#800w)

![image-20250827222120886](https://img.tynote.cn/img/typora/20250827222121210.png#800w)

#### 双标志后检查法

​	**先表达要使用临界资源的意愿，即上锁，然后再检查其他进程当前是否要使用临界资源。**

![image-20250827222304119](https://img.tynote.cn/img/typora/20250827222304692.png#800w)

![image-20250827222342624](https://img.tynote.cn/img/typora/20250827222342980.png#800w)

#### Peterson算法

![image-20250827223159799](https://img.tynote.cn/img/typora/20250827223200172.png#800w)

![image-20250827223259220](https://img.tynote.cn/img/typora/20250827223259727.png#800w)

#### 总结

![image-20250827223432665](https://img.tynote.cn/img/typora/20250827223433071.png#800w)

### 进程互斥的硬件实现方法

![image-20250830103944283](https://img.tynote.cn/img/typora/20250830103951798.png#800w)

#### 中断屏蔽方法

![image-20250830104132510](https://img.tynote.cn/img/typora/20250830104132994.png#800w)

#### TestAndSet指令

![image-20250830104901210](https://img.tynote.cn/img/typora/20250830104901534.png#800w)

#### Swap指令

![image-20250830105518514](https://img.tynote.cn/img/typora/20250830105518873.png#800w)

#### 总结

![image-20250830105600446](https://img.tynote.cn/img/typora/20250830105600862.png#800w)

### 互斥锁

![image-20250830105922070](https://img.tynote.cn/img/typora/20250830105922579.png#800w)

![image-20250830110033935](https://img.tynote.cn/img/typora/20250830110034244.png#800w)

### 信号量机制

![image-20250830110239411](https://img.tynote.cn/img/typora/20250830110239889.png#800w)

![image-20250830111259190](https://img.tynote.cn/img/typora/20250830111259536.png#800w)

#### 整型信号量

![image-20250830112712417](https://img.tynote.cn/img/typora/20250830112712800.png#800w)

​	**上图中的wait(S)和signal(S)原语并不满足“让权等待”，在黑皮书《操作系统概念》中写到：wait(S)直接使用while循环会卡住忙等待，改进方法是在wait(S)里面让进程调用sleep(S)阻塞自己，阻塞操作将一个进程放到与信号量相关的等待队列中，并且将该进程切换为等待状态，然后控制转到CPU调度程序，以便选择执行另一个进程。等待信号量S而阻塞的进程，在其他进程执行操作signal(S)后，应被重新执行，进程的重新执行是通过wakeup()来进行的，它将进程从等待状态改为就绪状态，然后进程被添加到就绪队列（取决于CPU调度算法，CPU可能会也可能不会从正在运行的进程切换到新的就绪进程），从而实现“让权等待”，实际上就是下面的记录型信号量。**

#### 记录型信号量

![image-20250830120749238](https://img.tynote.cn/img/typora/20250830120749630.png#800w)

​	**假设有2台打印机，则初始时S.value=2，等待队列S.L为空，接下来P0、P1、P2、P3进程访问临界资源，因为只有两台打印机，所以P0、P1申请并使用到了打印机，而P2、P3进入等待队列，等待某个打印机被释放后，它们被唤醒转为就绪态。**

![image-20250830121450401](https://img.tynote.cn/img/typora/20250830121450733.png#800w)

​	**此时CPU正在进程P0，服务完后value++变为-1，value≤0，所以唤醒等待队列中的进程P2，并将刚释放的打印机资源分配给P2，CPU接着为P2服务。**

![image-20250830122126226](https://img.tynote.cn/img/typora/20250830122126727.png#800w)

​	**同理，进程P2释放打印机资源后，此时value=0，唤醒等待队列中的进程P3，并将打印机资源分配给P3，然后CPU接着为P3服务。**

![image-20250830122336199](https://img.tynote.cn/img/typora/20250830122336560.png#800w)

​	**P3进程服务完后回收打印机资源，此时CPU服务进程P1，服务完后回收打印机资源，此时value=2，所有进程都已服务完。**

![image-20250830134249699](https://img.tynote.cn/img/typora/20250830134250219.png#800w)

![image-20250830134417358](https://img.tynote.cn/img/typora/20250830134417970.png#800w)

#### 总结

![image-20250830134622615](https://img.tynote.cn/img/typora/20250830134623126.png#800w)

### 用信号量实现进程互斥、同步、前驱关系

![image-20250830134843961](https://img.tynote.cn/img/typora/20250830134844295.png#800w)

#### 信号量机制实现进程互斥

![image-20250830135719443](https://img.tynote.cn/img/typora/20250830135719976.png#800w)

**`semaphore mutex = 1;` 实际等价于 `semaphore mutex = {1, NULL};`，既初始化了 `value`，也保证了等待队列 `L` 是安全的初始值（空队列）。即赋值时依次对结构体成员变量赋值，若未赋值，则默认为0或null。**

#### 信号量机制实现进程同步

![image-20250830141212583](https://img.tynote.cn/img/typora/20250830141212934.png#800w)

![image-20250830141442386](https://img.tynote.cn/img/typora/20250830141442925.png#800w)

#### 信号量机制实现前驱关系

![image-20250830141806505](https://img.tynote.cn/img/typora/20250830141806866.png#800w)

#### 总结

![image-20250830143007506](https://img.tynote.cn/img/typora/20250830143007874.png#800w)

### 生产者-消费者问题

#### 问题及实现

![image-20250830143722468](https://img.tynote.cn/img/typora/20250830143723036.png#800w)

**当消费者从缓冲区取走产品(数据)之后，如果此时有生产者是处于阻塞态的，那么消费者进程应该把生产者进程唤醒，使其重新回到就绪态，不过生产者只是回到了就绪态，并不意味着该生产者进程会立即往缓冲区写数据。**

**缓冲区必须作为临界资源互斥访问，否则可能出现多个生产者往缓冲区同一块地方写数据，从而导致出现数据覆盖的问题。**

![image-20250830144303866](https://img.tynote.cn/img/typora/20250830144304219.png#800w)

**消费者消费之前必须确认有产品，生产者生产之前必须确认缓冲区没满，即这两个事件中是有前后关系约束的，遵循上节课所学的“前V后P”原则。**

![image-20250830144821563](https://img.tynote.cn/img/typora/20250830144822114.png#800w)

**初始时没有产品，所以产品数量full=0，空闲缓冲区数量empty=n。同时，消费者消费后可以释放一个空闲缓冲区，而生产者生产后可以释放一个产品。**

![image-20250830145438043](https://img.tynote.cn/img/typora/20250830145438502.png#800w)

**此处不必纠结为什么不在生产产品前进行P(empty)操作，我们只需要严格按照“前V后P”原则，知道在“把产品放入缓冲区之前”要执行P(empty)操作，必须在放之前确认有空闲缓冲区即可。**

**而互斥信号量的PV操作必须在访问临界资源，也就是缓冲区前后执行。**

![image-20250830150532009](https://img.tynote.cn/img/typora/20250830150532381.png#800w)

**逻辑上，生产一个产品和使用一个产品是可以放到PV操作之间的，但是这会导致临界区代码增多，从而导致上锁时间变长，影响系统性能，因此并不建议这么做。**

#### 总结

![image-20250830150636319](https://img.tynote.cn/img/typora/20250830150636686.png#800w)

### 多生产者-多消费者问题

#### 问题及实现

![image-20250830150848530](https://img.tynote.cn/img/typora/20250830150849030.png#800w)

![image-20250830151251499](https://img.tynote.cn/img/typora/20250830151252145.png#800w)

**初始化信号量，互斥信号量mutex=1，表示初始时可以访问临界资源盘子的名额为1，aapple=0，orange=0，表示初始时盘子中没有这两种水果，plate=1，表示初始时有一个空盘子。**

​	**父亲母亲需要在放水果之前检查盘子是否为空，儿子女儿需要在拿水果之前检查盘子中是否有水果，同时，访问临界资源盘子时应互斥访问，且实现互斥的P操作一定要在实现同步的P操作之后。**

![image-20250830152106373](https://img.tynote.cn/img/typora/20250830152106883.png#800w)

![image-20250830152240984](https://img.tynote.cn/img/typora/20250830152241364.png#800w)

![image-20250830152432560](https://img.tynote.cn/img/typora/20250830152432974.png#800w)

**由于一开始盘子中没有水果，儿子、女儿进程上处理机都一定会被阻塞，所以只能是父亲或母亲进程先运行，并且由于在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1，这种特性，使它们在功能上也具备了互斥功能，如果plate=2，则不满足互斥访问。**

![image-20250830153223964](https://img.tynote.cn/img/typora/20250830153224437.png#800w)

![image-20250830153408195](https://img.tynote.cn/img/typora/20250830153408543.png#800w)

#### 总结

![image-20250830153718652](https://img.tynote.cn/img/typora/20250830153719024.png#800w)

### 读者-写者问题

#### 问题及实现

![image-20250830160926445](https://img.tynote.cn/img/typora/20250830160927065.png#800w)

![image-20250830161027333](https://img.tynote.cn/img/typora/20250830161027860.png#800w)

![image-20250830171530837](https://img.tynote.cn/img/typora/20250830171531493.png#800w)

**上述算法不断优化的思路是：①P(rw)与V(rw)：读前加锁，读后要解锁②if(count==0)：有多个读进程，所以加锁由第一个进程完成，解锁由最后一个进程完成③count++与count--：由于要判断是否是第一个或最后一个进程，所以要读前要加数，读完要减数④P(mutex)与V(mutex)：多个读进程并发执行时，可能导致阻塞，各读进程要互斥访问count**

![image-20250830174010788](https://img.tynote.cn/img/typora/20250830174011185.png#800w)

**上述情况④中，读者1执行到“读文件...”这一步时，w=1，rw=0，此时如果切换回写者1进程，则会被阻塞在P(rw)这一步，同时进入阻塞队列，由于写者1进程执行了P(w)这一步，所以w=0，此时如果读者2进程上处理机运行，则会被阻塞在P(w)这一步，同时进入阻塞队列，此时只有读者1进程运行完，由于执行了V(rw)使得rw=1，才会唤醒阻塞队列中的写者1进程，使其上处理机运行，同样的，只有写者1进程执行完，由于执行了V(w)使得w=1，才会唤醒阻塞队列中的读者2进程，使其上处理机运行。情况⑤也同理，写者1运行中，如果切换到其它进程，都会阻塞在P(w)这一步并进入阻塞队列，所以只有写者1完全运行完才能“先进先出”原则唤醒阻塞队列中的其它进程使其上处理机运行，以此类推。**

#### 总结

![image-20250830174242174](https://img.tynote.cn/img/typora/20250830174242818.png#800w)

### 哲学家进餐问题

#### 问题及实现

![image-20250830175923128](https://img.tynote.cn/img/typora/20250830175923712.png#800w)

![image-20250830180321115](https://img.tynote.cn/img/typora/20250830180321694.png#800w)

![image-20250830180718731](https://img.tynote.cn/img/typora/20250830180719323.png#800w)

**对于方案①，可以设置一个初始值为4的同步信号量，对于方案②，可以在每个哲学家拿筷子之前先判断一下他们的序号是奇数还是偶数，然后根据序号做相应处理。**

![image-20250830180907473](https://img.tynote.cn/img/typora/20250830180908055.png#800w)

![image-20250830181922092](https://img.tynote.cn/img/typora/20250830181922653.png#800w)

![image-20250830182511145](https://img.tynote.cn/img/typora/20250830182511867.png#800w)

**mutex=1意思是同一时间内只允许一个人拿筷子。①假设此时是0号拿起了左右筷子，执行到“吃饭...”的时候切换到了1号，此时由于1号左边筷子被0号拿走，所以1号会在P(chopstick[i])这一步阻塞，并且由于执行了P(mutex)使得mutex=0，此时如果2号想要拿起筷子，由于mutex被1号置为0，导致2号即使左右筷子都空闲也会在P(mutex)这一步阻塞。②假设此时是0号拿起了左右筷子，执行到“吃饭...”的时候切换到了4号，4号会在P(chopstick[(i+1)%5])这一步阻塞，并且由于执行了P(mutex)使得mutex=0，P(chopstick[i])使得chopstick[i]=0，即此时4号右边筷子不可用，但仍然会先拿起左边的筷子。因此这种方法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子。**

**如果各哲学家拿筷子这件事互斥执行的话，那么当有哲学家拿筷子拿到一半阻塞的时候，也不会有其它哲学家去拿筷子，例如上述情况①，当1号阻塞后，只有等待0号完成后才能被唤醒执行，而不会在1号还阻塞的时候，就有2号去尝试拿筷子。**

#### 总结

![image-20250830182820770](https://img.tynote.cn/img/typora/20250830182821171.png#800w)

### 管程

![image-20250830211933739](https://img.tynote.cn/img/typora/20250830211934083.png#800w)

#### 为什么要引入管程

![image-20250830212210712](https://img.tynote.cn/img/typora/20250830212211232.png#800w)

#### 管程的定义和特征

![image-20250830213115071](https://img.tynote.cn/img/typora/20250830213115552.png#800w)

#### 拓展1:用管程解决生产者消费者问题

​	**当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其它进程无法进入管程。为此，将阻塞原因定义为条件变量condition。通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即wait和signal。**

​	**wait(x)或x.wait()：当x对应的条件不满足时，正在调用管程的进程调用wait将自己插入x条件的等待队列，并释放管程，此时其它进程可以使用该管程。**

​	**signal(x)或x.signal()：x对应的条件发生了变化，则调用signal，唤醒一个因x条件而阻塞的进程。**

​	**条件变量和信号量的比较：**

- **相同点：条件变量的wait/signal操作类似于信号量的P/V操作，可以实现进程的阻塞/唤醒。**
- **不同点：条件变量是“没有值”的，仅实现了“排队等待”功能；而信号量是“有值”的，信号量的值反应了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。**

![image-20250830223828317](https://img.tynote.cn/img/typora/20250830223828658.png#800w)

![image-20250830215830455](https://img.tynote.cn/img/typora/20250830215830854.png#800w)

![image-20250830215920982](https://img.tynote.cn/img/typora/20250830215921487.png#800w)

#### 拓展2:JAVA中类似管程的机制

![image-20250830220047454](https://img.tynote.cn/img/typora/20250830220048057.png#800w)

#### 总结

![image-20250830220204601](https://img.tynote.cn/img/typora/20250830220205141.png#800w)

## 死锁

### 死锁的概念

![image-20250830224306884](https://img.tynote.cn/img/typora/20250830224307253.png#800w)

#### 什么是死锁

![image-20250830224435969](https://img.tynote.cn/img/typora/20250830224436790.png#800w)

![image-20250830224845374](https://img.tynote.cn/img/typora/20250830224846075.png#800w)

#### 死锁、饥饿、死循环的区别

![image-20250830225053011](https://img.tynote.cn/img/typora/20250830225053478.png#800w)

#### 死锁产生的必要条件

![image-20250830230005956](https://img.tynote.cn/img/typora/20250830230006600.png#800w)

#### 什么时候会发生死锁

![image-20250830230104685](https://img.tynote.cn/img/typora/20250830230149217.png#800w)

#### 死锁的处理策略

![image-20250830230218130](https://img.tynote.cn/img/typora/20250830230218546.png#800w)

#### 总结

![image-20250830230253978](https://img.tynote.cn/img/typora/20250830230254536.png#800w)

### 死锁的处理策略

#### 预防死锁

![image-20250831102932441](https://img.tynote.cn/img/typora/20250831102932883.png#800w)

##### 破环互斥条件

​	**各个进程把请求交给输出进程后，就可以去做其他事情，然后输出进程依照请求顺序完成任务。**

![image-20250831104000024](https://img.tynote.cn/img/typora/20250831104000465.png#800w)

##### 破坏不剥夺条件

![image-20250831104519852](https://img.tynote.cn/img/typora/20250831104520562.png#800w)

##### 破坏请求和保持条件

​	**此方法可能会导致进程饥饿，如下图，如果A类进程只需要资源1就可以运行，B类进程只需要资源2，C类进程同时需要资源1和资源2，而如果有源源不断的A类和B类进程，那么就会导致C类进程饥饿。**

![image-20250831104810875](https://img.tynote.cn/img/typora/20250831104811369.png#800w)

##### 破坏循环等待条件

![image-20250831105447768](https://img.tynote.cn/img/typora/20250831105448167.png#800w)

##### 总结

![image-20250831105551102](https://img.tynote.cn/img/typora/20250831105551479.png#800w)

#### 避免死锁

![image-20250831105652998](https://img.tynote.cn/img/typora/20250831105653549.png#800w)

##### 什么是安全序列

![image-20250831105900285](https://img.tynote.cn/img/typora/20250831105900950.png#800w)

![image-20250831105942854](https://img.tynote.cn/img/typora/20250831105943256.png#800w)

![image-20250831110051293](https://img.tynote.cn/img/typora/20250831110051693.png#800w)

![image-20250831110114236](https://img.tynote.cn/img/typora/20250831110114820.png#800w)

![image-20250831110141250](https://img.tynote.cn/img/typora/20250831110141692.png#800w)

##### 安全序列、不安全状态、死锁的联系

![image-20250831110313945](https://img.tynote.cn/img/typora/20250831110314675.png#800w)

![image-20250831110357127](https://img.tynote.cn/img/typora/20250831110357539.png#800w)

##### 银行家算法

- 例一

![image-20250831110604526](https://img.tynote.cn/img/typora/20250831110605187.png#800w)

![image-20250831110704003](https://img.tynote.cn/img/typora/20250831110704554.png#800w)

![image-20250831110744193](https://img.tynote.cn/img/typora/20250831110744587.png#800w)

![image-20250831110836546](https://img.tynote.cn/img/typora/20250831110837079.png#800w)

![image-20250831110922537](https://img.tynote.cn/img/typora/20250831110923030.png#800w)

- 例二

![image-20250831110959519](https://img.tynote.cn/img/typora/20250831111000103.png#800w)

![image-20250831111056301](https://img.tynote.cn/img/typora/20250831111056690.png#800w)

- 算法流程

![image-20250831111632376](https://img.tynote.cn/img/typora/20250831111632822.png#800w)

![image-20250831111938899](https://img.tynote.cn/img/typora/20250831111939303.png#800w)

![image-20250831111915563](https://img.tynote.cn/img/typora/20250831111915986.png#800w)

##### 总结

![image-20250831112101886](https://img.tynote.cn/img/typora/20250831112102318.png#800w)

#### 检测和解除

![image-20250831112156694](https://img.tynote.cn/img/typora/20250831112157213.png#800w)

##### 死锁的检测

![image-20250831112342806](https://img.tynote.cn/img/typora/20250831112343439.png#800w)

​	**如下图所示，R2资源分配了一个给P2进程，还剩余一个，此时P1进程要请求一个R2资源是可以满足的，所以P1进程可以正常运行，而R1资源已分配了两个给p1进程，一个给P2进程，此时P2进程还要请求一个R1资源是不能满足的，所以P2进程被阻塞。等到P1进程运行结束把资源归还系统后，P2进程才能满足请求，从而正常运行。**

![image-20250831112832836](https://img.tynote.cn/img/typora/20250831112833559.png#800w)

![image-20250831112858183](https://img.tynote.cn/img/typora/20250831112858563.png#800w)

![image-20250831112944900](https://img.tynote.cn/img/typora/20250831112945444.png#800w)

​	**如下图所示，P1进程请求两个R2资源，而R2资源只剩一个，P2进程要请求一个R1资源，而R1资源已经全部分配出去了，所以此时P1进程和P2进程被阻塞，能正常运行的只有P3进程。当P3进程运行结束后，归还资源R2一个，此时仍不能满足P1进程和P2进程，仍然被阻塞，处于死锁状态。**

![image-20250831113044310](https://img.tynote.cn/img/typora/20250831113044681.png#800w)

![image-20250831113406388](https://img.tynote.cn/img/typora/20250831113406865.png#800w)

- 检测死锁的算法

![image-20250831114041795](https://img.tynote.cn/img/typora/20250831114042247.png#800w)

![image-20250831114144050](https://img.tynote.cn/img/typora/20250831114144579.png#800w)

##### 死锁的解除

![image-20250831114614009](https://img.tynote.cn/img/typora/20250831114614429.png#800w)

##### 总结

![image-20250831114741985](https://img.tynote.cn/img/typora/20250831114742392.png#800w)

# 内存管理

## 内存的基础知识

![image-20250831160856083](https://img.tynote.cn/img/typora/20250831160903517.png#800w)

### 内存的定义

![image-20250831161106212](https://img.tynote.cn/img/typora/20250831161106922.png#800w)

![image-20250831161205155](https://img.tynote.cn/img/typora/20250831161205690.png#800w)

### 指令的工作原理

![image-20250831161419104](https://img.tynote.cn/img/typora/20250831161419776.png#800w)

![image-20250831161503131](https://img.tynote.cn/img/typora/20250831161503545.png#800w)

![image-20250831161700811](https://img.tynote.cn/img/typora/20250831161701372.png#800w)

![image-20250831161952401](https://img.tynote.cn/img/typora/20250831161952816.png#800w)

![image-20250831162045325](https://img.tynote.cn/img/typora/20250831162045754.png#800w)

### 装入的三种方式

#### 绝对装入

![image-20250831162448952](https://img.tynote.cn/img/typora/20250831162449325.png#800w)

**假设该可执行文件要在另一台电脑上运行，而另一台电脑又不能让它从地址编号为100的地方开始存放，这就意味着这个程序换一台电脑就不能执行了，所以这种方式灵活性很低。**

**绝对装入只适用于单道程序环境，此时没有产生操作系统，该方式由编译器完成。**

#### 可重定位装入

![image-20250831162941231](https://img.tynote.cn/img/typora/20250831162941650.png#800w)

#### 动态运行时装入

![image-20250831163035796](https://img.tynote.cn/img/typora/20250831163036384.png#800w)

![image-20250831163146115](https://img.tynote.cn/img/typora/20250831163146648.png#800w)

![image-20250831163219013](https://img.tynote.cn/img/typora/20250831163219440.png#800w)

### 从写程序到程序运行

​	**首先，程序员通过编译器写出一些代码文件，比如C语言中的代码文件就是`*.c`，接下来经过编译后，这些源代码文件会形成若干个与它们一一对应的目标模块文件，在C语言中就是`*.o`文件，并且这些目标模块文件中已经包含了这些代码所对应的那些指令，而这些指令的编址都是一个逻辑地址，也就是相对地址，每一个模块的编址都是从0开始的，所以经过编译后，我们就把高级语言翻译成了与它们等价的机器语言，只不过每个模块的逻辑地址的编址都是相互独立的，都是从0开始的，接下来进行链接，即把这些目标模块都组装起来，形成一个完整的装入模块，而在Windows系统中，所谓的装入模块就是`*.exe`文件，也就是可执行文件，链接起来后，所形成的装入模块就有一个完整的逻辑地址，当然在这一步，除了我们自己编写的目标模块需要链接以外，还需要把它们所调用到的库函数也链接起来，形成一个完整的装入模块，有了可执行文件，程序就可以开始运行了，即把装入模块装入内存中，并且当它装入内存后，就确定了这个进程所对应的实际的物理地址。**

![image-20250831164317626](https://img.tynote.cn/img/typora/20250831164317986.png#800w)

### 链接的三种方式

#### 静态链接

![image-20250831164416259](https://img.tynote.cn/img/typora/20250831164416616.png#800w)

#### 装入时动态链接

​	**目标模块放入内存时才开始链接，采用此方式时，该进程的完整逻辑地址是一边装入一边形成的。**

![image-20250831164606564](https://img.tynote.cn/img/typora/20250831164607167.png#800w)

#### 运行时动态链接

​	**采用此方式时，只有需要某个模块时才将其调入内存，比如刚开始是main函数运行，那么就需要把目标模块1放入内存中，然后执行的过程中发现main函数需要调用到函数a，因此需要把目标模块2也调入内存，并且把它装入的时候同时进行链接，函数b没用到，那其所对应的目标模块就不需要装入内存。**

![image-20250831165002708](https://img.tynote.cn/img/typora/20250831165003310.png#800w)

### 总结

![image-20250831165252238](https://img.tynote.cn/img/typora/20250831165252626.png#800w)

## 内存管理的概念

![image-20250831165704653](https://img.tynote.cn/img/typora/20250831165705109.png#800w)

### 内存空间的分配与回收

![image-20250831165805486](https://img.tynote.cn/img/typora/20250831165805859.png#800w)

### 内存空间的扩充

![image-20250831165905146](https://img.tynote.cn/img/typora/20250831165905655.png#800w)

### 地址转换

![image-20250831165949475](https://img.tynote.cn/img/typora/20250831165950014.png#800w)

![image-20250831170207759](https://img.tynote.cn/img/typora/20250831170208179.png#800w)

### 内存保护

![image-20250831170505717](https://img.tynote.cn/img/typora/20250831170506075.png#800w)

![image-20250831170406718](https://img.tynote.cn/img/typora/20250831170407244.png#800w)

![image-20250831170500461](https://img.tynote.cn/img/typora/20250831170500853.png#800w)

### 总结

![image-20250831170558574](https://img.tynote.cn/img/typora/20250831170558963.png#800w)

## 进程的内存映像

![image-20250831172001333](https://img.tynote.cn/img/typora/20250831172001779.png#800w)

![image-20250831172109613](https://img.tynote.cn/img/typora/20250831172110018.png#800w)

## 覆盖与交换

![image-20250831172246769](https://img.tynote.cn/img/typora/20250831172247135.png#800w)

### 覆盖技术

![image-20250831172350951](https://img.tynote.cn/img/typora/20250831172351461.png#800w)

​	**如下图，A模块可能依次调用B模块和C模块，“依次”的意思是不会同时调用这两个模块，同理，B模块可能调用D模块，C模块可能依次调用E模块和F模块。**

![image-20250831172747130](https://img.tynote.cn/img/typora/20250831172747533.png#800w)

### 交换技术

​	**假设内存当中有很多进程正在并发运行，如果某一时刻发现内存紧张，我们就可以把其中某些进程暂时换出外存，而进程相关的PCB会保留在内存当中，并且会插入到挂起队列，一直到之后内存空间不紧张了，又可以把这些进程相关的数据再换入内存，进程PCB常驻内存是因为进程被换出外存后，必须要通过某种方式记录进程换到外存的什么位置，即进程的存放位置信息会被记录在对应的PCB中，操作系统就可以根据记录的PCB信息对进程进行管理，所以进程的PCB需要常驻内存。**

![image-20250901090031367](https://img.tynote.cn/img/typora/20250901090032002.png#800w)

![image-20250901090143087](https://img.tynote.cn/img/typora/20250901090143653.png#800w)

![image-20250901090412468](https://img.tynote.cn/img/typora/20250901090413263.png#800w)

### 总结

![image-20250901090533329](https://img.tynote.cn/img/typora/20250901090533737.png#800w)

## 连续分配管理方式

![image-20250901090635570](https://img.tynote.cn/img/typora/20250901090636163.png#800w)

### 单一连续分配

![image-20250901090856525](https://img.tynote.cn/img/typora/20250901090856977.png#800w)

### 固定分区分配

![image-20250901104552325](https://img.tynote.cn/img/typora/20250901104552913.png#800w)

![image-20250901105642152](https://img.tynote.cn/img/typora/20250901105642751.png#800w)

### 动态分区分配

![image-20250901110047265](https://img.tynote.cn/img/typora/20250901110047852.png#800w)

![image-20250901110041021](https://img.tynote.cn/img/typora/20250901110041517.png#800w)

![image-20250901110211364](https://img.tynote.cn/img/typora/20250901110211949.png#800w)

​	**假设系统当中此时有3个空闲分区，有一个进程要申请4MB空间，最后根据某种算法决定从这20MB空间中分配4MB给该进程，因此要对该空闲分区表进行处理，由于该空闲分区本来就比所要申请的空间大，所以即使从中分配出了4MB，分区的数量也不会变，所以只需要修改该分区表项中的大小和起始地址即可，这是第一种情况。**

![image-20250901110827760](https://img.tynote.cn/img/typora/20250901110828218.png#800w)

![image-20250901110818435](https://img.tynote.cn/img/typora/20250901110818870.png#800w)

​	**第二种情况决定把3号分区的4MB空间分配给该进程，此时该空闲分区大小与所申请的空间大小相同，所以空闲分区数量会减1，我们需要把该分区对应的表项删除，如果采用的是空闲分区链，则把对应的结点删除。**

![image-20250901111502481](https://img.tynote.cn/img/typora/20250901111503129.png#800w)

![image-20250901111539343](https://img.tynote.cn/img/typora/20250901111539973.png#800w)

![image-20250901111601115](https://img.tynote.cn/img/typora/20250901111601552.png#800w)

![image-20250901111644362](https://img.tynote.cn/img/typora/20250901111644938.png#800w)

![image-20250901111710675](https://img.tynote.cn/img/typora/20250901111711138.png#800w)

![image-20250901111730458](https://img.tynote.cn/img/typora/20250901111731062.png#800w)

![image-20250901111815935](https://img.tynote.cn/img/typora/20250901111816365.png#800w)

![image-20250901111854163](https://img.tynote.cn/img/typora/20250901111854821.png#800w)

![image-20250901112113370](https://img.tynote.cn/img/typora/20250901112113855.png#800w)

![image-20250901112318926](https://img.tynote.cn/img/typora/20250901112319400.png#800w)

### 总结

![image-20250901112429456](https://img.tynote.cn/img/typora/20250901112429898.png#800w)

## 动态分区分配算法



![image-20250901140202447](https://img.tynote.cn/img/typora/20250901140202826.png#800w)

### 首次适应算法

​	**此时有一个进程5要求15MB的分区，因此从空闲分区链的链头开始依次检索，找到第一个能够满足大小的分区，经过检查发现，大小为20MB的1号空闲分区能够满足要求，所以会从20MB的空间中分配出15MB空间给该进程，于是该空闲分区会剩余5MB空间，相应的，我们需要把空闲分区链结点对应的数据，包括分区大小、起始地址等信息进行修改；此时如果还有一个进程6到来，要求8MB的空间，因此仍然从空闲分区链的链头开始依次查找，经过查找，发现大小为10MB的2号空闲分区能够满足要求，于是从2号空闲分区中分配8MB给该进程，于是该空闲分区会剩余2MB，同样的，将该空闲分区所对应的结点的信息进行修改，此处不展开赘述。**

![image-20250901140651356](https://img.tynote.cn/img/typora/20250901140651965.png#800w)

![image-20250901141106932](https://img.tynote.cn/img/typora/20250901141107492.png#800w)

### 最佳适应算法

​	**此时有一个进程6要求9MB的分区，因此从空闲分区链的链头开始依次检索，找到第一个能够满足大小的分区，经过检查发现，大小为10MB的2号空闲分区能够满足要求，所以会从10MB的空间中分配出9MB空间给该进程，于是该空闲分区会剩余1MB空间，相应的，我们需要把空闲分区链结点对应的数据，包括分区大小、起始地址等信息进行修改，同时由于修改完后，空闲分区链不满足容量递增次序，因此需要对该空闲分区链重新排序。**

![image-20250901141227041](https://img.tynote.cn/img/typora/20250901141227445.png#800w)

![image-20250901141523968](https://img.tynote.cn/img/typora/20250901141524361.png#800w)

​	**此时如果还有一个进程5到来，要求3MB的空间，因此仍然从空闲分区链的链头开始依次查找，经过查找，发现大小为4MB的2号空闲分区能够满足要求，于是从2号空闲分区中分配3MB给该进程，于是该空闲分区会剩余1MB，同样的，将该空闲分区所对应的结点的信息进行修改，由于修改后空闲分区链仍然保持容量递增的次序，因此不需要对空闲分区链重新排序，此处不展开赘述。**

![image-20250901141709675](https://img.tynote.cn/img/typora/20250901141710172.png#800w)

### 最坏适应算法

![image-20250901141934552](https://img.tynote.cn/img/typora/20250901141935069.png#800w)

​	**此时有一个进程5到来，要求3MB的空间，从空闲分区链的链头开始依次查找，经过查找，发现大小为20MB的1号空闲分区能够满足要求，于是从1号空闲分区中分配3MB给该进程，于是该空闲分区会剩余17MB，相应的，将该空闲分区所对应的结点的信息进行修改。**

![image-20250901142130744](https://img.tynote.cn/img/typora/20250901142131156.png#800w)

​	**此时如果还有一个进程6到来，要求9MB的空间，因此仍然从空闲分区链的链头开始依次查找，经过查找，发现大小为17MB的1号空闲分区能够满足要求，于是从1号空闲分区中分配9MB给该进程，于是该空闲分区会剩余8MB，相应的，将该空闲分区所对应的结点的信息进行修改，修改完后，空闲分区链不满足容量递减次序，因此需要对该空闲分区链重新排序。**

![image-20250901142405813](https://img.tynote.cn/img/typora/20250901142406445.png#800w)

![image-20250901142738823](https://img.tynote.cn/img/typora/20250901142739407.png#800w)

### 邻近适应算法

​	**此时有一个进程5到来，要求5MB的空间，从空闲分区链的链头开始依次查找，经过查找，发现大小为6MB的2号空闲分区能够满足要求，于是从2号空闲分区中分配6MB给该进程，于是该空闲分区会剩余1MB，相应的，将该空闲分区所对应的结点的信息进行修改。**

![image-20250901142859160](https://img.tynote.cn/img/typora/20250901142859566.png#800w)

![image-20250901143150689](https://img.tynote.cn/img/typora/20250901143151065.png#800w)

​	**此时如果还有一个进程6到来，要求5MB的空间，按照邻近适应算法的规则，从上次查找结束的位置开始查找，经过查找，发现大小为10MB的3号空闲分区能够满足要求，于是从3号空闲分区中分配5MB给该进程，于是该空闲分区会剩余5MB，相应的，将该空闲分区所对应的结点的信息进行修改。如果采用首次适应算法，需要查找3次才能找到合适的空闲分区，而采用邻近适应算法，只需要查找两次（上次查找结束的位置也要比较依次，看上次分配剩余的空间是否能够满足本次进程所需要的内存空间要求）。**

![image-20250901143356283](https://img.tynote.cn/img/typora/20250901143356811.png#800w)

![image-20250901143857522](https://img.tynote.cn/img/typora/20250901143858137.png#800w)

### 总结

![image-20250901143924422](https://img.tynote.cn/img/typora/20250901143925027.png#800w)

## 基本分页存储管理的概念

![image-20250902154146078](https://img.tynote.cn/img/typora/20250902154146686.png#800w)

### 什么是分页存储

![image-20250902154441658](https://img.tynote.cn/img/typora/20250902154442342.png#800w)

![image-20250902154646417](https://img.tynote.cn/img/typora/20250902154646966.png#800w)

**进程上的页面叫page，内存上的页框页帧叫page frame。**

### 页表



​	**那操作系统是怎么记录这种一一对应的关系的呢？这就涉及到了一个很重要的数据结构——页表**

![image-20250902155341965](https://img.tynote.cn/img/typora/20250902155342785.png#800w)

![image-20250902155413237](https://img.tynote.cn/img/typora/20250902155413893.png#800w)

#### 每个页表项占多少字节

![image-20250902155946115](https://img.tynote.cn/img/typora/20250902155946773.png#800w)

![image-20250902160029736](https://img.tynote.cn/img/typora/20250902160030551.png#800w)

![image-20250902160135425](https://img.tynote.cn/img/typora/20250902160135887.png#800w)

#### 如何实现地址的转换

![image-20250902160322267](https://img.tynote.cn/img/typora/20250902160322845.png#800w)

![image-20250902160539458](https://img.tynote.cn/img/typora/20250902160540228.png#800w)

![image-20250902160840197](https://img.tynote.cn/img/typora/20250902160840870.png#800w)

![image-20250902161410536](https://img.tynote.cn/img/typora/20250902161411050.png#800w)

**如果是2的整数幂，计算机就无需做复杂的除法或取余运算，直接取前面几位或后面记为就可以了。**

![image-20250902162000590](https://img.tynote.cn/img/typora/20250902162001422.png#800w)

![image-20250902162021580](https://img.tynote.cn/img/typora/20250902162022160.png#800w)

![image-20250902162159185](https://img.tynote.cn/img/typora/20250902162159793.png#800w)

### 总结

![image-20250902162305796](https://img.tynote.cn/img/typora/20250902162306224.png#800w)

## 基本地址变换机构

![image-20250902162834631](https://img.tynote.cn/img/typora/20250902162835267.png#800w)

### 基本地址变换机构

![image-20250902165126981](https://img.tynote.cn/img/typora/20250902165127567.png#800w)

![image-20250902165154479](https://img.tynote.cn/img/typora/20250902165155196.png#800w)

​	**首先对页号的合法性检查，页表长度M即有M个页表项或有M个页面，如果此时想要访问的页号已经超出了该进程的页面数，则认为想要访问的该逻辑地址非法，并抛出越界中断；如果合法，则利用好页号和页表始址进行计算，，找到该页号对应的页表项，再根据查表所得的内存块号与页面大小进行计算，得出对应的内存块的位置，再结合页内偏移量得到最终的物理地址。**

![image-20250902164741960](https://img.tynote.cn/img/typora/20250902164742617.png#800w)

![image-20250902165716755](https://img.tynote.cn/img/typora/20250902165717330.png#800w)

**页式管理中地址是一维的，意思是只需要有一个信息，也就是逻辑地址的值就可以计算出其逻辑地址所对应的物理地址，而不需要其它信息。**

![image-20250902172011792](https://img.tynote.cn/img/typora/20250902172012405.png#800w)

​	**由于内存被以页面大小为单位划分成了若干个相等的空间，称为页框，而页表项也是要放在内存中的，由于页表项长度是3B，每个页框大小为4KB，所以每个页框可以存放4096/3=1365个页表项，但是该页框会剩余4096%3=1B页内碎片，因此，1365号页表项存放的地址为X+3*1365+1，这会导致在内存中查找页表项的时候造成麻烦，为了解决这个问题，我们可以把每个页表项的长度拓展为4B，这样可以保证每个页框刚好可以放1024个页表项，而不会有任何页内碎片，这样在内存中查找1024号页表项的时候计算不用那么麻烦。此策略只是为了方便才采用，如果试题中问最小页表项长度，仍然按3B处理。**

![image-20250902172026664](https://img.tynote.cn/img/typora/20250902172125264.png#800w)

### 总结

![image-20250902172631719](https://img.tynote.cn/img/typora/20250902172632270.png#800w)

## 具有快表的地址变换机构

![image-20250902175107472](https://img.tynote.cn/img/typora/20250902175108123.png#800w)

### 什么是快表

![image-20250902175504403](https://img.tynote.cn/img/typora/20250902175505102.png#800w)

### 引入快表后的地址转换过程

![image-20250902182556777](https://img.tynote.cn/img/typora/20250902182557426.png#800w)

![image-20250902182649970](https://img.tynote.cn/img/typora/20250902182650440.png#800w)

​	**当进程上处理机运行的时候，系统会清空快表中的内容，当进程被切换的时候，快表的内容也需要被清除。首先该进程先访问逻辑地址(0,0)，即页号为0，页内偏移量为0的逻辑地址。假设访问TLB只需要1μs，访问内存需要100μs。**

![image-20250902181355185](https://img.tynote.cn/img/typora/20250902181355733.png#800w)

![image-20250902180744814](https://img.tynote.cn/img/typora/20250902180745273.png#800w)

​	**接下来访问逻辑地址(0,4)。**

![image-20250902181615152](https://img.tynote.cn/img/typora/20250902181615629.png#800w)

​	**接下来访问逻辑地址(0,8)，过程同上，此处不再赘述。**

![image-20250902181825130](https://img.tynote.cn/img/typora/20250902181825595.png#800w)

### 局部性原理

![image-20250902182958731](https://img.tynote.cn/img/typora/20250902182959242.png#800w)

### 总结

![image-20250902183039090](https://img.tynote.cn/img/typora/20250902183039582.png#800w)

## 两级页表

![image-20250902191314133](https://img.tynote.cn/img/typora/20250902191314780.png#800w)

### 单机页表的问题及解决

![image-20250902191649183](https://img.tynote.cn/img/typora/20250902191649814.png#800w)

![image-20250902191728516](https://img.tynote.cn/img/typora/20250902191729193.png#800w)

![image-20250902192056708](https://img.tynote.cn/img/typora/20250902192126275.png#800w)

**补充，多级页表的顺序是顶层页表序号最小，比如三级页表中，顶层页表又叫一级页表，存储进程页号和块号的最底层页表即为三级页表。**

### 两级页表的原理、逻辑地址

![image-20250902193228561](https://img.tynote.cn/img/typora/20250902193229348.png#800w)

![image-20250902194108073](https://img.tynote.cn/img/typora/20250902194108759.png#800w)

### 如何实现地址转换

![image-20250902194322294](https://img.tynote.cn/img/typora/20250902194323033.png#800w)

![image-20250902194415842](https://img.tynote.cn/img/typora/20250902194416585.png#800w)

![image-20250902210140368](https://img.tynote.cn/img/typora/20250902210141019.png#800w)

​	**页号28位，所以总共有$2^{28}$个页表项，页表项大小为4B，页面大小为$2^{12}B$，则每个页面可存放$2^{12}/4=2^{10}$个页表项。**

​	**我们知道，多级页表中上层页表存储的是下层页表的编号和下层页表的基地址，也就是下层页表中第一条页表项所在的内存块号，此处，为方便区分和理解，暂且将页目录表中的页表项称为基地址条目，同时，这也意味着，一张上层目录表中存有多少条下层页表的基地址条目，就说明一张上层目录包含了多少张下层页表，即$下层页表总张数=上层页表总张数×单张上层页表的页表项总数$。**

​	**已知每个页面可存放$2^{12}/4=2^{10}$个页表项，所以二级页目录表中共存有$2^{28}/2^{10}=2^{18}$个下层页表的基地址条目，而页面大小最多只允许存放$2^{10}$个，所以要再分一级，所以一共三级页表，一级页目录表(即顶层页表)中共存有$2^{18}/2^{10}=2^8$个二级页表的基地址条目。综上所述，需采用三级页表，一级页表一张，其中共存有$2^8$个二级页表的基地址条目，二级页表$2^8$张，其中每张共存有$2^{10}$条三级页表的基地址条目，三级页表共$2^{18}$张，其中每张共存有$2^{10}$条页表项，具体三级页表结构如下图所示。**



![image-20250902223253098](https://img.tynote.cn/img/typora/20250902223253699.png#800w)



### 总结

![image-20250902223513759](https://img.tynote.cn/img/typora/20250902223514444.png#800w)

## 基本分段存储管理方式

![image-20250902225427213](https://img.tynote.cn/img/typora/20250902225428118.png#800w)

### 分段

![image-20250902225739967](https://img.tynote.cn/img/typora/20250902225740586.png#800w)

![image-20250902230218492](https://img.tynote.cn/img/typora/20250902230219296.png#800w)

### 段表

![image-20250902231235545](https://img.tynote.cn/img/typora/20250902231236415.png#800w)

### 地址转换

![image-20250902231318159](https://img.tynote.cn/img/typora/20250902231319017.png#800w)

![image-20250902231408051](https://img.tynote.cn/img/typora/20250902231408701.png#800w)

![image-20250902231754468](https://img.tynote.cn/img/typora/20250902231755377.png#800w)

### 分段、分页管理的对比

![image-20250902232106375](https://img.tynote.cn/img/typora/20250902232107101.png#800w)

![image-20250902232245226](https://img.tynote.cn/img/typora/20250902232245886.png#800w)

![image-20250902232520126](https://img.tynote.cn/img/typora/20250902232520864.png#800w)

![image-20250902232602273](https://img.tynote.cn/img/typora/20250902232602951.png#800w)

### 总结

![image-20250902232648357](https://img.tynote.cn/img/typora/20250902232648974.png#800w)

## 段页式管理方式

![image-20250902232954142](https://img.tynote.cn/img/typora/20250902232954677.png#800w)

### 分页、分段的优缺点

![image-20250902233158974](https://img.tynote.cn/img/typora/20250902233200002.png#800w)

### 分段+分页=段页式管理

![image-20250902233432682](https://img.tynote.cn/img/typora/20250902233433193.png#800w)

### 段页式管理的逻辑地址结构

![image-20250902233813383](https://img.tynote.cn/img/typora/20250902233814253.png#800w)

### 段表、页表

![image-20250902234454914](https://img.tynote.cn/img/typora/20250902234455479.png#800w)

**由上图可以发现，一个进程对应一个段表，一个段表对应一个页表，因此一个进程只能有一个段表，而一个进程可以有多个页表。**

![image-20250902235025126](https://img.tynote.cn/img/typora/20250902235025977.png#800w)

### 总结

![image-20250902235209415](https://img.tynote.cn/img/typora/20250902235210042.png#800w)

## 虚拟内存的基本概念

![image-20250902235504768](https://img.tynote.cn/img/typora/20250902235505548.png#800w)

![image-20250902235532320](https://img.tynote.cn/img/typora/20250902235533260.png#800w)

### 传统存储管理方式的特征、缺点

![image-20250902235849385](https://img.tynote.cn/img/typora/20250902235849911.png#800w)

### 局部性原理

![image-20250903000038530](https://img.tynote.cn/img/typora/20250903000039404.png#800w)

### 虚拟内存的定义和特征

![image-20250903000248034](https://img.tynote.cn/img/typora/20250903000501367.png#800w)

### 如何实现虚拟内存技术

![image-20250903000458113](https://img.tynote.cn/img/typora/20250903000458704.png#800w)

### 总结

![image-20250903000656215](https://img.tynote.cn/img/typora/20250903000656855.png#800w)

## 请求分页管理方式

![image-20250903113718821](https://img.tynote.cn/img/typora/20250903113719362.png#800w)

### 页表机制

![image-20250903113958503](https://img.tynote.cn/img/typora/20250903113959279.png#800w)

### 缺页中断机构

![image-20250903114119130](https://img.tynote.cn/img/typora/20250903114119956.png#800w)

![image-20250903114134582](https://img.tynote.cn/img/typora/20250903114135315.png#800w)

![image-20250903114310248](https://img.tynote.cn/img/typora/20250903114311164.png#800w)

![image-20250903114414293](https://img.tynote.cn/img/typora/20250903114415082.png#800w)

![image-20250903114501117](https://img.tynote.cn/img/typora/20250903114501845.png#800w)

![image-20250903114646992](https://img.tynote.cn/img/typora/20250903114648025.png#800w)

### 地址转换机构

![image-20250903114740067](https://img.tynote.cn/img/typora/20250903114740669.png#800w)

![image-20250903114931674](https://img.tynote.cn/img/typora/20250903114932314.png#800w)

![image-20250903120035416](https://img.tynote.cn/img/typora/20250903120036304.png#800w)

![image-20250903120054539](https://img.tynote.cn/img/typora/20250903120055890.png#800w)

**蓝色框选部分是请求分页存储管理相较于基本分页存储管理新增的步骤。**

### 总结

![image-20250903120217744](https://img.tynote.cn/img/typora/20250903120218789.png#800w)

## 页面置换算法

![image-20250903120309492](https://img.tynote.cn/img/typora/20250903120310588.png#800w)

### 最佳置换算法(OPT)

​	**由于刚开始系统为进程分配的三个内存块都是空的，所以我们在依次访问7,0，1号页面时可以将它们分别放入内存块1,2,3。**

![image-20250903120939299](https://img.tynote.cn/img/typora/20250903120940370.png#800w)

![image-20250903121157430](https://img.tynote.cn/img/typora/20250903121158587.png#800w)

![image-20250903121301313](https://img.tynote.cn/img/typora/20250903121302623.png#800w)

![image-20250903121325581](https://img.tynote.cn/img/typora/20250903121326747.png#800w)

### 先进先出置换算法(FIFO)

![image-20250903121521722](https://img.tynote.cn/img/typora/20250903121522670.png#800w)

![image-20250903121642070](https://img.tynote.cn/img/typora/20250903121643240.png#800w)

![image-20250903121749927](https://img.tynote.cn/img/typora/20250903121750951.png#800w)

### 最近最久未使用置换算法(LRU)

![image-20250903122030113](https://img.tynote.cn/img/typora/20250903122031209.png#800w)

![image-20250903122105998](https://img.tynote.cn/img/typora/20250903122107064.png#800w)

### 时钟置换算法(CLOCK)

![image-20250903122649235](https://img.tynote.cn/img/typora/20250903122649963.png#800w)

​	**第一轮扫描均为1，全部重置为0，队头1号页面为0被置换为6号页面，并将指针指向下一个页面，也就是3号页面。**

![image-20250903122759087](https://img.tynote.cn/img/typora/20250903122800001.png#800w)

​	**访问到3号、4号页面时，命中，将其访问位置为1。注，指针仅在页面置换时移动，命中时不移动。**

![image-20250903123216650](https://img.tynote.cn/img/typora/20250903123217748.png#800w)

​	**要访问7号页面，未命中，需进行页面置换，此时指针指向3号页面，开始移动，找到第一个访问位为0的页面进行置换，并且途中扫描过的页面访问位要从1置为0，于是最终2号页面被置换为7号页面，并将指针指向下一个页面。**

![image-20250903123614966](https://img.tynote.cn/img/typora/20250903123616149.png#800w)

### 改进型的时钟置换算法

![image-20250903123945269](https://img.tynote.cn/img/typora/20250903123946411.png#800w)

![image-20250903124022830](https://img.tynote.cn/img/typora/20250903124023625.png#800w)

![image-20250903124104963](https://img.tynote.cn/img/typora/20250903124106085.png#800w)

​	**第一轮扫描未找到(0,0)的帧进行替换，且未修改任何标志位，进行第二轮扫描。**

![image-20250903124250489](https://img.tynote.cn/img/typora/20250903124251614.png#800w)

![image-20250903124325819](https://img.tynote.cn/img/typora/20250903124327271.png#800w)

​	**第一轮扫描未找到(0,0)的帧进行替换，且未修改任何标志位，进行第二轮扫描；第二轮扫描未找到(0,1)的帧进行替换，修改所有访问过的帧的访问位为0，进行第三轮扫描。**

![image-20250903124547215](https://img.tynote.cn/img/typora/20250903124548263.png#800w)

![image-20250903124621638](https://img.tynote.cn/img/typora/20250903124622814.png#800w)

![image-20250903124659952](https://img.tynote.cn/img/typora/20250903124701330.png#800w)

​	**第一轮扫描未找到(0,0)的帧进行替换，且未修改任何标志位，进行第二轮扫描；第二轮扫描未找到(0,1)的帧进行替换，修改所有访问过的帧的访问位为0，进行第三轮扫描；第三轮扫描未找到(0,0)的帧进行替换，且未修改任何标志位，进行第4轮扫描。**

![image-20250903124742245](https://img.tynote.cn/img/typora/20250903124743301.png#800w)

![image-20250903124916557](https://img.tynote.cn/img/typora/20250903124917700.png#800w)

![image-20250903125103767](https://img.tynote.cn/img/typora/20250903125104871.png#800w)

### 总结

![image-20250903125132494](https://img.tynote.cn/img/typora/20250903125133561.png#800w)

## 页面分配策略

![image-20250903161525022](https://img.tynote.cn/img/typora/20250903161526169.png#800w)

### 页面分配、置换策略

![image-20250903161631441](https://img.tynote.cn/img/typora/20250903161632560.png#800w)

![image-20250903161917051](https://img.tynote.cn/img/typora/20250903161917801.png#800w)

![image-20250903162446762](https://img.tynote.cn/img/typora/20250903162447512.png#800w)

![image-20250903162536727](https://img.tynote.cn/img/typora/20250903162537782.png#800w)

### 调入页面的时机

![image-20250903162718154](https://img.tynote.cn/img/typora/20250903162719145.png#800w)

### 从何处调页

![image-20250903162929632](https://img.tynote.cn/img/typora/20250903162930251.png#800w)

![image-20250903163003283](https://img.tynote.cn/img/typora/20250903163004612.png#800w)

![image-20250903163031833](https://img.tynote.cn/img/typora/20250903163032905.png#800w)

### 抖动(颠簸)现象

![image-20250903163132123](https://img.tynote.cn/img/typora/20250903163132883.png#800w)

### 工作集

​	**如果此时访问到23号页面且窗口尺寸为4，则会从此时访问的序列开始寻找之前访问过的4个页号，由此来确定工作集的内容。对于一些局部性很好的进程来说，工作集的大小一般比窗口尺寸大小要更小。**

![image-20250903163717217](https://img.tynote.cn/img/typora/20250903163718103.png#800w)

### 总结

![image-20250903163904420](https://img.tynote.cn/img/typora/20250903163905254.png#800w)

## 内存映射文件

![image-20250903163925318](https://img.tynote.cn/img/typora/20250903163926454.png#800w)

### 定义

![image-20250903164101703](https://img.tynote.cn/img/typora/20250903164102369.png#800w)

### 传统的文件访问方式

​	**有一个文件`葵花宝典.txt`，要存放到磁盘里边，磁盘的存储空间是以块为单位，每个块大小为1KB，相应的，这个文件就会被拆分成几个大小相等的块，每个块刚好是1KB，刚好可以放到磁盘里面，于是这些块有可能被离散地存放到磁盘的各个角落，如果进程想要访问该文件的数据，应该怎么做呢？传统做法中，首先我们知道每个进程有自己的虚拟地址空间，首先它需要使用open系统调用来指明打开这个文件，接下来需要使用seek系统调用来指明它想要读取该文件的哪部分数据，操作系统会使用一个读写指针来记录这个位置，接下来进程可以使用read系统调用来指明从这个位置往后它想要读入多少数据，那如果这一次进程要读入的这部分数据刚好是存放在文件的2号块，那么接下来操作系统会把这一块的数据读入内存，读入内存后，进程就可以访问或者修改内存中的这部分数据，如果想要修改的数据被保存，则进程需要使用write系统调用把内存中的这一块数据写回磁盘。**

![image-20250903165041414](https://img.tynote.cn/img/typora/20250903165042135.png#800w)

### 内存映射文件

​	**传统的文件访问方式很麻烦，那能不能读写文件数据的这些操作变得更简单呢？这就是内存映射文件要解决的问题。如果一个操作系统支持内存映射文件的功能，那么程序员或者进程访问文件的方式就会变得更简单。首先它需要使用open系统调用来指明打开一个文件，接下来使用mmap系统调用，让操作系统把文件映射到进程的虚拟地址空间中，这个系统调用会给程序员返回一个指针，这个指针会指向刚才映射的这片区域的起始地址，接下来就可以用访问内存的方式去访问文件数据。在使用mmap系统调用之后，操作系统只是建立了文件数据和内存之间的映射关系，但并没有把文件数据直接读入内存，这相当于一个缺页的状态。**

​	**假定此时要访问的数据刚好是在文件的2号块，操作系统此时发现这一块的数据还没有调入主存，也就是缺页异常，操作系统此时会自动地把这一块的数据读入主存，同理，如果此时要访问3号块的数据，且处于缺页状态，那么操作系统也会自动将其读入主存，也就是说，作为程序员，不需要再自己去调用write函数，读入数据的过程是操作系统自动完成的。读入内存之后，进程就可以对其进行访问或者修改，最后如果进程不再需要使用该文件，那么进程可以使用close系统调用来关闭文件，当它关闭文件后，操作系统会自动将文件被修改的数据写回磁盘。**



![image-20250903171121543](https://img.tynote.cn/img/typora/20250903171122258.png#800w)

![image-20250903171517780](https://img.tynote.cn/img/typora/20250903171518528.png#800w)

### 总结

![image-20250903171727055](https://img.tynote.cn/img/typora/20250903171728021.png#800w)

# 文件管理

## 初识文件管理

​	**<font color='blue'>本视频对应王道书4.1.1</font>**

![image-20250903173708019](https://img.tynote.cn/img/typora/20250903173709067.png#800w)

### 文件的属性

![image-20250903174227770](https://img.tynote.cn/img/typora/20250903174228772.png#800w)

### 文件内部数据的组织

![image-20250903174413626](https://img.tynote.cn/img/typora/20250903174414489.png#800w)

![image-20250903174632295](https://img.tynote.cn/img/typora/20250903174633443.png#800w)

![image-20250903174814352](https://img.tynote.cn/img/typora/20250903174815559.png#800w)

### 操作系统向上层提供的功能

![image-20250903175013351](https://img.tynote.cn/img/typora/20250903175014263.png#800w)

![image-20250903175104161](https://img.tynote.cn/img/typora/20250903175105345.png#800w)

### 文件应如何存放在外存

![image-20250903175357918](https://img.tynote.cn/img/typora/20250903175359030.png#800w)

![image-20250903175451947](https://img.tynote.cn/img/typora/20250903175452685.png#800w)

![image-20250903175526696](https://img.tynote.cn/img/typora/20250903175527993.png#800w)

### 总结

![image-20250903175624234](https://img.tynote.cn/img/typora/20250903175625296.png#800w)

## 文件的逻辑结构

​	**<font color='blue'>本视频对应王道书4.1.5</font>**

![image-20250903175756699](https://img.tynote.cn/img/typora/20250903175757635.png#800w)

### 无结构文件

![image-20250903175822879](https://img.tynote.cn/img/typora/20250903175823776.png#800w)

### 有结构文件

![image-20250903175902589](https://img.tynote.cn/img/typora/20250903175903836.png#800w)

![image-20250903175959180](https://img.tynote.cn/img/typora/20250903180000754.png#800w)

![image-20250903180043286](https://img.tynote.cn/img/typora/20250903180044869.png#800w)

![image-20250903180112531](https://img.tynote.cn/img/typora/20250903180113793.png#800w)

### 顺序文件

![image-20250903180241853](https://img.tynote.cn/img/typora/20250903180242984.png#800w)

![image-20250903181412620](https://img.tynote.cn/img/typora/20250903181413908.png#800w)

**在实际应用中，为了减少磁盘的I/O次数，一般来说，操作系统会日志文件，用日志文件来记录对这个文件当中的各个记录修改的信息，每隔一段比较长的时间再把这些信息统一的合并到外存当中的文件数据中，这样就可以减少对于顺序存储的顺序文件进行增删改所带来的一些开销。**

### 索引文件

![image-20250903181700302](https://img.tynote.cn/img/typora/20250903181701754.png#800w)

### 索引顺序文件

![image-20250903182035302](https://img.tynote.cn/img/typora/20250903182036376.png#800w)

**所以索引顺序文件的索引表其实是一种定长记录的串结构的顺序文件。**

![image-20250903182334503](https://img.tynote.cn/img/typora/20250903182335259.png#800w)

### 多级索引顺序文件

![image-20250903182744066](https://img.tynote.cn/img/typora/20250903182745111.png#800w)

### 总结

![image-20250903182927985](https://img.tynote.cn/img/typora/20250903182928658.png#800w)

## 文件目录

​	**<font color='blue'>本视频对应王道书4.1.2+4.2.1+4.2.2+4.2.3</font>**

![image-20250903205353339](https://img.tynote.cn/img/typora/20250903205354091.png#800w)

![image-20250903205447032](https://img.tynote.cn/img/typora/20250903205447778.png#800w)

### 文件控制块

![image-20250903205711110](https://img.tynote.cn/img/typora/20250903205711727.png#800w)

![image-20250903210102208](https://img.tynote.cn/img/typora/20250903210103043.png#800w)

![image-20250903210426722](https://img.tynote.cn/img/typora/20250903210427282.png#800w)

### 目录结构

#### 单级目录结构

![image-20250903210729711](https://img.tynote.cn/img/typora/20250903210730273.png#800w)

#### 两级目录结构

![image-20250903210859335](https://img.tynote.cn/img/typora/20250903210900001.png#800w)

#### 多级目录结构

![image-20250903211044203](https://img.tynote.cn/img/typora/20250903211045248.png#800w)

![image-20250903211138745](https://img.tynote.cn/img/typora/20250903211139543.png#800w)

#### 无环图目录结构

![image-20250903211441562](https://img.tynote.cn/img/typora/20250903211442712.png#800w)

![image-20250903211644395](https://img.tynote.cn/img/typora/20250903211645045.png#800w)

#### 索引结点(FCB的改进)

![image-20250903211958438](https://img.tynote.cn/img/typora/20250903211959158.png#800w)

![image-20250903212045076](https://img.tynote.cn/img/typora/20250903212046099.png#800w)

### 总结

![image-20250903212153964](https://img.tynote.cn/img/typora/20250903212154642.png#800w)

## 文件的物理结构

​	**<font color='blue'>本视频对应王道书4.1.6</font>**

![image-20250903212606108](https://img.tynote.cn/img/typora/20250903212606754.png#800w)

![image-20250903212727668](https://img.tynote.cn/img/typora/20250903212728820.png#800w)

### 文件块、磁盘块

![image-20250903212812909](https://img.tynote.cn/img/typora/20250903212813712.png#800w)

![image-20250903212941675](https://img.tynote.cn/img/typora/20250903212942907.png#800w)

### 文件分配方式

#### 连续分配

![image-20250903213147918](https://img.tynote.cn/img/typora/20250903213148672.png#800w)

![image-20250903213320161](https://img.tynote.cn/img/typora/20250903213320796.png#800w)

![image-20250903213411940](https://img.tynote.cn/img/typora/20250903213413340.png#800w)

![image-20250903213439841](https://img.tynote.cn/img/typora/20250903213441185.png#800w)

![image-20250903213624505](https://img.tynote.cn/img/typora/20250903213625167.png#800w)

![image-20250903213811109](https://img.tynote.cn/img/typora/20250903214711111.png#800w)

#### 链接分配

##### 隐式链接

![image-20250903214802292](https://img.tynote.cn/img/typora/20250903214803069.png#800w)

![image-20250903214356287](https://img.tynote.cn/img/typora/20250903214356946.png#800w)

![image-20250903214707397](https://img.tynote.cn/img/typora/20250903214708049.png#800w)

##### 显式链接

![image-20250903215017666](https://img.tynote.cn/img/typora/20250903215018469.png#800w)

![image-20250903215451204](https://img.tynote.cn/img/typora/20250903215452007.png#800w)

![image-20250903215612619](https://img.tynote.cn/img/typora/20250903215613686.png#800w)

#### 索引分配

![image-20250903220543624](https://img.tynote.cn/img/typora/20250903220544497.png#800w)

![image-20250903220829177](https://img.tynote.cn/img/typora/20250903220830480.png#800w)

![image-20250903220954968](https://img.tynote.cn/img/typora/20250903220955820.png#800w)

![image-20250903221554129](https://img.tynote.cn/img/typora/20250903221555278.png#800w)

![image-20250903223214268](https://img.tynote.cn/img/typora/20250903223214959.png#800w)

![image-20250903223358875](https://img.tynote.cn/img/typora/20250903223359896.png#800w)

![image-20250903230020399](https://img.tynote.cn/img/typora/20250903230021265.png#800w)

![image-20250903230405229](https://img.tynote.cn/img/typora/20250903230406515.png#800w)

### 总结

![image-20250903230507715](https://img.tynote.cn/img/typora/20250903230508571.png#800w)

## 逻辑结构VS物理结构

![image-20250904154718523](https://img.tynote.cn/img/typora/20250904154719713.png#800w)

​	**其实本节内容也就是在讲，文件的逻辑结构是我们用户能看到，并且如何设计取决于用户，例如在有结构文件中，可以是顺序文件，而顺序文件可以是顺序存储，也可以是链式存储，此处假设若采用链式存储的顺序文件举例，也就是我们在文件数据的结构组织上看起来是链式的，实际上，在背后，这个文件数据的存储方式可以是采用连续的一片内存，也就是连续分配方式，也可以是离散的，而离散存储方式又分为链式分配方式和索引分配方式。综上，逻辑结构是表面上看到的文件数据之间的组织方式，物理结构（即分配方式）是背后的文件数据在磁盘中的存储方式。**

​	**所以，牢记两点就不容易混淆，1️⃣逻辑结构是指在用户看来，文件内部的数据应该是如何组织起来的；而物理结构指的是在操作系统看来，文件的数据是如何存放在外存中的。2️⃣要与《数据结构》中所讲的顺序存储和链式存储区分，在数据结构中，顺序存储和链式存储指的是物理结构方面。**

### C语言创建无结构文件

![image-20250904154901910](https://img.tynote.cn/img/typora/20250904154902892.png#800w)

![image-20250904155133300](https://img.tynote.cn/img/typora/20250904155134224.png#800w)

![image-20250904155258257](https://img.tynote.cn/img/typora/20250904155259367.png#800w)

![image-20250904155315568](https://img.tynote.cn/img/typora/20250904155316795.png#800w)

![image-20250904155343225](https://img.tynote.cn/img/typora/20250904155344503.png#800w)

### C语言创建顺序文件

![image-20250904155859552](https://img.tynote.cn/img/typora/20250904155900644.png#800w)

![image-20250904155924289](https://img.tynote.cn/img/typora/20250904155925526.png#800w)

![image-20250904155937893](https://img.tynote.cn/img/typora/20250904155939245.png#800w)

![image-20250904155954965](https://img.tynote.cn/img/typora/20250904155956272.png#800w)

### 顺序文件采用顺序存储

![image-20250904161209095](https://img.tynote.cn/img/typora/20250904161209934.png#800w)

### 链式存储的顺序文件采用链式分配

![image-20250904161629924](https://img.tynote.cn/img/typora/20250904161630703.png#800w)

### 逻辑结构

![image-20250904162042386](https://img.tynote.cn/img/typora/20250904162043299.png#800w)

![image-20250904163542302](https://img.tynote.cn/img/typora/20250904163543153.png#800w)

![image-20250904163724540](https://img.tynote.cn/img/typora/20250904163725388.png#800w)

### 总结

![image-20250904163846683](https://img.tynote.cn/img/typora/20250904163847610.png#800w)

## 文件存储空间管理

![image-20250904164057687](https://img.tynote.cn/img/typora/20250904164058869.png#800w)

![image-20250904164132064](https://img.tynote.cn/img/typora/20250904164133009.png#800w)

### 存储空间的划分与初始化

![image-20250904164723238](https://img.tynote.cn/img/typora/20250904164724016.png#800w)

### 存储空间管理

#### 空闲表法

![image-20250904165209052](https://img.tynote.cn/img/typora/20250904165210474.png#800w)

![image-20250904165355977](https://img.tynote.cn/img/typora/20250904165356774.png#800w)

![image-20250904165530795](https://img.tynote.cn/img/typora/20250904165643794.png#800w)

![image-20250904165648711](https://img.tynote.cn/img/typora/20250904165649532.png#800w)

#### 空闲链表法

![image-20250904165819879](https://img.tynote.cn/img/typora/20250904165820736.png#800w)

![image-20250904165941110](https://img.tynote.cn/img/typora/20250904165942230.png#800w)

![image-20250904170239992](https://img.tynote.cn/img/typora/20250904170240673.png#800w)

#### 位示图法

![image-20250904171347908](https://img.tynote.cn/img/typora/20250904171349043.png#800w)

![image-20250904171531293](https://img.tynote.cn/img/typora/20250904171532483.png#800w)

#### 成组链接法

​	**成组链接法（Group link）是UNIX系统中用于管理磁盘空闲块的一种方法。其原理是将空闲块分为若干组，每100个空闲块为一组，每组的第一空闲块存储下一组的物理盘块号和空闲块总数。当某组第一个空闲块号为特殊值（如0）时，标识其为最后一组。分配空闲块时，优先从第一组分配；若第一组分配完毕且仍有下一组地址，则将该组数据拷贝至第一组后继续分配。释放空闲块时，新释放的块会存入第一组；若第一组已满，则将现有组数据转移至新释放块，并更新指向关系。**

![image-20250904171629994](https://img.tynote.cn/img/typora/20250904171630904.png#800w)

![image-20250904173527915](https://img.tynote.cn/img/typora/20250904173528827.png#800w)

![image-20250904173616028](https://img.tynote.cn/img/typora/20250904173617004.png#800w)

![image-20250904173836619](https://img.tynote.cn/img/typora/20250904173838216.png#800w)

![image-20250904174823033](https://img.tynote.cn/img/typora/20250904174823854.png#800w)

![image-20250904174947543](https://img.tynote.cn/img/typora/20250904174948787.png#800w)

![image-20250904175057226](https://img.tynote.cn/img/typora/20250904175058038.png#800w)

![image-20250904175232029](https://img.tynote.cn/img/typora/20250904175233151.png#800w)

![image-20250904175302038](https://img.tynote.cn/img/typora/20250904175303386.png#800w)

### 总结

![image-20250904175447524](https://img.tynote.cn/img/typora/20250904175448320.png#800w)

## 文件的基本操作

![image-20250904181417639](https://img.tynote.cn/img/typora/20250904181418756.png#800w)

### 创建文件

![image-20250904181550278](https://img.tynote.cn/img/typora/20250904181551145.png#800w)

### 删除文件

![image-20250904181739779](https://img.tynote.cn/img/typora/20250904181740748.png#800w)

### 打开文件

![image-20250904181912662](https://img.tynote.cn/img/typora/20250904181914113.png#800w)

![image-20250904182154180](https://img.tynote.cn/img/typora/20250904182155484.png#800w)

### 关闭文件

![image-20250904182255970](https://img.tynote.cn/img/typora/20250904182257282.png#800w)

![image-20250904182339141](https://img.tynote.cn/img/typora/20250904182340262.png#800w)

### 读文件

![image-20250904182746749](https://img.tynote.cn/img/typora/20250904182747727.png#800w)

### 写文件

![image-20250904182910144](https://img.tynote.cn/img/typora/20250904182911141.png#800w)

### 总结

![image-20250904183029081](https://img.tynote.cn/img/typora/20250904183029981.png#800w)

## 文件共享

![image-20250904184641342](https://img.tynote.cn/img/typora/20250904184642517.png#800w)

### 基于索引结点的共享方式(硬链接)

![image-20250904184929717](https://img.tynote.cn/img/typora/20250904184930969.png#800w)

![image-20250904184950505](https://img.tynote.cn/img/typora/20250904184951758.png#800w)

![image-20250904185012516](https://img.tynote.cn/img/typora/20250904185013909.png#800w)

![image-20250904185044147](https://img.tynote.cn/img/typora/20250904185045436.png#800w)

### 基于符号链的软链接

![image-20250904185150676](https://img.tynote.cn/img/typora/20250904185151468.png#800w)

![image-20250904185221250](https://img.tynote.cn/img/typora/20250904185222519.png#800w)

![image-20250904185246970](https://img.tynote.cn/img/typora/20250904185248289.png#800w)

![image-20250904185338086](https://img.tynote.cn/img/typora/20250904185339362.png#800w)

![image-20250904185405573](https://img.tynote.cn/img/typora/20250904185406941.png#800w)

### 总结

![image-20250904185524932](https://img.tynote.cn/img/typora/20250904185526011.png#800w)

## 文件保护

![image-20250904185626483](https://img.tynote.cn/img/typora/20250904185627733.png#800w)

### 口令保护

![image-20250904185737018](https://img.tynote.cn/img/typora/20250904185738417.png#800w)

### 加密保护



![image-20250904190137354](https://img.tynote.cn/img/typora/20250904190138432.png#800w)

![image-20250904190224321](https://img.tynote.cn/img/typora/20250904190225903.png#800w)

### 访问控制

![image-20250904190331970](https://img.tynote.cn/img/typora/20250904190333643.png#800w)

![image-20250904190501882](https://img.tynote.cn/img/typora/20250904190532879.png#800w)

![image-20250904190536810](https://img.tynote.cn/img/typora/20250904190537647.png#800w)

![image-20250904190631082](https://img.tynote.cn/img/typora/20250904190632174.png#800w)

![image-20250904190746007](https://img.tynote.cn/img/typora/20250904190747129.png#800w)

![image-20250904190921881](https://img.tynote.cn/img/typora/20250904190922982.png#800w)

![image-20250904190951664](https://img.tynote.cn/img/typora/20250904190952956.png#800w)

![image-20250904191012992](https://img.tynote.cn/img/typora/20250904191014015.png#800w)

### 总结

![image-20250904191124510](https://img.tynote.cn/img/typora/20250904191125604.png#800w)

## 文件系统的层次结构

### 文件系统层次结构

![image-20250904191645328](https://img.tynote.cn/img/typora/20250904191646617.png#800w)

### 总结

![image-20250904191916671](https://img.tynote.cn/img/typora/20250904191917836.png#800w)

## 文件系统布局

​	**我们从一个磁盘出厂、物理格式化，再到逻辑格式化，来一步一步认识文件系统在外存当中是如何一步一步被建立的。**

![image-20250904192530995](https://img.tynote.cn/img/typora/20250904192531873.png#800w)

**坏扇区对操作系统来说也是透明的，因为坏扇区会被备用扇区在背后悄悄替代。**

![image-20250904192554889](https://img.tynote.cn/img/typora/20250904192556333.png#800w)

![image-20250904193144617](https://img.tynote.cn/img/typora/20250904193145676.png#800w)

**i结点区：所谓i结点，就是我们的索引结点，每个文件都会有一个已知对应的索引结点，Unix文件系统当中所有的索引结点都是连续存放在i结点区的，可以简单认为这个区就是一个超大的数组，而数组元素就是一个一个的索引结点。**

![image-20250904211057030](https://img.tynote.cn/img/typora/20250904211058168.png#800w)

**内存区分为用户区和内核区，内核区中有三个重要的东西，一个是目录的缓存，最近访问的一些目录的数据会被暂时缓存在内存中。除此之外还有两个很重要的数据结构，一个是系统文件打开表，整个系统只有一张，另一个是用户打开文件表，也可以称为进程打开文件表，每一个进程都会有一张，包含在进程的pcb中，记录了某个进程当前打开了哪些文件，这就是文件系统在内存中的结构。**

![image-20250904211401673](https://img.tynote.cn/img/typora/20250904211402538.png#800w)

![image-20250904211429581](https://img.tynote.cn/img/typora/20250904211430582.png#800w)

## 虚拟文件系统&文件系统挂载(安装)

### 普通的文件系统

​	**插入不同设备对应的文件系统不同，调用相同功能的函数时参数不同，对上层用户不友好。**

![image-20250904211916473](https://img.tynote.cn/img/typora/20250904211917272.png#800w)

### 虚拟文件系统

![image-20250904212017477](https://img.tynote.cn/img/typora/20250904212018665.png#800w)

![image-20250904212253453](https://img.tynote.cn/img/typora/20250904212254593.png#800w)

![image-20250904212557483](https://img.tynote.cn/img/typora/20250904212558313.png#800w)



![image-20250904212933292](https://img.tynote.cn/img/typora/20250904212934212.png#800w)

![image-20250904213101584](https://img.tynote.cn/img/typora/20250904213102373.png#800w)

### 文件系统挂载(mounting)

![image-20250904213421481](https://img.tynote.cn/img/typora/20250904213422710.png#800w)

![image-20250904213536749](https://img.tynote.cn/img/typora/20250904213538079.png#800w)

